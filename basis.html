<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Basis</title><link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="index.css"></head><body data-name="basis"><main class="sections-wrapper"><!--glossary--><section class="section" id="glossary"><div class="section-container"><h2 class="section-title">glossary</h2><article class="section-info"><img class="memory-img" src="images/basis/memory.jpg" alt="memory"></article><article class="section-info"><b>glossary</b><pre>
check in / sign up - зарегистрироваться
log in / sign in - авторизоваться (войти в систему)
validation - проверка
verification - подтверждение
deployment (rollout) - 'развёртывание', 'выкатка' продукта
rollback - откат к старому релизу (выкатывают старый релиз)
bypass - обходить
issue - проблема / выпуск (в т.ч. выпуск новой задачи)
outage - отключение, перебой в работе
contributors - авторы
uptime - время безотказной работы
batching - группировка
grant - предоставлять
teardown - удаление
sequence - последовательность
implicitly - неявно
occur - случаться
evaluate - оценивать
CDN — content delivery network
threshold - порог (типа breakpoint)
workaround - обходной прием, костыль
credentials - полномочия
vulnerabilities - уязвимости
scrollbar - полоса прокрутки (bar - панель)
re-crawl - переиндексация (в google)
chunks - фрагмент, кусок
affected - затронутый
crutch - костыль (обход)
command prompt - командная строка
ratio - коэффициент, соотношение
intersection - пересечение
viewport - область видимости
restrictions - ограничения
runtime - во время выполнения
+, -, *, / - sum, sub, mult, div
инвариант - нечто неизменяемое
гипертекст - это текст, содержащий ссылки на другие тексты


privacy policy - политика конфиденциальности
dispatch - отправка (вызов события)
parsing - чтение (разбор)
rendering - отображение (отрисовка)
alias - псевдоним для длинной команды (более короткий)
timestamp - отметка времени
fps - frames per second (кадров в секунду)
compatibility - совместимость
release - выпуск (новой версии)
extract - извлекать (из приложения в библиотеку)
hash - мешанина
token - знак
implementation - реализация, создание (метода)
expires - истекает (expires in 2 days)
teammate - товарищ по команде
utility - вспомогательный, полезный
toolkit - набор инструментов
aggregate - совокупность
expand/collapse - развернуть/свернуть
miscellaneous (misc) - разные
maintenance - поддержание (проекта)
match - соответствие/совпадение
fallback - резервный
feature - особенность
featuring - с участием
groso / neto - з/п до вычета налогов - groso, а neto - после
idle - неработающий, простаивающий
undo - отменить
preferences - настройки
attempts - попытки
submission - отправка (формы)
backdrop - фон (overlay в popup)
reboot - перезагрузка
tap - нажатие
pane - панель
invoiсe - счет
billing - выставление счета
approve - утвердить
e.g. - например
clipboard - буфер обмена
`` - строковые литералы для создания шаблонов
appearance - внешний вид
sketch - эскиз
wireframe - каркас
mock up - макет
прототип - схематичное изображение страницы или виджета перед созданием дизайна


MVP-версия - минимально жизнеспособный продукт (minimum viable product) —
             продукт, обладающий минимальными, но достаточными для удовлетворения
             первых потребителей функциями. Основная задача — получение обратной
             связи для формирования гипотез дальнейшего развития продукта
LTS-версия  - (long term support) это часть жизненного цикла программного обеспечения,
              которая означает, что стабильный релиз будет поддерживаться долгое
              время и будет считаться стандартной версией к распространению
Standalone-приложение vs SaaS - пример standalone - мобильное приложение Facebook. В то же
                                время веб-сайт Facebook будет являться SaaS, т.к. доступ к
                                нему осуществляется через браузер (другое приложение);
                                Standalone на примере наших виджетов - например отдельный
                                виджет tik-tok, который является частью social-feed
захардкодить - это когда ты что-то жостко прописываешь без возможности
               менять (анти-паттерн), от чего теряется гибкость (например,задать
               четкий размер: width: 20px)
анти-паттерны - полная противоположность паттернам. Если паттерны проектирования —
                это примеры практик хорошего программирования, то есть шаблоны решения
                определённых задач. То анти-паттерны — их полная противоположность
транслитерация - передача знаков одной письменности знаками другой (латиницей русские слова)
i18n (internationalization) - процесс разработки приложения, чтобы оно могло переключаться
                              на другой язык, не прибегая к программному изменению приложения
l10n (localization) - процесс добавления соответствующих ресурсов в ваше программное
                      обеспечение для поддержки определенного языка (локали)
a11y (accessibility) - доступность для людей с ограниченными способностями
boilerplate code - шаблонный код (boilerplate - шаблон), который должен быть
                   написан во многих местах практически без изменений
polyfill -  код, написанный в старом стандарте для замещения встроенных функций, которые не
            поддерживаются в старых браузерах. Например в IE 11 js движок понимает только
            стандарт ES5-, в котором нет методов Array.from() или Array.prototype.keys().
            А транспилер (babel) переписывает код, преобразовывая новые синтаксические
            конструкции (например async await; не путать со встроенными функциями) в старые
синтаксический сахар  — это синтаксические возможности, применение которых не влияет на
                        поведение программы, но делает использование языка более удобным
интерфейс — руль и педали это внешний интерфейс авто, а все
            что под капотом - внутренний скрытый интерфейс
внутренний интерфейс – методы и свойства, доступные из других методов класса,
                       но не снаружи класса
внешний интерфейс – методы и свойства, доступные снаружи класса
API - программный интерфейс приложения. Проще говоря, это то, что обеспечивает эффективный
      процесс коммуникаций между программами, использующими функции и ресурсы друг друга;
      то есть это набор публичных свойств и методов (внешний интерфейс) для взаимодействия
      с програмой
CLI (Command line interface) - интерфейс командной строки; также известен под названиями
                               «консоль» и «терминал»; он противопоставляется системам
                               управления программой на основе меню, а также различным
                               реализациям графического интерфейса
шаблонизатор — программа, позволяющая использовать html-шаблоны для генерации конечных
               html-страниц. Основная цель использования шаблонизаторов — это отделение
               представления данных от исполняемого кода. Часто это необходимо для
               обеспечения возможности параллельной работы программиста и верстальщика;
               в JS популярен шаблонизатор Handlebars
OKR  - (Objectives and Key Results -цели и ключевые результаты) метод, используемый в
       современном менеджменте для управления проектами. Позволяет синхронизировать
       командные и индивидуальные цели и обеспечить эффективный контроль над реализацией
       поставленных задач.
       OKR - это не задачи, а цели. OKR в Lattice, а задачи в Jira. Goals в Lattice
       разбиваются на key results. Один key result может объединять несколько
       задач из Jira. И по мере закрытия задач нужно закрывать key results, таким
       образом наглядно трекать кроцесс выполнения цели.
KPI (Key Performance Indicators) - ключевые показатели эффективности - то, что нам
                                   скажет, что мы достигли какой то цели
SERP - Search Engine Results Page


REST API —  (Representational State Transfer — «передача состояния представления»).
            По сути это API сервера: набор публичных свойств и методов сервера для
            взаимодействия с ним. В документациях прописывается правила взаимодействия:
            на какой url слать запрос (Endpoint), какого типа делать запрос, что отправлять
            в запросе...


функциональное програмирование - когда функции становятся объектами первого класса, то
                                 есть могут принимать другую функцию в качестве аргумента
                                 или возвращать другую функцию в качестве результата

обратная совместимость - например, SCSS понимат CSS или TS понимает JS, т.е. обратно совместим

refactoring - (переработка кода) процесс изменения внутренней структуры программы, не
              затрагивающий её внешнего поведения и имеющий целью облегчить понимание её
              работы (например, вынесение повторяющегося кода в ф-ии, подключение redux к
              приложению...). То есть рефакторинг, это когда поведение програмы одно и тоже,
              а код меняется

декомпозиция - разделение целого на части

обфускация — приведение исходного текста или исполняемого кода программы к виду, сохраняющему её
             функциональность, но затрудняющему анализ, понимание алгоритмов работы и модификацию
             при декомпиляции


бизнес-логика - это набор правил (условий), которым подчиняются объекты, сущности,
                классы и данные внутри программы.
                  Т.е. простыми словами это правила, заключенные в самом бизнесе,
                для которого написана программа.
                  Например, если товар отправляется со склада, то в накладной не может
                не быть поставщика этого товара и т.д.


compilation - преобразование программы, при котором используется исходный код
              программы, написанной на одном языке программирования в качестве
              исходных данных, и производится эквивалентный исходный код на другом
              языке программирования (т.е. языки с разными уровнями абстракции, в
              отличае от транспиляции).
              Например: JS движок V8 компилирует js в машинный код;
                        Brython компилирует Python в JS

transpilation - подвид компиляции (source-to-source compiler), при котором
                преобразование происходит для языка с тем же уровнем абстакции
                (например TS в JS) или в другую версию того же языка (Babel)

Дамп (dump – сбрасывать) – файл, включающий в себя содержимое базы данных (.sql файл).
                           Он содержит особые данные, благодаря которым можно легко
                           воссоздать копию БД

NDA (non-disclosure agreement) — это соглашение, в котором стороны договариваются о неразглашении
                                 конфиденциальной информации. В нём прописывают, какую конкретно
                                 информацию нельзя разглашать, и ответственность, наступающую при
                                 нарушении условий договора.
        </pre></article></div></section><!--console--><section class="section" id="console"><div class="section-container"><h2 class="section-title">Console</h2><article class="section-info"><pre>
        <b>навигация по директориям:</b>

pwd                     - показать путь к текущей папке (present working directory)
ls (dir на windows)     - показать все папки/файлы в проекте (без скрытых)
ls -a                   - показать все папки/файлы в проекте (со скрытыми)
cd &lt; path >             - сменить директорию
cd или cd ~             - переходит в домашний каталог (корень)


        <b>работа с папками/файлами:</b>

touch filename.**              - создать файл
mkdir &lt; folder >               - создать папку
rm -rf filename.**             - удалить файл (rm -rf .git/index.lock)
rm -r dirname/                 - удалить папку


        <b>misc:</b>

clear                          - очистить консоль
rm -rf node_modules && npm i   - быстро удалить и переустановить модули

git add . && git commit -m "message" && git push
        </pre></article></div></section><!--IDE's--><section class="section" id="ide"><div class="section-container"><h2 class="section-title">IDE's</h2><article class="section-info"><b>WebStorm</b><pre>
  <b>keyboard shortcuts:</b>

ctl + x                               - вырезать
ctl + d                               - дублировать строку
alt + click                           - мультикурсор
shift shift                           - поиск
ctl + shift + f                       - поиск в проекте
ctl + f                               - поиск в файле
ctl + r                               - заменить
ctl + alt + l                         - выровнять весь файл
ctl + alt + i                         - выровнять выбраный участок
ctl + alt + o                         - удаляет все неиспользуемые импорты
shift + alt + вверх/вниз              - переместит строку
ctl + /                               - закомментировать строку
ctl + shift + /                       - закомментировать несколько строк
ctl + z                               - undo
ctl + shift + z                       - redo
alt + j                               - выделить следующее вхождение
ctl + shift + alt + j                 - выделить все вхождения
ctl + shift + u                       - toggle uppercase
alt + enter                           - добавить импорт выбраному участку



  <b>snippets:</b>

shift shift  -->  Live Templates  -->  add Template Group  -->  add Live Template
-->  add abbreviation / description  -->  add code ( $firstTabName$ )



  <b>пример TODO:</b>

// @TODO использовать хук useSettings, получающий контекст виджета
...(block.type === 'form' ? formBlockProps : {})
        </pre></article><article class="section-info"><b>VSC</b><pre>
  <b>settings.json:</b>

{
  "breadcrumbs.enabled": false,
  "editor.fontSize": 16,
  "editor.lineHeight": 23.5,
  "editor.minimap.enabled": false,
  "editor.tabSize": 2,
  "editor.autoIndent": "brackets",
  "editor.tabCompletion": "on",
  "editor.insertSpaces": true,
  "editor.detectIndentation": false,
  "editor.hover.enabled": true,
  "editor.links": false,
  "editor.matchBrackets": "never",
  "editor.occurrencesHighlight": false,
  "editor.smoothScrolling": true,
  "editor.glyphMargin": false,
  "editor.multiCursorModifier": "ctrlCmd",
  "editor.parameterHints.enabled": false,
  "editor.bracketPairColorization.enabled": false,
  "editor.quickSuggestions": {
    "other": false,
    "comments": false,
    "strings": false
  },
  "editor.tokenColorCustomizations": {
    "[Spacegray Eighties Dark]": {
      "textMateRules": [
        {
          "scope": "entity.name.tag.js",
          "settings": {
            "foreground": "#7b9aaa"
          }
        }
      ]
    },
    "comments": "#8f8f8f"
  },
  "emmet.triggerExpansionOnTab": true,
  "explorer.compactFolders": false,
  "explorer.openEditors.visible": 0,
  "explorer.autoReveal": false,
  "explorer.decorations.colors": false,
  "files.autoSave": "onFocusChange",
  "terminal.integrated.profiles.windows": {
    "WSL": {
      "path": [
        "C:\\WINDOWS\\System32\\wsl.exe"
      ]
    }
  },
  "terminal.integrated.defaultProfile.windows": "WSL",
  "terminal.integrated.fontSize": 15,
  "workbench.iconTheme": "vscode-icons-mac",
  "vsicons.presets.hideExplorerArrows": true,
  "workbench.startupEditor": "newUntitledFile",
  "workbench.colorTheme": "Spacegray Eighties Dark",
  "workbench.colorCustomizations": {
    "editorIndentGuide.background": "#3b3b3b",
    "editorIndentGuide.activeBackground": "#555555",
    "statusBar.background" : "#252525",
    "statusBar.foreground" : "#808080",
    "tab.activeBorder" : "#5afff1",
    "sideBar.foreground": "#afafaf",
    "editor.foldBackground": "#2c2c2c"
  },
  "workbench.editor.tabSizing": "shrink",
  "workbench.tree.indent": 18,
  "workbench.tree.renderIndentGuides": "none",
  "subtleBrackets.style": {
    "borderColor": "#ffffff",
    "borderWidth": "1.5px"
  },
  "window.title": "${activeEditorLong}",
  "git.decorations.enabled": false,
  "auto-close-tag.SublimeText3Mode": true,
  "css.validate": false,
  "scss.validate": false,
  "javascript.validate.enable": false,
  "liveServer.settings.donotShowInfoMsg": true,
  "open-in-browser.default": "chrome",
  "extensions.ignoreRecommendations": true,
  "gitlens.codeLens.authors.enabled": false,
  "gitlens.codeLens.recentChange.enabled": false,
  "gitlens.currentLine.enabled": false,
  "gitlens.menus": {
    "editor": false,
    "editorGroup": {
      "blame": true,
      "compare": false
    }
  },
  "diffEditor.ignoreTrimWhitespace": false
}


  <b>extensions:</b>

Auto Close Tag
Auto Import - ES6, TS, JSX, TSX
Auto Rename Tag
Code Runner
EditorConfig for VS Code
Git Graph
GitLens — Git supercharged
IntelliSense for CSS class names in HTML
language-stylus
Live Server
Multiple clipboards for VSCode
open in browser
Path Intellisense
Project Manager
Sass
SFTP
Spacegray VSCode
Subtle Match Brackets
VS Color Picker
vscode-icons-mac
vscode-styled-components


  <b>keybindings.json:</b>

[
  {
    "key": "ctrl+b",
    "command": "-workbench.action.toggleSidebarVisibility"
  },
  {
    "key": "ctrl+b",
    "command": "editor.action.clipboardCutAction",
    "when": "textInputFocus && !editorReadonly"
  },
  {
    "key": "ctrl+x",
    "command": "-editor.action.clipboardCutAction",
    "when": "textInputFocus && !editorReadonly"
  },
  {
    "key": "ctrl+x",
    "command": "redo",
    "when": "textInputFocus && !editorReadonly"
  },
  {
    "key": "ctrl+y",
    "command": "-redo",
    "when": "textInputFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+r",
    "command": "-revealFileInOS",
    "when": "!editorFocus"
  },
  {
    "key": "shift+alt+r",
    "command": "editor.action.reindentselectedlines"
  },
  {
    "key": "ctrl+shift+/",
    "command": "editor.action.blockComment",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+a",
    "command": "-editor.action.blockComment",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+d",
    "command": "editor.action.copyLinesDownAction",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+shift+d",
    "command": "-workbench.view.debug"
  },
  {
    "key": "ctrl+shift+d",
    "command": "editor.action.copyLinesDownAction",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+down",
    "command": "-editor.action.copyLinesDownAction",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+k ctrl+l",
    "command": "editor.action.transformToLowercase"
  },
  {
    "key": "ctrl+k ctrl+u",
    "command": "-editor.action.removeCommentLine",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+k ctrl+u",
    "command": "editor.action.transformToUppercase"
  }
]


  <b>C:\Users\Anton\AppData\Roaming\Code\User\snippets\javascript.json:</b>

{
  "Console Log": {
    "prefix": "log",
    "body": [
      "console.log('---', $1)"
    ]
  }
}
        </pre></article></div></section><!--git--><section class="section" id="git"><div class="section-container"><h2 class="section-title">git</h2><article class="section-info"><b>theory</b><pre>
            <b>1. Настройки git</b>
  git config --global user.name 'Anton'
  git config --global user.email 'anton.byshok@gmail.com'
Если мы не задали конфиг в конкретном репозитории, то он будут браться из глобальных
настроек. Чтобы посмотреть все настройки: git config --list


            <b>2. Инициализация Git</b>
  Создаем  репозиторий в папке с проектом. Либо правой кнопкой мыши и git init here.
Либо открываем Git Bash и прописываем комманду git init. После инициализации появляется
скрытая папка .git (база данных git, служебная дирректория)


            <b>3. Двуступенчатая система изменений в репозиторий</b>
  Одна из важнейших особенностей git, это то, что система изменений в репозиторий
двуступенчатая (index - repository):

   <span>(файлы проекта)</span>        |      <span>(эти 2 зоны принадлежат репозиторию git; данные о них в /.git)</span>
                          |
- working directory       |     - index (хранит список файлов          - local repository (HEAD)
                          |       проекта, отслеживаемых git;            (хранится вся история
                          |       является промежуточным                 разработки проекта)
                                  хранилищем изменений)
                --> git add (stage)                         --> git commit

  Для внесения изменений в git сначало добавляем файлы проекта в index (git add &lt;file(s)>)
и затем, когда мы доделали какой то кусок работы, сохраняем изменения из index в 3-ей зоне -
в repository (git commit -m 'my_comment'). И в нем уже хранится вся история разработки проекта

      Проверять статус index можно командой git status, которая может выдать такие уведомления:
- Changes not staged for commit (список файлов, которые отслеживаются git, но которые были
                                изменены/удалены; и чтобы их закомитить, нужно опять добавить
                                их в index перед комитом)
- Untracked files (список файлов, которые не отслеживаются, т.е. ранее не добавлялись в index,
                  например новые файлы; чтобы их закомитить, также нужно добавить в index перед
                  комитом)
- Changes to be commited (список файлов, которые были добавлены в index и готовы быть закомичены)
- Unmerged paths (список файлов с неразрешенными конфликтами при слиянии)

  Если добавить измененный файл в index, а потом еще что то поменять в нем, то git status
покажет что он будет одновременно в 2 списках: Changes to be commited и Changes not staged
for commit. То есть при коммите в репозиторий попадет версия, которая была добавленв в
index (первое изменение), а второе изменение нет. Его нужно сначало добавить в index

  Если удалить файл, который трекается (ранее добавлялся в index), то его так же после удаления
нужно проиндексировать перед комитом, чтобы он так же удалился из локального репозитория


            <b>4. Ветки / HEAD / tag</b>
ветка - это ссылка на 1 конкретный commit (последний в ветке). Но при этом находящимися в ветке
        называют все commit'ы, которые находятся на пути от вершины вниз по цепочке от родителей.
        Ветки можно увидеть в .git/refs/heads; commit, на который указывает ветка, называют ее
        вершиной
HEAD - используется чтобы git репозиторий понимал где мы находимся сейчас; HEAD хранит ссылку
       на текущую ветку; технически HEAD может хранить ссылку на коммит, но это редкое состояние
       'detached HEAD' (отделенная HEAD; возникает при переключении на определенный коммит в
       ветке); alias для HEAD является @

  При переключении на другую ветку, если есть незакомиченные изменения (не важно внесены
они в index или нет), то git будет ругаться, только в том случае, если изменения находятся
в файле, который различается между ветками (есть конфликт). А если конфликтных различий нет,
то переключение пройдет успешно, а незакомиченые файлы пометятся 'M' в консоле. Нужно быть
аккуратными, т.к. в переключаемую ветку попадут измененнные и добавленные в index.
  Но вообще лучше либо закомитить изменения перед переключением, либо сбросить working
directory и index до состояния последнего коммита, чтобы git status был 'чист'

  теги в git - это ссылки на определенные коммиты по названию тега. То есть можно назвать
тег, а потом ссылаться на него по названию. Иными словами тег - это метка коммита,
использующаяся для удобного переключения по понятному названию тега.
  Например, можно маркировать релизы: git tag v1.1.0 &lt;commitHash>


            <b>5. Игнорирование файлов (.gitignore)</b>
  node_modules       - игнорировать все папки node_modules в проекте
  dist               - игнорировать все папки dist в проекте
  folderName/.html   - игнорировать файлы с определенным расширением в folderName
  *drawio.dtmp       - игнорировать все файлы с определенным расширением в проекте

  Чтобы смотреть как бы глазами гита не из корневой папки, а из другой, нужно зайти
в нее (cd folderName). После этого файлы будут показываться относитель нее.
  git status --untracked-files=all   - показать все неотслеживаемы (untracked) файлы
  * .gitignore нужно заливать в репозиторий


            <b>6. SSH</b>
  Лучше использовать соединение с защищенным протоколом SSH вместо HTTPS. С помощью ключей
SSH вы можете подключаться к GitHub без указания имени пользователя или пароля при каждом
посещении.
Для использования SSH нужны 2 связанных сгенерированных ключа:
  - публичный (аналог замка) - лежит на сервере (github),
  - приватный (аналог ключа от замка) - лежит в компьютере,
    может быть несколько для разных компов
Для генерирования ключа на Windows пишем в Git Bash (или wsl):
  ssh-keygen -t rsa -b 4096 -C "your_email@example.com"     -  email моего github аккаунта
Далее указываем куда установить ключи (жмем enter по дефолту ( ~/.ssh/ )) и придумываем пароль
passphrase (можно ничего не вводить).
Добавление вашего SSH-ключа в ssh-agent:
  eval $(ssh-agent -s)
  затем
  ssh-add ~/.ssh/id_rsa
Теперь добаляем публичный SSH-ключ в свою учетную запись GitHub:
  clip &lt; ~/.ssh/id_rsa.pub
  затем
  на github Settings -> SSH and GPG keys -> вводим имя в Title и вставляем ключ из буффера

<b>* не обязательно для каждого сервера иметь свой ключ,
  можно один для всех (например одинаковый на github и gitlab)</b>


  Если необходимо положить ключи в другую не стандартную папку (не ~/.ssh/) или кастомно
назвать ключи, например, вместо id_rsa назвать _id_rsa, или если ключей несколько для разных
акаунтов, то необходимо создать конфигурационный файл ~/.ssh/config, в котором указать:
Host (host aliases: github, bitbucket), HostName, User, IdentityFile (private key)

Host github_corp
  HostName github.com
  User anton
  IdentityFile ~/.ssh/id_rsa

Host bitbucket
  HostName bitbucket.org
  User anton
  IdentityFile ~/.ssh/_id_rsa

  При клонировании после git@ указываем Host (alias для HostName), по дефолту
при клонировании репозитория из github после git@ идет github.com.
  * Для репозиториев на одном хостинге (с одинаковым HostName) нужно использовать разные
alias'ы (например, bitbucket-corporate и bitbucket-personal) т.к. HostName одинаков, а для
разных серверов в этом нет необходимости, поэтому для удобства лучше называть Host также как
и HostName.
git clone git@github_corp:company/project.git
git clone git@bitbucket:company/project.git

  Добавление связаных удаленных репозиториев с моим
локальным (git remote add &lt;repoName> &lt;repoUrl>):
git remote add one git@github_corp:webmag-anton/test.git
git remote add two git@bitbucket:company/project.git

  Теперь можно запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
репозиторий &lt;repoName> (git push &lt;repoName> &lt;myBranchName>); если на удаленном
репозитории нет такой ветки (&lt;myBranchName>), то она создастся:
git push github_repo_name anton
git push bitbucket_repo_name anton


           подитоживая, для добавления 2-го ssh-ключа, например, в bitbucket:
1) ssh-keygen -t rsa -b 4096 -C "anton.byshok@gmail.com"
2) Enter file in which to save the key (/c/Users/anton/.ssh/id_rsa):
   /c/Users/anton/.ssh/id_rsa_bitbucket
3) open terminal in in ~/.ssh and type: touch config
4) in ~/.ssh/config

Host github.com
  HostName github.com
  User anton
  IdentityFile ~/.ssh/id_rsa

Host bitbucket.org
  HostName bitbucket.org
  User anton
  IdentityFile ~/.ssh/id_rsa_bitbucket

5) eval $(ssh-agent -s)
6) ssh-add ~/.ssh/id_rsa
  then
  ssh-add ~/.ssh/id_rsa_bitbucket
7) clip &lt; ~/.ssh/id_rsa_bitbucket.pub
  затем
  на bitbucket Personal settings -> SSH keys ->
  вводим имя ключа в Label и вставляем ключ из буффера обмена

8) при передачи данных может возникнуть такое сообщение:
The authenticity of host 'bitbucket.org (18.205.93.0)' can't be established.
RSA key fingerprint is SHA256:zzXQOXSRBEiUtuE...
Are you sure you want to continue connecting (yes/no/[fingerprint])?
  Пишем yes, после чего в ~/.ssh в файле known_hosts добавится
bitbucket.org,18.205.93.0 ssh-rsa AAAAB3Nz...
        </pre></article><article class="section-info"><b>forking</b><pre>
  Можно форкнуть чей то репозиторий на github (нажать кнопку Fork) - это скопирует репозиторий
в мой аккаунт. Затем вносятся изменения в скопированный репозиторий и далее авторам исходного
проекта предлагается принять мои изменения при помощи 'pull request'.
  <b>Исходный проект называют upstream, мой форк - origin, клонированый проект - локальная копия</b>
        </pre></article><article class="section-info"><b>repositories: local ⇔ remote</b><pre>
  <b>Чтобы связать и отправить локальный репозиторий</b> (папка, в которой инициализирован
git) <b>на github репозиторий</b>, необходимо сначало создать репозиторий на github, а затем:

1. git remote add origin https://github.com/webmag-anton/git-test.git
2. git push -u origin master
где   remote – удаленный репозиторий
      add    – добавить
      origin – псевдоним репозитория (по дефолту origin), можно назвать по другому
      https://github.com/webmag-anton/git-test.git – адрес созданного мной репозитория git-test
      -u      – ключ для запоминания логина при пуше
      origin  – псевдоним  удаленного  репозитория
      master  – имя текущей локальной ветки



  <b>Чтобы загрузить (клонировать) удаленный репозиторий на свой компьютер:</b>
git clone git@github.com:webmag-anton/git-test.git
  При клонировании репозитория, клонируется не только master ветка, а все удалённые
ветки. Просто они имеют префикс origin/удалённая_ветка. А вот отслеживаемой становится
только ветка master -> origin/master!
  Для того, чтобы сделать ещё одну отслеживаемую ветку - переключитесь на удалённую
и выполните создание локальной ветки. Всё это можно сделать одной командой:
git checkout --track -b local_branch_name origin/remote_branch_name
        </pre></article><article class="section-info"><b>glossary</b><pre>
origin          - дефолтное имя клонированного из github удаленного репозитория
master          - дефолтное имя изначальной (главной) ветки
ветка           - ссылка на 1 конкретный commit (последний в ветке)
HEAD            - ссылка на текущую ветку (на ее последний commit)

alias           - псевдоним для длинных команд
@               - это alias для HEAD
@~              - ссылка на предпоследний коммит в текущей ветке
@~4             - (эквивалент HEAD~4) ссылка на 5 с конца коммит в текущей ветке

commit-id      - (&lt;commitHash>) первые 4 символа коммита: c73b или c73b4b7
        </pre></article><article class="section-info commands-article"><b>main commands</b><pre>
git help command_name                                       - просмотр докумментации комманды
git config --global core.autocrlf true                      - такая установка гарантирует, что ваш репозиторий можно будет
                                                              использовать на других платформах, сохраняя CRLF в вашем рабочей
                                                              папке. Поэтому параметр true рекомендован для Windows
git config --global alias.st status                         - создали глобальный алиас 'st' для команды status
git config --global alias.last log --oneline --graph
                                   --decorate --all         - информативный лаконичный log (список коммитов),
                                                              пример для вывода последних 3-х: git last -3
git config --global alias.commitall '!git add .;git commit' - проиндексировать и затем закомитить все измененные
                                                              файлы, включая неотслеживаемые (т.е. до этого не добавлявшиеся
                                                              в index git'a); пример: git commitall -m 'initial'
git status                                                  - проверка статуса index
git log                                                     - вывести список коммитов с дополнительными данными текущей
                                                              ветки (выход q)
git reflog                                                  - показывает историю ваших действий; используя reflog, вы можете
                                                              вернуться в прошлое, отменяя почти любые действия, сделанные в Git.
                                                              Даже если это были rebase или reset; чтобы изменить нужное состояние,
                                                              нужно запустить checkout, используя абсолютную ссылку, например git
                                                              checkout 1234568 или относительную ссылку: git checkout HEAD@{3} и вы
                                                              окажетесь в независимом (detached) состоянии HEAD, из которого можно
                                                              создать новую ветвь. Вот и всё, все операции после вышеуказанного
                                                              состояния отменены

git add &lt;file(s)>                                           - добавить файл в индекс (stage); после коммита файл удаляется
                                                              из индекса, так что нужно повторно добавлять в индекс перед коммитом!
git add .                                                   - проиндексировать все файлы из текущей директории, что бы не
                                                              указывать каждый
git rm --cached &lt;file>                                      - если по ошибке проиндексировали лишние файлы, или которые
                                                              забыли добавить в игнор, то их можно удалить из индекса (unstage)
git commit -m 'my_comment'                                  - создать снимок состояния проиндексированных файлов в рабочей
                                                              дерриктории; в случае чего можно откатится до этого состояния
git commit --amend --no-edit -m 'my_comment'                - ключ --amend позволяет объединить проиндексированные изменения
                                                              с предыдущим коммитом без создания нового, но дата коммита обновляется;
                                                              коментарий обновится на новый; ключ --no-edit для того, чтобы сообщение
                                                              осталось без изменения;
   commit без промежуточного индексирования (3 варианта):
git commit -am 'my_comment'                                 - commit всех измененных файлов без промежуточного добавления в индекс;
                                                              единственный нюанс, что делается commit только ранее добавлявшихся
                                                              (отслеживаемых) файлов из working directory, которые мы поменяли;
                                                              новосозданные файлы не закомитятся без предварительного индексирования
git commit -m 'my_comment' &lt;file(s)>                        - commit конкретных измененных файлов без промежуточного добавления
                                                              в индекс; так же как и с флагом -a, этот вариант применится только
                                                              для уже ранее треканых файлов (ранее индексировавшихся)
git commitall (alias)                                       - использовать созданый alias commitall:  git commitall -m 'descr'

git show                                                    - показывает содержание коммита

git checkout -- &lt;filename>                                  - допустим мы закоммитили файл, а потом изменили его и поняли
                                                              что нужно откатиться до коммита
git checkout -f                                             - допустим мы закоммитили несколько файлов, а потом изменили их и поняли
                                                              что нужно откатиться до коммита (то есть откатить все файлы до последнего
                                                              коммита; откатит и проиндексированые файлы, т.е. отменит индексацию); но
                                                              не удалит неотслеживаемые файлы (ранее не индексировавшиеся), которых
                                                              не было в проекте в последнем комите; для их удаления нужно дополнительно
                                                              вызвать команду  git clean dxf
git clean -dxf                                              - удаляет неотслеживаемые (untracked) файлы и папки из working directory

git diff --name-only &lt;nameBr> [&lt;repoName>/]&lt;nameBr>         - показывает файлы, в которых есть отличая между ветками, т.е. последними
                                                              коммитами на них; удобно смотреть перед слиянием
git checkout &lt;commitHash>                                   - переключиться на определенный коммит по его hash (виден в git log/reflog);
                                                              при этом возникнет состояние 'detached HEAD' (отделенная HEAD), т.е.
                                                              HEAD будет указывать не на вершину ветки; и при коммите не из последнего
                                                              коммита в ветке возникнут коммиты, не принадлежащие ни одной ветке, так
                                                              лучше не делать; обычно git checkout &lt;commitHash> используют просто для
                                                              просмотра какого то коммита; что бы переключиться на последний коммит
                                                              на ветке нужно переключиться на эту ветку (git checkout master)

git reset --hard &lt;commitHash>                               - бывает что мы замечаем ошибку не сразу, а когда она уже в репозитории
                                                              и хотелось бы отменить последний коммит или несколько и поменять там
                                                              что то (можно переключиться и в коммит другой ветки, от которой была
                                                              создана наша); при откате на нужный коммит, коммиты, которые шли после
                                                              него удаляться и на них теперь нельзя переключиться, их как будто и не
                                                              было; хотя конечно можно, git не сразу подчищает;
                                                              пример отмены последнего мержа (коммита слияния):   git reset --hard @~
                                                              (@ - это alias для HEAD (ссылка на текущую ветку), а ~ - это родительский
                                                              коммит, то есть предпоследний, до которого мы хотим откатиться)
                                                              --hard означает, что после отката в определенный коммит сбросится и
                                                              рабочая директория (в файлах не будут изменения от коммита, из которого
                                                              делали reset) и index.
                                                              --mixed (default, git reset &lt;commitHash>) означает сброс index, но в
                                                              файлах останутся изменения от коммита, из которого делали reset.
git reset --soft &lt;commitHash>                               - ресет с сохранением изменений в working directory и index (сделаных
                                                              в коммите, от которого мы переключаемся в нужный по его хэшу). В основном
                                                              мягкий ресет используется для отмены последнего комита, при этом оставляя
                                                              все подготовленные для него данные.
                                                              Удобно для отмены коммита, если забыли что то довнести в него или поняли
                                                              что нужно что то поменять. Например,  git reset --soft @~

git revert &lt;commitHash>                                     - отменяет действия прошлых коммитов, создавая новый, содержащий все
                                                              отменённые изменения. Т.е. ревертнутый коммит(ы) не удалится из истории,
                                                              но добавится новый, в котором будут отмененные изменения, произошедшие в
                                                              указанном коммите(ах).
                                                              Зачем использовать её вместо других решений? Это единственный безопасный
                                                              способ, так как он не изменяет историю коммитов. Обычно используют в
                                                              публичных ветвях, где изменение истории нежелательно

git branch                                                  - список локальных веток
git branch -a                                               - список локальных и удаленных веток
git branch &lt;branchName>                                     - создания новой ветки от текущей
git branch -d &lt;branchName>                                  - удаление ветки
git checkout &lt;branchName>                                   - переключение в нужную ветку
git checkout -b &lt;branchName>                                - создание и переключение в созданную ветку от текущей
git branch -m &lt;oldname> &lt;newname>                           - переименовать ветку (без &lt;oldname> - текущую)

git merge &lt;branchName>                                      - смержить текущую локальную ветку с локальной &lt;branchName>, т.е.
                                                              указываем из какой ветки мы хотим добавить изменения в текущую ветку
git merge &lt;repoName>/&lt;repoNameBranch>                       - смержить ветку &lt;repoNameBranch> из подтянутого (fetch) удаленного
                                                              репозитория &lt;repoName> с моей локальной текущей веткой
git merge &lt;nameBr> --no-commit                              - автомерж без создания коммита слияния; бывает что в файле нет конфликта, но,
                                                              например, в разные строки кода добавляются 2 взаимоисключающие функции из
                                                              сливаемых веток; git автоматически добавил бы обе эти функции в коммит, но
                                                              нам этого не нужно; чтобы была возможность в ручном режиме выбирать нужный
                                                              вариант в каждом из различающихся файлов при слиянии и нужен --no-commit
git checkout --ours[theirs] &lt;filename>                      - разрешения конфликта при merge'е в пользу нашей ветки (--ours) или ветки, в
                                                              которую мы вливаем нашу (--theirs) в конкретном конфликтном файле &lt;filename>
git checkout --merge &lt;filename>                             - допустим мы разрешили конфликт в определенном файле в пользу нашей ветки, но
                                                              после этого поняли, что нужно выбрать в пользу сливаемой ветки; для этого
                                                              нужно вернуть версию файла с маркерами конфликта и выбрать нужный вариант
git merge --abort                                           - допустим мы видим много конфликтов при слиянии и решаем вообще его отменить;
                                                              в отличае от git reset --hard (без указания коммита отката предполагается
                                                              последний), git merge --abort не трогает незакомиченнные изменения в
                                                              неотслеживаемых файлах, то есть в файлах, ни разу не добавляемых в index

git branch --track &lt;locBrNm> &lt;repoName>/&lt;remBrNm>           - создание локальной ветки &lt;locBrNm> от удаленной &lt;remBrNm> (нужно
                                                              подтянуть &lt;remBrNm>, если нужно, с помощью git fetch &lt;repoName>),
                                                              которая отслеживает удаленную ветку &lt;remBrNm> репозитория &lt;repoName>;
                                                              флаг --track можно использовать только при создании новых веток
git branch &lt;myBrNm> --set-upstream-to &lt;repoNm>/&lt;remBrNm>    - установка существующей локальной ветке &lt;myBrNm> отслеживание
                                                              удаленной ветки &lt;remBrNm> из репозитория &lt;repoNm> (после этого, при
                                                              git pull, &lt;remBrNm> ветка будет заливаться в локальную &lt;myBrNm>, т.к.
                                                              она отслеживается локальной &lt;myBrNm>)

git clone &lt;repoUrl>                                         - загрузить удаленный репозиторий в локальную дирректорию (по
                                                              дефолту удаленный репозиторий имеет имя origin)
git remote                                                  - показывает существующие удаленные репозитории, связанные с
                                                              локальным репозиторием
git remote add &lt;repoName> &lt;repoUrl>                         - добавляем очередной связаный удаленный репозиторий с моим локальным,
                                                              например:  git remote add origin https://github.com/webmag-anton/test.git
git remote rm &lt;repoName>                                    - удаляем свзанный удаленный репозиторий &lt;repoName> (git remote rm sec_repo)
git remote set-url origin new.git.url/here                  - для изменения/установки удаленного репозитория, чтобы, например, при переезде
                                                              из bitbucket на gitlab, локальный проект отслеживал другую удаленную репу
git fetch &lt;repoName>                                        - подтянуть изменения со всех веток и новые ветки репозитория &lt;repoName>
git pull &lt;repoName> &lt;remoteBranchName>                      - подтянуть в .git (fetch) + смержить &lt;remoteBranchName> ветку из
                                                              удаленного репозитория &lt;repoName> с моей локальной активной веткой
                                                              ( pull = fetch + merge )
git push &lt;repoName> &lt;myBranchName>                          - запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
                                                              репозиторий &lt;repoName>, например:
                                                              git push origin master;
                                                              если на удаленном репозитории нет такой ветки (&lt;myBranchName>), то она
                                                              создастся !
                                                              Обычно Git позволяет пушить изменения только в том случае, если история
                                                              коммитов вашей локальной ветки совпадает с веткой удаленного репозитория.
                                                              --force отменяет это ограничение, то есть позволяет принудительно
                                                              перезаписать историю коммитов вашей локальной ветки в ветку удаленного
                                                              репозитория. Например, если в удаленном репозитории есть более свежие
                                                              коммиты сторонних разработчиков, то их сначало нужно подтянуть и выполнить
                                                              слияние, а потом пушить свои коммиты. Но, для принудительной перезаписи
                                                              удаленной ветки добавляем флаг --force. После этого история коммитов из
                                                              локального репозитория будет скопирована в удаленный, замещая при этом
                                                              все предыдущие записи. Поэтому использовать --force нужно аккуратно только
                                                              в исключительных ситуациях
git push &lt;repoName> &lt;myBranchName>:&lt;remoteBranchName>       - запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
                                                              репозиторий &lt;repoName> в его ветку &lt;remoteBranchName>


git checkout --track -b &lt;myBrNm> &lt;repoName>/&lt;remBrNm>       - при клонировании репозитория отслеживаемой становится только ветка
                                                              master. Чтобы сделать ещё одну отслеживаемую ветку - создаем и
                                                              переключаемся на ветку &lt;myBrNm> (создастся не от текущей, а от &lt;remBrNm>),
                                                              которая будет отслеживать удаленную ветку &lt;remBrNm> репозитория &lt;repoName>;
                                                              &lt;myBrNm> и &lt;remBrNm> удобно назвать одинаково. Перед этим нужно создать
                                                              ветку на сервере и подтянуть в локальный репозиторий (git fetch &lt;repoName>)
git checkout --no-track -b &lt;myBrNm> &lt;repoName>/&lt;remBrNm>    - создание локальной ветки &lt;myBrNm> (и переключение в нее) от
                                                              удаленной &lt;repoName>/&lt;remBrNm> без отслеживания

git fetch && git checkout feature/DEV-367                   - после создания ветки на сервере можно подтянуть ее в локальный
                                                              репозиторий и сразу создать и переключиться на одноименную локальную
                                                              ветку 1 командой, причем локальная ветка будет отслеживать удаленную
                                                              (в примере подтянул удаленную ветку feature/DEV-367 и сразу создал и
                                                              переключился на одноименную локальную, которая трекает удаленную)

git stash                                                   - допустим мы работаем над проектом, но нас попросили переключиться на
                                                              другую ветку что бы помочь кому то решить задачу. Просто так нельзя
                                                              переключиться, нужно сделать коммит моих изменений (страховка от git).
                                                              Но нам не нужно еще делать коммит, т.к. например функция написана
                                                              наполовину. Можно спрятать изменения с помощью git stash, затем
                                                              переключиться на нужную ветку, проделать там работу, а затем при
                                                              возврате на свою, вернуть изменения командой git stash pop;
                                                              при этом git stash не спрячет непроиндесированные (неотслеживаемые) файлы
git stash pop                                               - вернуть спрятанные изменения и очистить тайник; git stash apply - для
                                                              возврата спрятанного без очистки тайника, но луше с очисткой;
                                                              важно возвращать изменения на той же ветке, на которой прятали, т.к. у
                                                              git stash нет привязки к ветке

git rebase &lt;baseBranchName>                                 - локальный rebase с указанием ветки, на которую нужно осуществить
                                                              перебазирование текущей ветки; т.е. коммиты, если они есть, последовательно
                                                              накладываются на базовую ветку (ее последний коммит).
                                                              Т.е. наша ветка теперь будет начинаться с последнего коммита той ветки,
                                                              которую мы указали при rebase; и соответственно мы получим весь код базовой
                                                              ветки, которого до этого не было в проекте.
                                                              Эта операция альтернативна merge'у
git rebase &lt;repoName>/&lt;repoNameBranch>                      - перебазирование удаленной ветки &lt;repoNameBranch> из репозитория &lt;repoName>
                                                              в локальную текущую ветку
git rebase --abort                                          - если, например, при пребазировании возникли конфликты и мы решили отменить
                                                              rebase вместо разрешения конфликтов
git rebase --continue                                       - продолжить перебазирование (наложить следующие комиты из своей ветки) после
                                                              разрешения конфликтов в указанном коммите, информация о котором выводится
                                                              при перебазировании

git rebase -i &lt;base>                                        - чтобы смержить несколько коммитов в один, т.е. переписать историю нескольких
                                                              последних комитов, нужно использовать интерактивный rabase; для этого нужно
                                                              скопировать коммит (хэш коммита из git log), который идет перед коммитами
                                                              которые я хочу слить друг с другом; этот коммит будет являться базой (&lt;base>);
                                                              например: git rebase -i @~4 (ссылка на 5 коммит, т.е. смержить 4 посл коммита);
                                                              дальше git предложит выполнить какие то действия над коммитами: ставим
                                                              ключ s (squash (сплющить)) вместо слова push слева от коммитов, которые я хочу
                                                              сплющить, т.е. слить с первым стоящим выше коммитом в списке без squash;
                                                              Изначально в списке коммиты стоят в обратной последовательности и их можно
                                                              менять местами, чтобы, например, нижний в списке (т.е. мой последний коммит)
                                                              поднять наверх, а под ним уже были коммиты, которые нужно сквошить.
                                                              Изменения в файлах из сквошиваемых коммитов попадут в коммит(ы), которые мы не
                                                              трогали (слева от которых остался push).
                                                              Далее выхожу (ctrl + x) и выбираю сохранить: жму Y; далее git предложит выбрать
                                                              коммент из какого то коммита или создать свой вместо какого то: оставляем один
                                                              коммент, а ненужные комменты для других коммитов комментирую с помощью #.
                                                              В процессе слияний коммитов могут возникать конфликты, после решения которых
                                                              нужно добавить файлы с решенными конфликтами в индекс (git add &lt;file>) и
                                                              ввести команду git rebase --continue

git cherry-pick &lt;commitHash>                                - позволяет взять коммит(ы) из другой ветки (коммит D на схеме) и применить
                                                              его изменения (отличая по сравнению с С) к текущей ветке (коммит F) без
                                                              слияния (получается два независимых но эквивалентных коммита).
                                                                Т.е. в текущей ветке добавится новый коммит D', в котором будут те же
                                                              изменения, как и в D по сравнению с С.
                                                                Копировать коммиты можно и из середины ветки, не обязательно с конца. Так
                                                              же можно копировать не один коммит, а сразу несколько:
                                                                git cherry-pick 2702 2с11
                                                              или целую ветку (все коммиты ветки feature, которых нет в мастер):
                                                                git cherry-pick master..feature
                                                                При копировании коммитов могут возникать конфликты. Для отмены копирования
                                                              cherry-pick --abort. После разрешения конфликта: cherry-pick --continue
                                                                Может быть полезен, например, если обнаружена ошибка в файле, который
                                                              есть и в 1й ветке и во 2й. Соответственно, поправили в одной из веток,
                                                              и <b>копируем коммит</b> с правками в другую





        </pre><b style="display: block; margin-bottom: 10px; text-align: center">merge vs rebase</b><pre>
merge и rebase переносят коммиты из одной ветки в другую, но делают это по разному.
Допустим мы начинаем разработку новой фичи. Для этого создаем отдельную feature-ветку от master
и делаем в ней коммиты. Но пока мы разрабатываем фичу в нашей ветке, коллеги мержат свои фичи
в master ветку. => в определенный момент мы захотим обновить нашу feature-ветку фичами, фиксами
от коллег. Есть 2 способа:
1) merge (pull = fetch + merge). В нашей feature-ветке поверх создастся дополнительный
   merge-коммит, который будет содержать в себе все нове комиты коллег из master ветки.
     Плюс в том, что если над моей feature-веткой работают так же другие разрабы, то мы
   мержем никак не разрушм историю. То есть после мержа я запушу свою feature-ветку в
   удаленный репозиторий и коллега, который так же работает с этой feature-веткой, обновит
   свою локальную feature-ветку.
     С др. стороны это и минус, т.к. если ведется активная разработка и в master и в feature-вете
   и мы часто будем обновляться от master, то наша feature-ветка засорится merge-коммитами =>
   может быть трудно разобраться в истории коммитов (git graph очень запутается).
2) rebase (git rebase master; перед этим делаем fetch, что бы подтянуть обновленную master).
   В результате наша локальная feature-ветка теперь будет отпачкована не от того коммита в master,
   который был последним на момент создания feature-ветки, а от самого свежего коммита в master-ветке.
     Плюс в том, что мы как будто сейчас создали feature-ветку от master и после этого сделали
   наши коммиты с фичами (которые на самом деле мы делали ранее). => у нас нет лишних merge-коммитов
   (которые есть в merge) и история выглядит красивей (елочка) и чище.
     Но, с rebase опасно работать, если над одной feature-веткой работает несколько разрабов, т.к.
   когда мы делаем rebase, у нас меняются все хэши наших коммитов с фичами в feature-ветке (т.к.
   могут быть конфликты при rebase и git status выдаст detached HEAD => нужно будет решить конфликты).
   Поэтому для того чтобы в удаленный репозиторий запушить нашу ветку нужно делать force пуш
   (git push origin feature --force). И получается что все коммиты в нашей feature-ветке могут
   привести к конфликтам при pull у др. разрабов, которые работают с feature-веткой.
     Лучше испольовать rebase, только если я один работаю с feature-веткой !!
</pre><br><img src="./images/basis/merge.png" alt="merge" style="display: inline-block; width: 50%"> <img src="./images/basis/rebase.png" alt="rebase" style="display: inline-block; width: 44%"> <b style="display: block; margin-bottom: 10px; text-align: center">cherry-pick</b> <img src="./images/basis/cherry-pick.jpg" alt="cherry-pick" style="width: 30%"><pre>

Альтернатива cherry-pick - использовать merge. Но это не всегда удобный вариант, требующий создания новой ветки с фиксом:

</pre><img src="./images/basis/cherry-pick_merge-alternative.jpg" alt="cherry-pick_merge-alternative.jpg" style="width: 30%"></article><article class="section-info"><b>Git Branching Strategies</b><pre>
<img src="./images/basis/TruncBased_vs_GitFlow.jpg" alt="TruncBased_vs_GitFlow">
        </pre></article></div></section><!--_repeat--><section class="section" id="_repeat"><div class="section-container"><h2 class="section-title">_repeat</h2><article class="section-info"><b>Styles:</b><pre>
:root                 - &lt;html>
br ~ p                - все p идущие после br



  <b>inline</b> элементам нельзя задать ширину/высоту и верхние/нижние
отступы (padding/margin), в отличае от inline-block



position: absolute;   - элемент выходит из потока => соседние блоки и родительский его не
                        видят. Если для абсолютно позиционированного элемента не заданы
                        свойства left, right, top, bottom, то он останется на исходном месте.
                        Позиционируется относительно ближайшего позиционированного предка или
                        относительно &lt;html>




flex: 0 1 200px              - = flex-grow + flex-shrink + flex-basis;
                               значения:
                               none, [flex-grow flex-shrink? || flex-basis];
                               (default: 0 1 auto)

        </pre></article><article class="section-info"><b>JS:</b><pre>
  В браузере глобальные функции и переменные, объявленные с помощью var,
становятся свойствами window.

'use strict'
alert(this)     <span>undefined  (без 'use strict' - window)</span>




  Модуль – это js файл, в котором обычно что-то импортируем/экспортируем.
Модули работают только на сервере (live server, browser-sync...) и в них
всегда включена директива 'use strict'




  В JS объекты имеют специальное скрытое свойство [[Prototype]], которое либо равно
null, либо ссылается на другой объект. Этот объект называется прототип.
(у функций и классов так же есть прототип: Func.prototype / SomeClass.prototype).
  Когда мы хотим прочитать свойство из object, а оно отсутствует, JS автоматически
берёт его из прототипа - прототипное наследование.
  Св-во __proto__ у объектов ссылается на прототип объекта (является
геттером/сеттером для [[Prototype]])

  При наследовании классов наследуются все свойства и методы (в т.ч. и не из
конструктора).
  Если у Child не указан конструктор, то он унаследуется от Parent или от ближайшего
родительского класса, у которого есть метод constructor (если есть).





str.indexOf(substr [, pos])    - [number or -1], индекс первой совпавшей подстроки
                                 начиная с позиции pos
str.search(regex)              - [number or -1], индекс первого совпадения с
                                 regex в строке str или -1, если совпадения нет
str.match(regex)               - [arrayOfMatches or null], например:
                                 'Любо, братцы, любо!'.match(/любо/gi) <span>['Любо', 'любо']</span>




dateObj<b>.toString()</b>        - приводит к строке:
                            Wed Jul 28 1993 14:39:07 GMT-0600 (PDT)
dateObj<b>.toDateString()</b>    - возвращает часть, содержащую только дату объекта Date
                            в виде человеко-читаемой строки на американском английском:
                            Wed Jul 28 1993
dateObj<b>.toLocaleDateString([locales [, options]])</b>    - возвращает строку с языко-зависимым
                                                       представлением: 16.05.2020
dateObj<b>.toJSON()</b>          - возвращает представление объекта в виде JSОN
                            ( эквивалентен JSON.stringify(dateObj) )




Map – это коллекция пар ключ-значение, как и Object. Но основное
      отличие в том, что Map позволяет использовать ключи любого типа
Set – это особый вид коллекции - «множество» значений (без ключей),
      где каждое значение может появляться только один раз





<b>У объекта promise, возвращаемого new Promise(), есть внутренние свойства:</b>

- state:  вначале "pending" («ожидание»), потом меняется на
          "fulfilled" («выполнено успешно») при вызове resolve или
          на "rejected" («выполнено с ошибкой») при вызове reject.
- result: вначале undefined, далее изменяется на value при
          вызове resolve(value) или на error при вызове reject(error)

const promise = <b>new Promise( function(resolve, reject) {</b>
  <span>эта функция-исполнитель вызывается автоматически.
  Она должна вызвать один из этих колбэков сразу или
  с задержкой (сработает первый вызванный):
  resolve(value)    — если работа завершилась успешно, с результатом value
  reject(error)     — если произошла ошибка, error – объект ошибки

  * value и error могут быть любым типом данных</span>
<b>})</b>

                          <b>статические методы Promise:</b>

<span>после завершения самого долгого промиса возвращает массив результатов переданных
промисов в той же последовательности.
Если в переданном промисе ошибка, то остальные игнорятся и возвращается ошибка.
В массив могут передаваться не обязательно промисы</span>
Promise.all([...промисы...])

<span>всегда ждёт завершения всех промисов (даже завершенных с ошибкой).
В массиве результатов будет:
{status:"fulfilled", value:результат}  для успешных завершений,
{status:"rejected", reason:ошибка}     для ошибок</span>
Promise.allSettled([...промисы...])

<span>похож на Promise.all, но ждёт только первый (самый быстрый)
промис, из которого возвращает результат (или ошибку)</span>
Promise.race([...промисы...])
        </pre></article><article class="section-info"><b>JS Browser:</b><pre>
              Любая точка на странице имеет координаты:

  <b>- относительно окна браузера, даже если элемент находится
    вне окна (вне видимости). Отсчет от border, если есть:</b>
elem.getBoundingClientRect()      - возвращает объект со св-ми:
                                    x/y, width/height, top/bottom, left/right

  <b>- относительно документа, например:</b>
elem.getBoundingClientRect().top + window.pageYOffset





- Cookies в отличае от Local Storage могут хранить намного меньше данных
  (LS ~5mb, Cookies 4kb)
- Local / Session Storage как и Cookies так же привязан к конкретному домену
- Мы можем сами устанавливать время жизни для Cookie
- С каждым запросом на сервер автоматически отправляются Cookies (которые установил
  сервер в header'е Set-Cookie при первом запросе от клиента) и сервер так же может
  перезаписывать эти Cookies в последующих ответах на клиент
- В отличае от LS, Cookies служат для передачи данных между клинтом и сервером,
  в то время как LS только для хранения данных на клиенте
        </pre></article><article class="section-info"><b>React:</b><pre>
  В классовом компоненте св-во props и метод setState() наследуется от
библиотечного класса Component (получаем в методах: this.props / this.setState()).
  Если есть метод constructor в классовом компоненте, то props является параметром
и вызов super(props) обязателен!


  В setState() передается новый объект состояния, но не со всеми свойствами, а только
с теми, которые хотим изменить! Переданный в setState() объект состояния мержится с
текущим состоянием.
  Во всех остальных случаях: хуке useState, редьюсере для useReducer и Redux нужно
задавать новое состояние (не будет мержится со старым как в setState()).



  Компонент перерисовывается, даже если у него перерисовался родитель, но props не
поменялись. Что бы не происходила лишняя перерисовка нужно использовать
<b>React.PureComponent</b> в классовых компонентах
и
<b>React.memo()</b> в функциональных компонентах





                                    <b>React + Redux:</b>

  <b>'react-redux'</b> только для Provider ( &lt;Provider store={store}> ) и для
взаимодействия со стором в компонентах (получение полей состояния и
диспатчинг для изменения состояния), а все остальное импортируем из 'redux':
import {Provider} from 'react-redux'
import {connect} from 'react-redux'                       // в классах
import {useSelector, useDispatch} from 'react-redux'      // в функциях


  <b>thunk</b> - функция, принимающая ф-ю dispatch и выполняющая асинхронное действие
(setTimeout, fetch...), после выполнения которого и будет диспатчиться action(s)
        </pre></article></div></section></main><script src="index.js"></script></body></html>
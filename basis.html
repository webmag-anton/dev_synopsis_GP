<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Basis</title><link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="index.css"></head><body data-name="basis"><main class="sections-wrapper"><!--glossary--><section class="section" id="glossary"><div class="section-container"><h2 class="section-title">glossary</h2><article class="section-info"><img class="memory-img" src="images/basis/memory.jpg" alt="memory"></article><article class="section-info"><b>glossary</b><pre>
check in / sign up - зарегистрироваться
log in / sign in - авторизоваться (войти в систему)
validation - проверка
verification - подтверждение
deployment (rollout) - 'развёртывание', 'выкатка' продукта
rollback - откат к старому релизу (выкатывают старый релиз)
bypass - обходить
issue - задача
outage - отключение, перебой в работе
contributors - авторы
uptime - время безотказной работы
grant - предоставлять
teardown - удаление
sequence - последовательность
implicitly - неявно
occur - случаться
evaluate - оценивать
CDN — content delivery network
threshold - порог (типа breakpoint)
workaround - обходной прием, костыль
credentials - полномочия
vulnerabilities - уязвимости
scrollbar - полоса прокрутки (bar - панель)
re-crawl - переиндексация (в google)
chunks - фрагмент, кусок
affected - затронутый
crutch - костыль (обход)
command prompt - командная строка
ratio - коэффициент, соотношение
intersection - пересечение
viewport - область видимости
outage - перебой в работе
restrictions - ограничения
runtime - во время выполнения
+, -, *, / - sum, sub, mult, div
инвариант - нечто неизменяемое
гипертекст - это текст, содержащий ссылки на другие тексты


privacy policy - политика конфиденциальности
dispatch - отправка (вызов события)
parsing - чтение (разбор)
rendering - отображение (отрисовка)
alias - псевдоним для длинной команды (более короткий)
timestamp - отметка времени
fps - frames per second (кадров в секунду)
compatibility - совместимость
release - выпуск (новой версии)
extract - извлекать (из приложения в библиотеку)
hash - мешанина
token - знак
implementation - реализация, создание (метода)
expires - истекает (expires in 2 days)
teammate - товарищ по команде
utility - вспомогательный, полезный
toolkit - набор инструментов
aggregate - совокупность
expand/collapse - развернуть/свернуть
miscellaneous (misc) - разные
maintenance - поддержание (проекта)
match - соответствие/совпадение
fallback - резервный
feature - особенность
featuring - с участием
groso / neto - з/п до вычета налогов - groso, а neto - после
idle - неработающий, простаивающий
undo - отменить
preferences - настройки
attempts - попытки
submission - отправка (формы)
backdrop - фон (overlay в popup)
reboot - перезагрузка
tap - нажатие
pane - панель
invoiсe - счет
billing - выставление счета
approve - утвердить
e.g. - например
clipboard - буфер обмена
`` - строковые литералы для создания шаблонов
appearance - внешний вид
sketch - эскиз
wireframe - каркас
mock up - макет
прототип - схематичное изображение страницы или виджета перед созданием дизайна


MVP-версия - минимально жизнеспособный продукт (minimum viable product) —
             продукт, обладающий минимальными, но достаточными для удовлетворения
             первых потребителей функциями. Основная задача — получение обратной
             связи для формирования гипотез дальнейшего развития продукта
LTS-версия  - (long term support) это часть жизненного цикла программного обеспечения,
              которая означает, что стабильный релиз будет поддерживаться долгое
              время и будет считаться стандартной версией к распространению
Standalone-приложение vs SaaS - пример standalone - мобильное приложение Facebook. В то же
                                время веб-сайт Facebook будет являться SaaS, т.к. доступ к
                                нему осуществляется через браузер (другое приложение);
                                Standalone на примере наших виджетов - напимер отдельный
                                виджет tik-tok, который является частью social-feed
захардкодить - это когда ты что-то жостко прописываешь без возможности
               менять (анти-паттерн), от чего теряется гибкость (например,задать
               четкий размер: width: 20px)
анти-паттерны - полная противоположность паттернам. Если паттерны проектирования —
                это примеры практик хорошего программирования, то есть шаблоны решения
                определённых задач. То анти-паттерны — их полная противоположность
транслитерация - передача знаков одной письменности знаками другой (латиницей русские слова)
i18n (internationalization) - процесс разработки приложения, чтобы оно могло переключаться
                              на другой язык, не прибегая к программному изменению приложения
l10n (localization) - процесс добавления соответствующих ресурсов в ваше программное
                      обеспечение для поддержки определенного языка (локали)
a11y (accessibility) - доступность для людей с ограниченными способностями
boilerplate code - шаблонный код (boilerplate - шаблон), который должен быть
                   написан во многих местах практически без изменений
polyfill -  код, написанный в старом стандарте для замещения встроенных функций, которые не
            поддерживаются в старых браузерах. Например в IE 11 js движок понимает только
            стандарт ES5-, в котором нет методов Array.from() или Array.prototype.keys().
            А транспилер (babel) переписывает код, преобразовывая новые синтаксические
            конструкции (например async await; не путать со встроенными функциями) в старые
синтаксический сахар  — это синтаксические возможности, применение которых не влияет на
                        поведение программы, но делает использование языка более удобным
интерфейс — руль и педали это внешний интерфейс авто, а все
            что под капотом - внутренний скрытый интерфейс
внутренний интерфейс – методы и свойства, доступные из других методов класса,
                       но не снаружи класса
внешний интерфейс – методы и свойства, доступные снаружи класса
API - программный интерфейс приложения. Проще говоря, это то, что обеспечивает эффективный
      процесс коммуникаций между программами, использующими функции и ресурсы друг друга;
      то есть это набор публичных свойств и методов (внешний интерфейс) для взаимодействия
      с програмой
CLI (Command line interface) - интерфейс командной строки; также известен под названиями
                               «консоль» и «терминал»; он противопоставляется системам
                               управления программой на основе меню, а также различным
                               реализациям графического интерфейса
шаблонизатор — программа, позволяющее использовать html-шаблоны для генерации конечных
               html-страниц. Основная цель использования шаблонизаторов — это отделение
               представления данных от исполняемого кода. Часто это необходимо для
               обеспечения возможности параллельной работы программиста и верстальщика;
               в JS популярен шаблонизатор Handlebars
OKR  - (Objectives and Key Results -цели и ключевые результаты) метод, используемый в
       современном менеджменте для управления проектами. Позволяет синхронизировать
       командные и индивидуальные цели и обеспечить эффективный контроль над реализацией
       поставленных задач.
       OKR - это не задачи, а цели. OKR в Lattice, а задачи в Jira. Goals в Lattice
       разбиваются на key results. Один key result может объединять несколько
       задач из Jira. И по мере закрытия задач нужно закрывать key results, таким
       образом наглядно трекать кроцесс выполнения цели.
KPI (Key Performance Indicators) - ключевые показатели эффективности - то, что нам
                                   скажет, что мы достигли какой то цели
SERP - Search Engine Results Page


SPA - это веб-приложение или веб-сайт, который взаимодействует с веб-браузером,
      динамически переписывая текущую веб-страницу новыми данными с веб-сервера,
      вместо того, чтобы по умолчанию браузер загружал целые новые страницы.
      Цель - более быстрые переходы, которые делают сайт более похожим на нативное
      приложение. В SPA все необходимые коды HTML, JavaScript и CSS либо извлекаются
      браузером с одной загрузкой страницы, либо соответствующие ресурсы динамически
      загружаются и добавляются на страницу по мере необходимости, обычно в ответ на
      действия пользователя. Страница не перезагружается в любой точке процесса и не
      передает управление на другую страницу, хотя хэш местоположения можно
      использовать для обеспечения восприятия и навигации по отдельным логическим
      страницам в приложении.
        SPA использует единственный HTML-документ как оболочку для всех веб-страниц
      и организует взаимодействие с пользователем через динамически подгружаемые HTML,
      CSS, JavaScript, обычно посредством AJAX подхода (в фоновом режиме - без перезагрузки)

REST API —  (Representational State Transfer — «передача состояния представления»).
            По сути это API сервера: набор публичных свойств и методов сервера для
            взаимодействия с ним. В документациях прописывается правила взаимодействия:
            на какой url слать запрос (Endpoint), какого типа делать запрос, что отправлять
            в запросе...

CORS (Cross-Origin Resource Sharing) - совместное использование ресурсов между разными
                                       источниками ( источник (origin) – комбинация
                                       домен/порт/протокол )


функциональное програмирование - когда функции становятся объектами первого класса, то
                                 есть могут принимать другую функцию в качестве аргумента
                                 или возвращать другую функцию в качестве результата

обратная совместимость - например, SCSS понимат CSS или TS понимает JS, т.е. обратно совместим

refactoring - (переработка кода) процесс изменения внутренней структуры программы, не
              затрагивающий её внешнего поведения и имеющий целью облегчить понимание её
              работы (например, вынесение повторяющегося кода в ф-ии, подключение redux к
              приложению...). То есть рефакторинг, это когда поведение програмы одно и тоже,
              а код меняется

декомпозиция - разделение целого на части

обфускация — приведение исходного текста или исполняемого кода программы к виду, сохраняющему её
             функциональность, но затрудняющему анализ, понимание алгоритмов работы и модификацию
             при декомпиляции


бизнес-логика    - это набор правил (условий), которым подчиняются объекты, сущности,
                   классы и данные внутри программы.
                     Т.е. простыми словами это правила, заключенные в самом бизнесе,
                   для которого написана программа.
                     Например, если товар отправляется со склада, то в накладной не может
                   не быть поставщика этого товара и т.д.


compilation - преобразование программы, при котором используется исходный код
              программы, написанной на одном языке программирования в качестве
              исходных данных, и производится эквивалентный исходный код на другом
              языке программирования (т.е. языки с разными уровнями абстракции, в
              отличае от транспиляции).
              Например: JS движок V8 компилирует js в машинный код;
                        Brython транспилирует Python в JS

transpilation - подвид компиляции (source-to-source compiler), при котором
                преобразование происходит для языка с тем же уровнем абстакции
                (например TS в JS) или в другую версию того же языка (Babel)

Дамп (dump – сбрасывать) – файл, включающий в себя содержимое базы данных (.sql файл).
                           Он содержит особые данные, благодаря которым можно легко
                           воссоздать копию БД
        </pre></article></div></section><!--console--><section class="section" id="console"><div class="section-container"><h2 class="section-title">Console</h2><article class="section-info"><pre>
        <b>навигация по директориям:</b>

pwd                     - показать путь к текущей папке (present working directory)
ls (dir на windows)     - показать все папки/файлы в проекте (без скрытых)
ls -a                   - показать все папки/файлы в проекте (со скрытыми)
cd &lt; path >             - сменить директорию
cd или cd ~             - переходит в домашний каталог (корень)


        <b>работа с папками/файлами:</b>

touch filename.**              - создать файл
mkdir &lt; folder >               - создать папку
rm -rf filename.**             - удалить файл (rm -rf .git/index.lock)
rm -r dirname/                 - удалить папку


        <b>misc:</b>

clear                          - очистить консоль
rm -rf node_modules && npm i   - быстро удалить и переустановить модули

git add . && git commit -m "message" && git push
        </pre></article></div></section><!--IDE's--><section class="section" id="ide"><div class="section-container"><h2 class="section-title">IDE's</h2><article class="section-info"><b>WebStorm</b><pre>
  <b>keyboard shortcuts:</b>

ctl + x                               - вырезать
ctl + d                               - дублировать строку
alt + click                           - мультикурсор
shift shift                           - поиск
ctl + shift + f                       - поиск в проекте
ctl + f                               - поиск в файле
ctl + r                               - заменить
ctl + alt + l                         - выровнять весь файл
ctl + alt + i                         - выровнять выбраный участок
ctl + alt + o                         - удаляет все неиспользуемые импорты
shift + alt + вверх/вниз              - переместит строку
ctl + F7                              - выделит все одинаковые слова
ctl + /                               - закомментировать строку
ctl + shift + /                       - закомментировать несколько строк
ctl + z                               - undo
ctl + shift + z                       - redo
alt + shift + up                      - переместить строку
alt + j                               - выделить следующее вхождение
ctl + alt + shift + j                 - выделить все вхождения
ctl + shift + u                       - toggle uppercase
        </pre></article></div></section><!--git--><section class="section" id="git"><div class="section-container"><h2 class="section-title">git</h2><article class="section-info"><b>theory</b><pre>
            <b>1. Настройки git</b>
  git config --global user.name 'Anton'
  git config --global user.email 'anton.byshok@gmail.com'
Если мы не задали конфиг в конкретном репозитории, то он будут браться из глобальных
настроек. Чтобы посмотреть все настройки: git config --list


            <b>2. Инициализация Git</b>
  Создаем  репозиторий в папке с проектом. Либо правой кнопкой мыши и git init here.
Либо открываем Git Bash и прописываем комманду git init. После инициализации появляется
скрытая папка .git (база данных git, служебная дирректория)


            <b>3. Двуступенчатая система изменений в репозиторий</b>
  Одна из важнейших особенностей git, это то, что система изменений в репозиторий
двуступенчатая (index - repository):

   <span>(файлы проекта)</span>        |      <span>(эти 2 зоны принадлежат репозиторию git; данные о них в /.git)</span>
                          |
- working directory       |     - index (хранит список файлов          - repository ( HEAD )
                          |       проекта, отслеживаемых git;            (хранится вся история
                          |       является промежуточным                 разработки проекта)
                                  хранилищем изменений)
                --> git add (stage)                         --> git commit

  Для внесения изменений в git сначало добавляем файлы проекта в index (git add &lt;file(s)>)
и затем, когда мы доделали какой то кусок работы, сохраняем изменения из index в 3-ей зоне -
в repository (git commit -m 'my_comment'). И в нем уже хранится вся история разработки проекта

      Проверять статус index можно командой git status, которая может выдать такие уведомления:
- Changes not staged for commit (список файлов, которые отслеживаются git, но которые были
                                изменены/удалены; и чтобы их закомитить, нужно опять добавить
                                их в index перед комитом)
- Untracked files (список файлов, которые не отслеживаются, т.е. ранее не добавлялись в index,
                  например новые файлы; чтобы их закомитить, также нужно добавить в index перед
                  комитом)
- Changes to be commited (список файлов, которые были добавлены в index и готовы быть закомичены)
- Unmerged paths (список файлов с неразрешенными конфликтами при слиянии)

  Если добавить измененный файл в index, а потом еще что то поменять в нем, то git status
покажет что он будет одновременно в 2 списках: Changes to be commited и Changes not staged
for commit. То есть при коммите в репозиторий попадет версия, которая была добавленв в
index (первое изменение), а второе изменение нет. Его нужно сначало добавить в index

  Если удалить файл, который трекается (ранее добавлялся в index), то его так же после удаления
нужно проиндексировать перед комитом, чтобы он так же удалился из локального репозитория


            <b>4. Ветки / HEAD / tag</b>
ветка - это ссылка на 1 конкретный commit (последний в ветке). Но при этом находящимися в ветке
        называют все commit'ы, которые находятся на пути от вершины вниз по цепочке от родителей.
        Ветки можно увидеть в .git/refs/heads; commit, на который указывает ветка, называют ее
        вершиной
HEAD - используется чтобы git репозиторий понимал где мы находимся сейчас; HEAD хранит ссылку
       на текущую ветку; технически HEAD может хранить ссылку на коммит, но это редкое состояние
       'detached HEAD' (отделенная HEAD; возникает при переключении на определенный коммит в
       ветке); alias для HEAD является @

  При переключении на другую ветку, если есть незакомиченные изменения (не важно внесены
они в index или нет), то git будет ругаться, только в том случае, если изменения находятся
в файле, который различается между ветками (есть конфликт). А если конфликтных различий нет,
то переключение пройдет успешно, а незакомиченые файлы пометятся 'M' в консоле. Нужно быть
аккуратными, т.к. в переключаемую ветку попадут измененнные и добавленные в index.
  Но вообще лучше либо закомитить изменения перед переключением, либо сбросить working
directory и index до состояния последнего коммита, чтобы git status был 'чист'

  теги в git - это ссылки на определенные коммиты по названию тега. То есть можно назвать
тег, а потом ссылаться на него по названию. Иными словами тег - это метка коммита,
использующаяся для удобного переключения по понятному названию тега.
  Например, можно маркировать релизы: git tag v1.1.0 &lt;commitHash>


            <b>5. Игнорирование файлов (.gitignore)</b>
  node_modules       - игнорировать все папки node_modules в проекте
  dist               - игнорировать все папки dist в проекте
  folderName/.html   - игнорировать файлы с определенным расширением в folderName
  *drawio.dtmp       - игнорировать все файлы с определенным расширением в проекте

  Чтобы смотреть как бы глазами гита не из корневой папки, а из другой, нужно зайти
в нее (cd folderName). После этого файлы будут показываться относитель нее.
  git status --untracked-files=all   - показать все неотслеживаемы (untracked) файлы
  * .gitignore нужно заливать в репозиторий


            <b>6. SSH</b>
  Лучше использовать соединение с защищенным протоколом SSH вместо HTTPS. С помощью ключей
SSH вы можете подключаться к GitHub без указания имени пользователя или пароля при каждом
посещении.
Для использования SSH нужны 2 связанных сгенерированных ключа:
  - публичный (аналог замка) - лежит на сервере (github),
  - приватный (аналог ключа от замка) - лежит в компьютере,
    может быть несколько для разных компов
Для генерирования ключа на Windows пишем в Git Bash (или wsl):
  ssh-keygen -t rsa -b 4096 -C "your_email@example.com"     -  email моего github аккаунта
Далее указываем куда установить ключи (жмем enter по дефолту ( ~/.ssh/ )) и придумываем пароль
passphrase (можно ничего не вводить).
Добавление вашего SSH-ключа в ssh-agent:
  eval $(ssh-agent -s)
  затем
  ssh-add ~/.ssh/id_rsa
Теперь добаляем публичный SSH-ключ в свою учетную запись GitHub:
  clip &lt; ~/.ssh/id_rsa.pub
  затем
  на github Settings -> SSH and GPG keys -> вводим имя в Title и вставляем ключ из буффера

<b>* не обязательно для каждого сервера иметь свой ключ,
  можно один для всех (например одинаковый на github и gitlab)</b>


  Если необходимо положить ключи в другую не стандартную папку (не ~/.ssh/) или кастомно
назвать ключи, например, вместо id_rsa назвать _id_rsa, или если ключей несколько для разных
акаунтов, то необходимо создать конфигурационный файл ~/.ssh/config, в котором указать:
Host (host aliases: github, bitbucket), HostName, User, IdentityFile (private key)

Host github_corp
  HostName github.com
  User anton
  IdentityFile ~/.ssh/id_rsa

Host bitbucket
  HostName bitbucket.org
  User anton
  IdentityFile ~/.ssh/_id_rsa

  При клонировании после git@ указываем Host (alias для HostName), по дефолту
при клонировании репозитория из github после git@ идет github.com.
  * Для репозиториев на одном хостинге (с одинаковым HostName) нужно использовать разные
alias'ы (например, bitbucket-corporate и bitbucket-personal) т.к. HostName одинаков, а для
разных серверов в этом нет необходимости, поэтому для удобства лучше называть Host также как
и HostName.
git clone git@github_corp:company/project.git
git clone git@bitbucket:company/project.git

  Добавление связаных удаленных репозиториев с моим
локальным (git remote add &lt;repoName> &lt;repoUrl>):
git remote add one git@github_corp:webmag-anton/test.git
git remote add two git@bitbucket:company/project.git

  Теперь можно запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
репозиторий &lt;repoName> (git push &lt;repoName> &lt;myBranchName>); если на удаленном
репозитории нет такой ветки (&lt;myBranchName>), то она создастся:
git push github_repo_name anton
git push bitbucket_repo_name anton


           подитоживая, для добавления 2-го ssh-ключа, например, в bitbucket:
1) ssh-keygen -t rsa -b 4096 -C "anton.byshok@gmail.com"
2) Enter file in which to save the key (/c/Users/anton/.ssh/id_rsa):
   /c/Users/anton/.ssh/id_rsa_bitbucket
3) open terminal in in ~/.ssh and type: touch config
4) in ~/.ssh/config

Host github.com
  HostName github.com
  User anton
  IdentityFile ~/.ssh/id_rsa

Host bitbucket.org
  HostName bitbucket.org
  User anton
  IdentityFile ~/.ssh/id_rsa_bitbucket

5) eval $(ssh-agent -s)
6) ssh-add ~/.ssh/id_rsa
  then
  ssh-add ~/.ssh/id_rsa_bitbucket
7) clip &lt; ~/.ssh/id_rsa_bitbucket.pub
  затем
  на bitbucket Personal settings -> SSH keys ->
  вводим имя ключа в Label и вставляем ключ из буффера обмена

8) при передачи данных может возникнуть такое сообщение:
The authenticity of host 'bitbucket.org (18.205.93.0)' can't be established.
RSA key fingerprint is SHA256:zzXQOXSRBEiUtuE...
Are you sure you want to continue connecting (yes/no/[fingerprint])?
  Пишем yes, после чего в ~/.ssh в файле known_hosts добавится
bitbucket.org,18.205.93.0 ssh-rsa AAAAB3Nz...
        </pre></article><article class="section-info"><b>forking</b><pre>
  Можно форкнуть чей то репозиторий на github (нажать кнопку Fork) - это скопирует репозиторий
в мой аккаунт. Затем вносятся изменения в скопированный репозиторий и далее авторам исходного
проекта предлагается принять мои изменения при помощи 'pull request'.
  <b>Исходный проект называют upstream, мой форк - origin, клонированый проект - локальная копия</b>
        </pre></article><article class="section-info"><b>repositories: local ⇔ remote</b><pre>
  <b>Чтобы связать и отправить локальный репозиторий</b> (папка, в которой инициализирован
git) <b>на github репозиторий</b>, необходимо сначало создать репозиторий на github, а затем:

1. git remote add origin https://github.com/webmag-anton/git-test.git
2. git push -u origin master
где   remote – удаленный репозиторий
      add    – добавить
      origin – псевдоним репозитория (по дефолту origin), можно назвать по другому
      https://github.com/webmag-anton/git-test.git – адрес созданного мной репозитория git-test
      -u      – ключ для запоминания логина при пуше
      origin  – псевдоним  удаленного  репозитория
      master  – имя текущей локальной ветки



  <b>Чтобы загрузить (клонировать) удаленный репозиторий на свой компьютер:</b>
git clone git@github.com:webmag-anton/git-test.git
  При клонировании репозитория, клонируется не только master ветка, а все удалённые
ветки. Просто они имеют префикс origin/удалённая_ветка. А вот отслеживаемой становится
только ветка master -> origin/master!
  Для того, чтобы сделать ещё одну отслеживаемую ветку - переключитесь на удалённую
и выполните создание локальной ветки. Всё это можно сделать одной командой:
git checkout --track -b local_branch_name origin/remote_branch_name
        </pre></article><article class="section-info"><b>glossary</b><pre>
origin          - дефолтное имя клонированного из github удаленного репозитория
master          - дефолтное имя изначальной (главной) ветки
ветка           - ссылка на 1 конкретный commit (последний в ветке)
HEAD            - ссылка на текущую ветку (на ее последний commit)

alias           - псевдоним для длинных команд
@               - это alias для HEAD
@~              - ссылка на предпоследний коммит в текущей ветке
@~4             - (эквивалент HEAD~4) ссылка на 5 с конца коммит в текущей ветке
        </pre></article><article class="section-info commands-article"><b>main commands</b><pre>
git help command_name                                       - просмотр докумментации комманды
git config --global core.autocrlf true                      - такая установка гарантирует, что ваш репозиторий можно будет
                                                              использовать на других платформах, сохраняя CRLF в вашем рабочей
                                                              папке. Поэтому параметр true рекомендован для Windows
git config --global alias.st status                         - создали глобальный алиас 'st' для команды status
git config --global alias.last log --oneline --graph
                                   --decorate --all         - информативный лаконичный log (список коммитов),
                                                              пример для вывода последних 3-х: git last -3
git config --global alias.commitall '!git add .;git commit' - проиндексировать и затем закомитить все измененные
                                                              файлы, включая неотслеживаемые (т.е. до этого не добавлявшиеся
                                                              в index git'a); пример: git commitall -m 'initial'
git status                                                  - проверка статуса index
git log                                                     - вывести список коммитов с дополнительными данными текущей
                                                              ветки (выход q)
git reflog                                                  - показывает историю ваших действий; используя reflog, вы можете
                                                              вернуться в прошлое, отменяя почти любые действия, сделанные в Git.
                                                              Даже если это были rebase или reset; чтобы изменить нужное состояние,
                                                              нужно запустить checkout, используя абсолютную ссылку, например git
                                                              checkout 1234568 или относительную ссылку: git checkout HEAD@{3} и вы
                                                              окажетесь в независимом (detached) состоянии HEAD, из которого можно
                                                              создать новую ветвь. Вот и всё, все операции после вышеуказанного
                                                              состояния отменены

git add &lt;file(s)>                                           - добавить файл в индекс (stage); после коммита файл удаляется
                                                              из индекса, так что нужно повторно добавлять в индекс перед коммитом!
git add .                                                   - проиндексировать все файлы из текущей директории, что бы не
                                                              указывать каждый
git rm --cached &lt;file>                                      - если по ошибке проиндексировали лишние файлы, или которые
                                                              забыли добавить в игнор, то их можно удалить из индекса (unstage)
git commit -m 'my_comment'                                  - создать снимок состояния проиндексированных файлов в рабочей
                                                              дерриктории; в случае чего можно откатится до этого состояния
git commit --amend --no-edit -m 'my_comment'                - ключ --amend позволяет объединить проиндексированные изменения
                                                              с предыдущим коммитом без создания нового, но дата коммита обновляется;
                                                              коментарий обновится на новый; ключ --no-edit для того, чтобы сообщение
                                                              осталось без изменения;
   commit без промежуточного индексирования (3 варианта):
git commit -am 'my_comment'                                 - commit всех измененных файлов без промежуточного добавления в индекс;
                                                              единственный нюанс, что делается commit только ранее добавлявшихся
                                                              (отслеживаемых) файлов из working directory, которые мы поменяли;
                                                              новосозданные файлы не закомитятся без предварительного индексирования
git commit -m 'my_comment' &lt;file(s)>                        - commit конкретных измененных файлов без промежуточного добавления
                                                              в индекс; так же как и с флагом -a, этот вариант применится только
                                                              для уже ранее треканых файлов (ранее индексировавшихся)
git commitall (alias)                                       - использовать созданый alias commitall:  git commitall -m 'descr'

git show                                                    - показывает содержание коммита

git checkout -- &lt;filename>                                  - допустим мы закоммитили файл, а потом изменили его и поняли
                                                              что нужно откатиться до коммита
git checkout -f                                             - допустим мы закоммитили несколько файлов, а потом изменили их и поняли
                                                              что нужно откатиться до коммита (то есть откатить все файлы до последнего
                                                              коммита; откатит и проиндексированые файлы, т.е. отменит индексацию); но
                                                              не удалит неотслеживаемые файлы (ранее не индексировавшиеся), которых
                                                              не было в проекте в последнем комите; для их удаления нужно дополнительно
                                                              вызвать команду  git clean dxf
git clean -dxf                                              - удаляет неотслеживаемые (untracked) файлы и папки из working directory

git diff --name-only &lt;nameBr> [&lt;repoName>/]&lt;nameBr>         - показывает файлы, в которых есть отличая между ветками, т.е. последними
                                                              коммитами на них; удобно смотреть перед слиянием
git checkout &lt;commitHash>                                   - переключиться на определенный коммит по его hash (виден в git log/reflog);
                                                              при этом возникнет состояние 'detached HEAD' (отделенная HEAD), т.е.
                                                              HEAD будет указывать не на вершину ветки; и при коммите не из последнего
                                                              коммита в ветке возникнут коммиты, не принадлежащие ни одной ветке, так
                                                              лучше не делать; обычно git checkout &lt;commitHash> используют просто для
                                                              просмотра какого то коммита; что бы переключиться на последний коммит
                                                              на ветке нужно переключиться на эту ветку (git checkout master)

git reset --hard &lt;commitHash>                               - бывает что мы замечаем ошибку не сразу, а когда она уже в репозитории
                                                              и хотельсь бы отменить последний коммит или несколько и поменять там
                                                              что то (можно переключиться и в коммит другой ветки, от которой была
                                                              создана наша); при откате на нужный коммит, коммиты, которые шли после
                                                              него удаляться и на них теперь нельзя переключиться, их как будто и не
                                                              было; хотя конечно можно, git не сразу подчищает;
                                                              пример отмены последнего мержа (коммита слияния):   git reset --hard @~
                                                              (@ - это alias для HEAD (ссылка на текущую ветку), а ~ - это родительский
                                                              коммит, то есть предпоследний, до которого мы хотим откатиться)
                                                              --hard означает, что после отката в определенный коммит сбросится и
                                                              рабочая директория (в файлах не будут изменения от коммита, из которого
                                                              делали reset) и index.
                                                              --mixed (default, git reset &lt;commitHash>) означает сброс index, но в
                                                              файлах останутся изменения от коммита, из которого делали reset.
git reset --soft &lt;commitHash>                               - ресет с сохранением изменений в working directory и index (сделаных
                                                              в коммите, от которого мы переключаемся в нужный по его хэшу). В основном
                                                              мягкий ресет используется для отмены последнего комита, при этом оставляя
                                                              все подготовленные для него данные.
                                                              Удобно для отмены коммита, если забыли что то довнести в него или поняли
                                                              что нужно что то поменять. Например,  git reset --soft @~

git revert &lt;commitHash>                                     - отменяет действия прошлых коммитов, создавая новый, содержащий все
                                                              отменённые изменения. Зачем использовать её вместо других решений? Это
                                                              единственный безопасный способ, так как он не изменяет историю коммитов.
                                                              Обычно используют в публичных ветвях, где изменение истории нежелательно

git branch                                                  - список локальных веток
git branch -a                                               - список локальных и удаленных веток
git branch &lt;branchName>                                     - создания новой ветки от текущей
git branch -d &lt;branchName>                                  - удаление ветки
git checkout &lt;branchName>                                   - переключение в нужную ветку
git checkout -b &lt;branchName>                                - создание и переключение в созданную ветку от текущей
git branch -m &lt;oldname> &lt;newname>                           - переименовать ветку (без &lt;oldname> - текущую)

git merge &lt;branchName>                                      - смержить текущую локальную ветку с локальной &lt;branchName>, т.е.
                                                              указываем из какой ветки мы хотим добавить изменения в текущую ветку
git merge &lt;repoName>/&lt;repoNameBranch>                       - смержить ветку &lt;repoNameBranch> из подтянутого (fetch) удаленного
                                                              репозитория &lt;repoName> с моей локальной текущей веткой
git merge &lt;nameBr> --no-commit                              - автомерж без создания коммита слияния; бывает что в файле нет конфликта, но,
                                                              например, в разные строки кода добавляются 2 взаимоисключающие функции из
                                                              сливаемых веток; git автоматически добавил бы обе эти функции в коммит, но
                                                              нам этого не нужно; чтобы была возможность в ручном режиме выбирать нужный
                                                              вариант в каждом из различающихся файлов при слиянии и нужен --no-commit
git checkout --ours[theirs] &lt;filename>                      - разрешения конфликта при merge'е в пользу нашей ветки (--ours) или ветки, в
                                                              которую мы вливаем нашу (--theirs) в конкретном конфликтном файле &lt;filename>
git checkout --merge &lt;filename>                             - допустим мы разрешили конфликт в определенном файле в пользу нашей ветки, но
                                                              после этого поняли, что нужно выбрать в пользу сливаемой ветки; для этого
                                                              нужно вернуть версию файла с маркерами конфликта и выбрать нужный вариант
git merge --abort                                           - допустим мы видим много конфликтов при слиянии и решаем вообще его отменить;
                                                              в отличае от git reset --hard (без указания коммита отката предполагается
                                                              последний), git merge --abort не трогает незакомиченнные изменения в
                                                              неотслеживаемых файлах, то есть в файлах, ни разу не добавляемых в index

git branch --track &lt;locBrNm> &lt;repoName>/&lt;remBrNm>           - создание локальной ветки &lt;locBrNm> от удаленной &lt;remBrNm> (нужно
                                                              подтянуть &lt;remBrNm>, если нужно, с помощью git fetch &lt;repoName>),
                                                              которая отслеживает удаленную ветку &lt;remBrNm> репозитория &lt;repoName>;
                                                              флаг --track можно использовать только при создании новых веток
git branch &lt;myBrNm> --set-upstream-to &lt;repoNm>/&lt;remBrNm>    - установка существующей локальной ветке &lt;myBrNm> отслеживание
                                                              удаленной ветки &lt;remBrNm> из репозитория &lt;repoNm> (после этого, при
                                                              git pull, &lt;remBrNm> ветка будет заливаться в локальную &lt;myBrNm>, т.к.
                                                              она отслеживается локальной &lt;myBrNm>)

git clone &lt;repoUrl>                                         - загрузить удаленный репозиторий в локальную дирректорию (по
                                                              дефолту удаленный репозиторий имеет имя origin)
git remote                                                  - показывает существующие удаленные репозитории, связанные с
                                                              локальным репозиторием
git remote add &lt;repoName> &lt;repoUrl>                         - добавляем очередной связаный удаленный репозиторий с моим локальным,
                                                              например:  git remote add origin https://github.com/webmag-anton/test.git
git remote rm &lt;repoName>                                    - удаляем свзанный удаленный репозиторий &lt;repoName> (git remote rm sec_repo)
git remote set-url origin new.git.url/here                  - для изменения/установки удаленного репозитория, чтобы, например, при переезде
                                                              из bitbucket на gitlab, локальный проект отслеживал другую удаленную репу
git fetch &lt;repoName>                                        - подтянуть изменения со всех веток и новые ветки репозитория &lt;repoName>
git pull &lt;repoName> &lt;remoteBranchName>                      - подтянуть в .git (fetch) + смержить &lt;remoteBranchName> ветку из
                                                              удаленного репозитория &lt;repoName> с моей локальной активной веткой
                                                              ( pull = fetch + merge )
git push &lt;repoName> &lt;myBranchName>                          - запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
                                                              репозиторий &lt;repoName>, например:  git push origin master; если на
                                                              удаленном репозитории нет такой ветки (&lt;myBranchName>), то она создастся !
git push &lt;repoName> &lt;myBranchName>:&lt;remoteBranchName>       - запушить свою локальную ветку &lt;myBranchName> на удаленный связаный
                                                              репозиторий &lt;repoName> в его ветку &lt;remoteBranchName>


git checkout --track -b &lt;myBrNm> &lt;repoName>/&lt;remBrNm>       - при клонировании репозитория отслеживаемой становится только ветка
                                                              master. Чтобы сделать ещё одну отслеживаемую ветку - создаем и
                                                              переключаемся на ветку &lt;myBrNm> (создастся не от текущей, а от &lt;remBrNm>),
                                                              которая будет отслеживать удаленную ветку &lt;remBrNm> репозитория &lt;repoName>;
                                                              &lt;myBrNm> и &lt;remBrNm> удобно назвать одинаково. Перед этим нужно создать
                                                              ветку на сервере и подтянуть в локальный репозиторий (git fetch &lt;repoName>)
git checkout --no-track -b &lt;myBrNm> &lt;repoName>/&lt;remBrNm>    - создание локальной ветки &lt;myBrNm> (и переключение в нее) от
                                                              удаленной &lt;repoName>/&lt;remBrNm> без отслеживания

git fetch && git checkout feature/DEV-367                   - после создания ветки на сервере можно подтянуть ее в локальный
                                                              репозиторий и сразу создать и переключиться на одноименную локальную
                                                              ветку 1 командой, причем локальная ветка будет отслеживать удаленную (в
                                                              примере подтянул удаленную ветку feature/DEV-367 и сразу содал и
                                                              переключился на одноименную локальную feature/DEV-367, которая трекает
                                                              удаленную)

git stash                                                   - допустим мы работаем над проектом, но нас попросили переключиться на
                                                              другую ветку что бы помочь кому то решить задачу. Просто так нельзя
                                                              переключиться, нужно сделать коммит моих изменений (страховка от git).
                                                              Но нам не нужно еще делать коммит, т.к. например функция написана
                                                              наполовину. Можно спрятать изменения с помощью git stash, затем
                                                              переключиться на нужную ветку, проделать там работу, а затем при
                                                              возврате на свою, вернуть изменения командой git stash pop;
                                                              при этом git stash не спрячет непроиндесированные (неотслеживаемые) файлы
git stash pop                                               - вернуть спрятанные изменения и очистить тайник; git stash apply - для
                                                              возврата спрятанного без очистки тайника, но луше с очисткой;
                                                              важно возвращать изменения на той же ветке, на которой прятали, т.к. у
                                                              git stash нет привязки к ветке

git rebase &lt;nameBranch>                                     - локальный rebase с указанием ветки, на которую нужно осуществить
                                                              перебазирование текущей ветки; т.е. коммиты, если они есть, последовательно
                                                              накладываются на базовую ветку (ее последний коммит), которую мы указываем
                                                              при rebase; т.е. наша ветка теперь будет начинаться с последнего коммита
                                                              той ветки, которую мы указали при rebase; и соответственно мы получим весь
                                                              код базовой ветки, которого до этого не было в проекте.
                                                              Эта операция альтернатива merge'у, но при rebase за основу берется не текущая
                                                              ветка; есть и другие отличая
git rebase &lt;repoName>/&lt;repoNameBranch>                      - перебазирование удаленной ветки &lt;repoNameBranch> из репозитория &lt;repoName>
                                                              в локальную текущую ветку
git rebase --abort                                          - если, например, при пребазировании возникли конфликты и мы решили отменить
                                                              rebase вместо разрешения конфликтов
git rebase --continue                                       - продолжить перебазирование (наложить следующие комиты из своей ветки) после
                                                              разрешения конфликтов в указанном коммите, информация о котором выводится
                                                              при перебазировании

git rebase -i &lt;base>                                        - чтобы смержить несколько коммитов в один, т.е. переписать историю нескольких
                                                              последних комитов, нужно использовать интерактивный rabase; для этого нужно
                                                              скопировать коммит (хэш коммита из git log), который идет перед коммитами
                                                              которые я хочу слить друг с другом; этот коммит будет являться базой (&lt;base>);
                                                              например: git rebase -i @~4 (ссылка на 5 коммит, т.е. смержить 4 посл коммита);
                                                              дальше git предложит выполнить какие то действия над коммитами: ставим
                                                              ключ s (squash (сплющить)) вместо слова push слева от коммитов, которые я хочу
                                                              сплющить, т.е. слить с первым стоящим выше коммитом в списке без squash;
                                                              Изначально в списке коммиты стоят в обратной последовательности и их можно
                                                              менять местами, чтобы, например, нижний в списке (т.е. мой последний коммит)
                                                              поднять наверх, а под ним уже были коммиты, которые нужно сквошить.
                                                              Изменения в файлах из сквошиваемых коммитов попадут в коммит(ы), которые мы не
                                                              трогали (слева от которых остался push).
                                                              Далее выхожу (ctrl + x) и выбираю сохранить: жму Y; далее git предложит выбрать
                                                              коммент из какого то коммита или создать свой вместо какого то: оставляем один
                                                              коммент, а ненужные комменты для других коммитов комментирую с помощью #.
                                                              В процессе слияний коммитов могут возникать конфликты, после решения которых
                                                              нужно добавить файлы с решенными конфликтами в индекс (git add &lt;file>) и
                                                              ввести команду git rebase --continue


cherry-pick позволяет взять один коммит и применить его изменения к другой ветке без слияния
        </pre></article></div></section></main><script src="https://unpkg.com/scrollnav@3.0.1/dist/scrollnav.min.umd.js"></script><script src="index.js"></script></body></html>
<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Misc</title><link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="index.css"></head><body data-name="misc"><main class="sections-wrapper"><!--imports--><section class="section" id="imports"><div class="section-container"><h2 class="section-title">imports</h2><article class="section-info"><pre>
  <b>HTML:</b>
&lt;link rel='stylesheet' href='css/index.css'>
&lt;script src='js/main.js'>&lt;/script>

  <b>CSS:</b>
@import 'style/main.css';
@import url('https://webref.ru/style.css');

  <b>SCSS:</b>
@import 'media.scss';
@import 'media';        (media.scss / _media.scss или media.css;  нельзя указывать .css)
@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400&display=swap');

  <b>JS:</b>
&lt;script type='module'>
   import { sayHi } from './say.js'
   document.body.innerHTML = sayHi('John')
&lt;/script>


  <b>Webpack (React) CSS/SCSS:</b>
@import '~normalize.css';  или  @import '~normalize.css/normalize.css';
@import '~materialize-css/dist/css/materialize.min.css';   (~ значит из /node_modules)
@import 'fonts.css';
@import '~bootstrap/scss/bootstrap';              (в scss файле .scss можно не писать)

  <b>Webpack (React) JS:</b>
import Post from './Post'                         .js не обязательно
import './styles/styles.css'
import json from './assets/json'                  .json не обязательно, в React'е
                                                  json импортруется уже распаршеный
import webpackLogo from './assets/logo.png'       путь к картинке:  &lt;img src={webpackLogo}/>
import * as $ from 'jquery'                       путь к /node_modules не пишется, обычно скрипт
                                                  берется из /dist)
import './styles/scss.scss'
import './babel'                                  подключить модуль, но не присваивать его
                                                  переменной; подключаемый модуль может ничего
                                                  не экспортировать
export { layoutOptions } from './layoutOptions'   реэкспорт (= импорт + экспорт);
                                                  обычно реэкспортируется несколько файлов (или
                                                  все *) в index.js, который лежит в папке с
                                                  реэкспортируемыми компонентами; и соответственно
                                                  импорт происходит из .../path_to_fold_with_index
                                                  без указания пути к index.js
        </pre></article></div></section><!--RegExp--><section class="section" id="regexp"><div class="section-container"><h2 class="section-title">RegExp</h2><article class="section-info"><b>Введение: шаблоны и флаги</b><pre>
  Регулярные выражения – мощное средство поиска и замены в строке.
Оно состоит из шаблона и необязательных флагов: g, i, m, u, s, y.
В JS регулярные выражения реализованы отдельным объектом RegExp и
интегрированы в методы строк

<b>Длинный синтаксис</b> (отличается от короткого возможностью подставлять переменные с помощью `${}`):
regexp = new RegExp(pattern, flags)

<b>Короткий синтаксис</b>:
regexp = /шаблон/     <span>без флагов</span>
regexp = /шаблон/gmi  <span>с флагами</span>

<b>флаги</b>:
i - поиск не зависит от регистра - нет разницы между A и a
g - поиск ищет все совпадения, без него – только первое
m - многострочный режим
s - включает режим «dotall», при котором точка может соответствовать символу перевода строки \n
u - включает полную поддержку юникода; Флаг разрешает корректную обработку суррогатных пар
y - режим поиска на конкретной позиции в тексте


использование регулярных выражений интегрировано в методы строк: <b>str.match() и str.replace()</b>
let str = 'Любо, братцы, любо!'
let result = str.match(/любо/gi)  <span>['Любо', 'любо'] </span>

result.length <span>2</span>
  дополнительная информация:
result.index  <span>0 (позиция совпадения)</span>
result.input  <span>Любо, братцы, любо! (исходная строка)</span>

если совпадений нет, то возвращается не пустой массив, а null
let matches = 'JavaScript'.match(/HTML/) <span>null</span>

Метод str.replace(regexp, replacement) заменяет совпадения с regexp в
строке str на replacement (все, если есть флаг g, иначе только первое)
'We will, we will'.replace(/we/i, 'I')  <span>I will, we will</span>
'We will, we will'.replace(/we/ig, 'I') <span>I will, I will</span>

  В строке замены replacement мы можем использовать <b>специальные
комбинации символов для вставки фрагментов совпадения</b>:
  $& - вставляет всё найденное совпадение
"Люблю я HTML тоже".replace(/HTML/, "$& и JavaScript")  <span>"Люблю я HTML и JavaScript тоже"</span>
  $` - вставляет часть строки до совпадения
"Люблю я HTML тоже".replace(/HTML/, "$` и JavaScript")  <span>"Люблю я Люблю я  и JavaScript тоже"</span>
  $' -	вставляет часть строки после совпадения
"Люблю я HTML тоже".replace(/HTML/, "$' и JavaScript")  <span>"Люблю я  тоже и JavaScript тоже"</span>
  $$ -	вставляет символ "$"
"Люблю я HTML тоже".replace(/HTML/, "$$ и JavaScript")  <span>"Люблю я $ и JavaScript тоже"</span>


  Метод regexp.test(str) проверяет, есть ли хоть одно совпадение:
let regexp = /люблю/i
regexp.test('Я ЛюБлЮ JavaScript') <span>true</span>
        </pre></article><article class="section-info"><b>Символьные классы</b><pre>
  Символьный класс – это специальное обозначение, которое соответствует
любому символу из определённого набора

\s - пробел      <span>включает в себя символ пробела, табуляции \t, перевода строки (новой строки) \n</span>
\S - не пробел
\d - цифра
\D - не цифра
\w - слово       <span>буква латинского алфавита или цифра или подчёркивание _</span>
\W - не слово
.  - любой символ, кроме новой строки, т.е. кроме \n


  у нас есть номер телефона вида '+7(903)-123-45-6', и нам
нужно превратить его в строку только из чисел: 79035419441
let str = '+7(903)-123-45-67'
let regexp = /\d/g
str.match(regexp) <span>[7,9,0,3,1,2,3,4,5,6,7]</span>
str.match(regexp).join('')
  альтернативный, более короткий путь – найти нецифровые символы \D и удалить их из строки:
str.replace(/\D/g, '')


  Регулярное выражение может содержать как обычные символы, так и символьные классы
let str = 'Есть ли стандарт CSS4?'
let regexp = /C.S\d/
str.match(regexp) <span>['CSS4']</span>
  Также мы можем использовать несколько символьных классов:
'I love HTML5!'.match(/\s\w\w\w\w\d/) <span>[' HTML5']</span>
        </pre></article><article class="section-info"><b>Юникод: флаг 'u' и класс \p{...}</b><pre>
  Флаг u включает поддержку Юникода в регулярных выражениях.
Конкретно, это означает, что:
- символы из 4 байт воспринимаются как единое целое, а не как два символа по 2 байта
- работает поиск по юникодным свойствам \p{…}

  С помощью юникодных свойств мы можем искать слова на нужных языках,
специальные символы (кавычки, обозначения валюты) и т.д.
        </pre></article><article class="section-info"><b>Якоря: начало строки ^ и конец $</b><pre>
  У символов каретки ^ и доллара $ есть специальные значения в регулярных выражениях.
Они называются якоря.
Каретка ^ означает совпадение с началом текста, а доллар $ – с концом

  В конкретно этих случаях мы могли бы использовать и методы строк startsWith/endsWith.
Регулярные выражения следует применять, когда нужна проверка сложнее.
let str1 = 'Mary had a little lamb'
/^Mary/.test(str1) <span>true</span>
/lamb$/.test(str1) <span>true</span>

  Проверка на полное совпадение; Здесь совпадение с \d\d:\d\d ищется не где-то посредине
текста, а сразу после начала строки ^, и после него должен быть сразу конец строки $
let goodInput = '12:34'
let badInput = '12:345'
let regexp = /^\d\d:\d\d$/
regexp.test(goodInput) <span>true</span>
regexp.test(badInput)  <span>false</span>

/^$/ <span>пустая строка</span>
        </pre></article><article class="section-info"><b>Многострочный режим якорей ^ $, флаг 'm'</b><pre>
  Многострочный режим включается флагом m. Он влияет только на поведение ^ и $.
В многострочном режиме они означают не только начало/конец текста, но и начало/конец
каждой строки в тексте.

let str = `1е место: Винни
           2е место: Пятачок
           3е место: Слонопотам`
str.match(/^\d/gm) <span> ['1', '2', '3']  без флага m была бы найдена только первая цифра</span>


let str = `Винни: 1
           Пятачок: 2
           Слонопотам: 3`
str.match(/\d$/gm) <span> ['1', '2', '3']  без флага m была бы найдена только последняя цифра в 1 строке</span>
        </pre></article><article class="section-info"><b>Граница \b</b><pre>
Граница слова или числа \b – проверка, как ^ и $

'Hello, Java!'.match(/\bJava\b/)   <span>['Java']</span>
'Hello, JavaScript!'.match(/\bJava\b/)  <span>null</span>

<span>null (! не является «символом слова» \w, поэтому после него нет границы слова)</span>
'Hello, Java!'.match(/\bJava!\b/)

  Мы можем использовать \b не только со словами, но и с числами
'1 23 456 78'.match(/\b\d\d\b/g)  <span>['23', '78']</span>
'Завтрак в 09:00 в комнате 123:456'.match(/\b\d\d:\d\d\b/)  <span>['09:00']</span>
        </pre></article><article class="section-info"><b>Экранирование, специальные символы</b><pre>
  Специальные символы используются для более сложных поисковых конструкций.
Вот полный перечень этих символов   <b>[ \ ^ $ . | ? * + ( )</b>
  Чтобы использовать специальный символ как обычный его нужно
экранировать - добавить к нему обратную косую черту: \.

'Глава 5.1'.match(/\d\.\d/)     <span>['5.1']  (совпадение,  '\.' - ищет обычную точку</span>
'function g()'.match(/g\(\)/)   <span>['g()']</span>
  Если мы ищем обратную косую черту \, это специальный символ как в обычных
строках, так и в регулярных выражениях, поэтому мы должны удвоить её
'1\\2'.match(/\\/)  <span>['\']</span>

  Символ косой черты '/', так называемый «слэш», не является специальным символом,
но в JavaScript он используется для открытия и закрытия регулярного выражения: /...шаблон.../,
поэтому мы должны экранировать его
'/'.match(/\//)  <span>['/']</span>

  * При передаче строки в new RegExp нужно удваивать обратную косую черту: \\ для
экранирования специальных символов, потому что строковые кавычки «съедят» одну черту
        </pre></article><article class="section-info"><b>Наборы [...] и диапазоны [0-9A-F], «исключающие» диапазоны [^…]</b><pre>
  Несколько символов или символьных классов в квадратных скобках […] означают «искать
любой символ из заданных».
Для примера, [eao] означает любой из 3-х символов: 'a', 'e' или 'o'. Это называется набором.

<span>найти [т или х], после которых идёт 'оп'</span>
'Топ хоп'.match(/[тх]оп/gi)   <span>['топ', 'хоп']</span>
'Вуаля'.match(/В[уа]ля/)      <span>null, нет совпадений; ищет 'В', затем [у или а], потом 'ля'</span>

Ещё квадратные скобки могут содержать диапазоны символов.
К примеру, [a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5
<span>['xAF']  ищется символ, который либо цифра от 0 до 9, либо буква от A до F</span>
'Exception 0xAF'.match(/x[0-9A-F][0-9A-F]/g)  <span>['xAF']</span>

  Также мы можем использовать символьные классы внутри […].
\d – то же самое что и [0-9],   \w – что и [a-zA-Z0-9_]
  Например, если мы хотим найти «символ слова» \w или дефис -, то набор будет: [\w-]

  Помимо обычных диапазонов, есть «исключающие» диапазоны, которые выглядят как [^…].
Они обозначаются символом каретки ^ в начале диапазона и соответствуют любому символу
за исключением заданных
[^aeyo] <span>любой символ, за исключением 'a', 'e', 'y' или 'o'</span>
[^0-9]  <span>любой символ, за исключением цифры, то же, что и \D</span>
'alice15@gmail.com'.match(/[^\d\sA-Z]/gi)  <span>['@', '.']</span>

  В квадратных скобках большинство специальных символов можно использовать без экранирования !!!
разрешены без экранирования все специальные символы, кроме случаев, когда они означают что-то
особое в наборах
[-().^+]  <span>ищет один из символов -().^+</span>

'Java'.match(/Java[^script]/)         <span>null</span>
'JavaScript'.match(/Java[^script]/)   <span>['JavaS']</span>
'Завтрак в 09:00. Ужин в 21-30'.match( /\d\d[:-]\d\d/g )  <span>['09:00', '21-30']</span>
        </pre></article><article class="section-info"><b>Квантификаторы +, *, ? и {n}</b><pre>
Квантификатор указывает количество повторений

  Самый простой квантификатор — это число в фигурных скобках: {n}
Он добавляется к символу (или символьному классу, или набору [...]
и т.д.) и указывает, сколько их нам нужно
'Мне 12345 лет'.match(/\d{5}/)  <span>['12345']</span>

  Диапазон: {3,5}, от 3 до 5
Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}
'Мне не 12, а 1234 года'.match(/\d{3,5}/)  <span>['1234']</span>
  Верхнюю границу можно не указывать. Тогда шаблон \d{3,} найдёт
последовательность чисел длиной 3 и более цифр
'+4(903)-123-45-67'.match(/\d{1,}/g)  <span>['4','903','123','45','67']</span>


  Короткие обозначения:
<b>+  -  «один или более»; то же самое, что и {1,}</b>
'+4(903)-123-45-67'.match(/\d+/g)  // ['4','903','123','45','67']

<b>?  -  «ноль или один»; то же самое, что и {0,1}; по сути, делает символ необязательным</b>
'Следует писать color или colour?'.match(/colou?r/g) // ['color', 'colour']

<b>*  -  «ноль или более»; то же самое, что и {0,};</b>
то есть символ может повторяться много раз или вообще отсутствовать
'100 10 1'.match(/\d0*/g) // ['100', '10', '1']


'Привет!... Как дела?.....'.match(/\.{3,}/g)  <span>['...', '.....']</span>

let styles = 'color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678'
styles.match( /#[a-f0-9]{6}\b/gi )   <span>['#121212', '#AA00ef']</span>
        </pre></article><article class="section-info"><b>Жадные и ленивые квантификаторы</b><pre>
  У квантификаторов есть два режима работы:

- <b>Жадный (по умолчанию)</b>
  По умолчанию движок регулярного выражения пытается повторить квантификатор столько раз,
сколько это возможно. Из примера ниже: .+ получит все символы. Когда движок дойдёт до конца
строки, он продолжит искать совпадение для оставшегося шаблона, т.е. для ". Т.к. строка
закончилась, совпадения не будет => он уменьшит количество повторов (осуществит возврат
на один символ назад с конца) и попробует снова. Откат будет до символа m, после которого
идет " из шаблона.
'a "witch" and her "broom" is one'.match(/".+"/g)   <span>['"witch" and her "broom"']</span>

- <b>Ленивый</b>
  Включается с помощью знака вопроса ? после квантификатора. То есть будет *? или +? или даже ??.
Движок пытается найти совпадение для оставшегося шаблона перед каждым повторением квантификатора
'a "witch" and her "broom" is one'.match(/".+?"/g)   <span>['"witch"', '"broom"']</span>


  Альтернативный ленивому вариант поиска "witch", "broom" в жадном режиме:
'a "witch" and her "broom" is one'.match(/"[^"]+"/g)	 <span>['"witch"', '"broom"']</span>

  Первый, ленивый шаблон, \d+? попытается получить как можно меньше цифр до первого
пробела; Второй \d+? возьмёт только одну цифру, потому что этого будет достаточно
'123 456'.match(/\d+? \d+?/g)  <span>['123', '4']</span>
        </pre></article><article class="section-info"><b>Скобочные группы</b><pre>
Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».

           У такого выделения есть два эффекта:
- Позволяет поместить часть совпадения в отдельный массив
- Если установить квантификатор после скобок, то он будет
  применяться ко всему содержимому скобки, а не к одному символу

"my-site.com  my.site.com".match( /([\w-]+\.)+\w+/g )  <span>my-site.com, my.site.com</span>


  Метод str.match(regexp), если у регулярного выражения regexp
нет флага g, ищет первое совпадение и возвращает его в виде массива:
На позиции 0 будет всё совпадение целиком
На позиции 1 – содержимое первой скобочной группы
На позиции 2 – содержимое второй скобочной группы и так далее…

  Например, мы хотим найти HTML теги &lt;.*?> и обработать их.
Было бы удобно иметь содержимое тега (то, что внутри уголков) в отдельной переменной.
let tag = '&lt;h1>Hello, world!&lt;/h1>'.match( /&lt;(.*?)>/ )
tag[0]  <span>&lt;h1>  - полное совпадение</span>
tag[1]  <span>h1</span>


    <b>Вложенные группы</b>.  Скобки могут быть и вложенными

let result = '&lt;span class="my">'.match( /&lt;(([a-z]+)\s*([^>]*))>/ )
result[0]  <span>&lt;span class="my">     - полное совпадение</span>
result[1]  <span>span class="my"       - первая скобка</span>
result[2]  <span>span                  - 1 вложенная скобка</span>
result[3]  <span>class="my"            - 2 вложенная скобка</span>


    <b>Необязательные группы</b>

(...)?  -  необязательная
let match = 'ac'.match(/a(z)?(c)?/)
match.length  <span>3, длина массива всегда равна 3, т.к. 2 группы</span>
match[0]      <span>ac (всё совпадение)</span>
match[1]      <span>undefined, потому что для (z)? ничего нет</span>
match[2]      <span>c</span>


    <b>Поиск всех совпадений с группами: matchAll</b>

  при поиске всех совпадений (флаг g) метод match не
возвращает скобочные группы. Например, попробуем найти все теги в строке:
let tags = '&lt;h1> &lt;h2>'.match( /&lt;(.*?)>/g )
alert( tags ) <span>&lt;1>, &lt;h2>  - массив совпадений, но без деталей о каждом</span>

  чтобы получать скобочные группы для всех совпадений,
мы можем использовать метод str.matchAll(regexp).
Он, как и str.match(regexp), ищет совпадения, но у него есть три отличия:
- Он возвращает не массив, а перебираемый объект.
- При поиске с флагом g, он возвращает каждое совпадение в виде массива со скобочными группами.
- Если совпадений нет, он возвращает не null, а просто пустой перебираемый объект.

let results = '&lt;h1> &lt;h2>'.matchAll(/&lt;(.*?)>/gi)
let [tag1, tag2] = results  <span>деструктуризация перебираемого объекта</span>
alert( tag1[0] ) <span>&lt;h1></span>
alert( tag1[1] ) <span>h1</span>
alert( tag1.index ) <span>0,  дополнительное свойство index (позиция совпадения)</span>
alert( tag1.input ) <span>&lt;h1> &lt;h2>,  дополнительное свойство input (исходный текст)</span>


    <b>Именованные группы</b>

  Гораздо лучше – давать скобкам имена.
Это делается добавлением ?&lt;name> непосредственно после открытия скобки.
        группы располагаются в свойстве groups результата match
let dateRegexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/g
let results = "2019-10-30 2020-01-01".matchAll(dateRegexp)
for(let result of results) {  <span>проходимся по итерируемому объекту</span>
  let {year, month, day} = result.groups
  alert(`${day}.${month}.${year}`) <span>первый вывод: 30.10.2019   второй: 01.01.2020</span>
}


    <b>Скобочные группы при замене</b>

  str.replace(regexp, replacement) позволяет использовать в строке замены содержимое
скобок. Это делается при помощи обозначений вида $n, где n – номер скобочной группы
'John Bull'.replace(/(\w+) (\w+)/, '$2, $1')  <span>Bull, John</span>

  Для именованных скобок ссылка будет выглядеть как $&lt;имя>
let regexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/g
'2019-10-30, 2020-01-01'.replace(regexp, '$&lt;day>.$&lt;month>.$&lt;year>')  <span>30.10.2019, 01.01.2020</span>


      Исключение из запоминания скобочных групп через ?:
Бывает так, что скобки нужны, чтобы квантификатор правильно применился, но
мы не хотим, чтобы их содержимое было выделено в результате. Скобочную группу
можно исключить из запоминаемых и нумеруемых, добавив в её начало ?: (?:...)
        </pre></article><article class="section-info"><b>Обратные ссылки в шаблоне: \N и \k&lt;имя></b><pre>
                         Обратная ссылка по номеру: \N
  К группе можно обратиться в шаблоне, используя \N, где N – это номер группы.
Таким образом мы ссылаемся на содержимое указанной группы.
  Пример: необходимо найти строки в кавычках: либо одинарных '...', либо двойных "..."
let str = `He said: "She's the one!".`
str.match( /['"](.*?)['"]/g )   <span>"She'   результат - не тот, который хотелось бы</span>
  а вот так сработает, \1 означает «найти то же самое, что в первой скобочной группе»
str.match( /(['"])(.*?)\1/g )  <span>"She's the one!"</span>

                         Обратная ссылка по имени: \k&lt;имя>
  Для обращения к именованной группе можно использовать синтаксис \k&lt;имя>
let regexp = /(?&lt;quote>['"])(.*?)\k&lt;quote>/g
`He said: "She's the one!".`.match(regexp)  <span>"She's the one!"</span>
        </pre></article><article class="section-info"><b>Альтернация (или) |</b><pre>
  Альтернация – термин в регулярных выражениях, которому соответствует слово «ИЛИ».
В регулярных выражениях она обозначается символом вертикальной черты |
let str = 'Сначала появился язык Java, затем HTML, потом JavaScript'
str.match( /html|css|java(script)?/gi )  <span>Java, HTML, JavaScript</span>

  Квадратные скобки (т.е. наборы) работают только с символами или наборами символов.
Альтернация мощнее, она работает с любыми выражениями
gr(a|e)y                <span>означает точно то же, что и gr[ae]y</span>
gra|ey                  <span>означает gra или ey</span>
Люблю HTML|CSS          <span>найдёт Люблю HTML или CSS</span>
Люблю (HTML|CSS)        <span>найдёт Люблю HTML или Люблю CSS</span>

let regexp = /([01]\d|2[0-3]):[0-5]\d/g
'00:00 10:10 23:59 25:99 1:2'.match(regexp)  <span>00:00, 10:10, 23:59</span>
        </pre></article><article class="section-info"><b>Опережающие (lookahead) и ретроспективные (lookbehind) проверки</b><pre>
  Иногда нужно найти соответствия шаблону, но только те,
за которыми или перед которыми следует другой шаблон.

                    <b>X(?=Y)  -   опережающая проверка</b>
синтаксис опережающей проверки означает: найди X при условии,
что за ним следует Y. Вместо X и Y здесь может быть любой шаблон.
 При поиске X(?=Y) движок регулярных выражений, найдя X, проверяет
есть ли после него Y. Если это не так, то игнорирует совпадение и
продолжает поиск дальше.
<span>30    число 1 проигнорировано, так как за ним НЕ следует €</span>
'1 индейка стоит 30€'.match(/\d+(?=€)/)

X(?=Y)(?=Z) <span>этот шаблон означает, что мы ищем X при условии, что за ним идёт и Y и Z</span>
  ищет \d+ при условии, что за ним идёт пробел, и где-то впереди есть 30
'1 индейка стоит 30€'.match(/\d+(?=\s)(?=.*30)/)  <span>1</span>

                    <b>X(?!Y)  -   негативная опережающая проверка</b>
Допустим, нам нужно узнать из этой же строки количество индеек,
то есть число \d+, за которым НЕ следует знак €
'2 индейки стоят 60€'.match(/\d+(?!€)/)  <span>2</span>


                    <b>(?&lt;=Y)X  -   ретроспективная проверка</b>
ищет совпадение с X при условии, что перед ним ЕСТЬ Y
'1 индейка стоит $30'.str.match(/(?&lt;=\$)\d+/)  <span>30</span>

                    <b>(?&lt;!Y)X  -   негативная ретроспективная проверка</b>
ищет совпадение с X при условии, что перед ним НЕТ Y
'2 индейки стоят $60'.match(/(?&lt;![\$\d])\d+/)  <span>2</span>

  Скобочные группы внутри опережающей и ретроспективной проверки.
В некоторых ситуациях нам может быть интересно захватить и то,
что в проверке. Для этого нужно обернуть это в дополнительные скобки.
'1 индейка стоит 30€'.match(/\d+(?=(€|kr))/)  <span>30 (match 1), € (group 1)</span>
        </pre></article><article class="section-info"><b>Поиск на заданной позиции, флаг 'y'</b><pre>
  Если у регулярного выражения в методе regexp.exec(str) есть флаг g (глобальный поиск), то
поиск осуществляется в строке str, начиная с позиции, заданной свойством regexp.lastIndex.
И, когда находит, обновляет regexp.lastIndex на позицию после совпадения.
При создании регулярного выражения его свойство lastIndex равно 0.
Так что повторные вызовы regexp.exec возвращают совпадения по очереди, одно за другим.

let str = 'let varName'
let regexp = /\w+/g
alert(regexp.lastIndex)  <span>0 (при создании lastIndex === 0)</span>

let word1 = regexp.exec(str)
alert(word1[0])  <span>let (первое слово)</span>
alert(regexp.lastIndex)  <span>3 (позиция за первым совпадением)</span>

let word2 = regexp.exec(str)
alert(word2[0])  <span>varName (второе слово)</span>
alert(regexp.lastIndex)  <span>(позиция за вторым совпадением)</span>

let word3 = regexp.exec(str)
alert(word3)  <span>null (больше совпадений нет)</span>
alert(regexp.lastIndex)  <span>0 (сбрасывается по окончании поиска)</span>

  То есть, при флаге g свойство lastIndex задаёт начальную позицию поиска


  Флаг y заставляет regexp.exec искать ровно на позиции lastIndex, ни до и ни после !
И если не находит на заданной позиции, то возвращает null и прекращает поиск
let str = 'let varName = "value"'

let regexp = /\w+/y

regexp.lastIndex = 3
alert( regexp.exec(str) )  <span>null (на позиции 3 пробел, а не слово)</span>

regexp.lastIndex = 4
alert( regexp.exec(str) )  <span>varName (слово на позиции 4)</span>

alert( regexp.lastIndex )  <span>11</span>
alert( regexp.exec(str) )  <span>null, на позиции 11 нет совпадения (на позиции 11 пробел, а не слово)</span>
        </pre></article></div></section><!--local servers--><section class="section" id="local_servers"><div class="section-container"><h2 class="section-title">local servers</h2><article class="section-info"><pre>
                              <b>локальные серверы:</b>

   <b>простые (ограничен функционал):</b>
http-server (npm i -g http-server, запускаем в папке с проектом http-server -c-1 ./)
browsersync (browser-sync start --server --files 'index.html' 'style.css' 'index.js')
liveServer (vsc)
<span>для запуска серверной части, что бы файл с БД (db.json) отдавал данные</span>
json-server  (json-server db.json -p 4000)

   <b>полноценные (поддерживающие все запросы, не только GET):</b>
OpenServer
MAMP

сервис для тестирования запросов всех видов: https://jsonplaceholder.typicode.com
        </pre></article></div></section><!--Prettier & Eslint--><section class="section" id="prettier&eslint"><div class="section-container"><h2 class="section-title">Prettier / ESlint</h2><article class="section-info"><pre>
  <b>Prettier</b> - форматер кода в соответствии с набором правил

  <b>установка prettier:</b>
npm install -g prettier
npm install -D --save-exact prettier   <span>--save-exact значит точная версия без диапазона</span>

  <b>config example .prettierrc.json:</b>
{ <span>на сайте есть playground для конфигурации</span>
  "tabWidth": 2,
  "semi": true,            <span>;</span>
  "arrowParens": "always", <span>включите круглые скобки вокруг единственного параметра стрелочной ф-ии</span>
  "trailingComma": "none", <span>, в конце последнего поля</span>
  "singleQuote": true      <span>'' вместо ""</span>
}

  <span>npx позволяет запускать локально установленные инструменты
    Примечание: если вы забудете сначала установить Prettier, npx временно
  загрузит последнюю версию. Это не очень хорошая идея при использовании Prettier,
  потому что Prettier меняет форматирование кода в каждом выпуске! Важно иметь
  заблокированную версию Prettier (--save-exact) в package.json</span>
  <b>запуск prettier</b> (можно и в скрипте в package.json):
format all files with prettier:     "npx prettier --write ."
format a certain directory:         "npx prettier --write app/"
format a certain file:              "npx prettier --write app/components/Button.js"
format all tests in a directory:
"npx prettier --write \"app/**/*.js\" && npx prettier --write \"configurator/**/*.js\""


* в webStorm встроена поддержкой Prettier;
  в поле Prettier package нужно выбрать пакет prettier из node_modules проекта;
  можно настроить что бы форматировать файлы при сохранении или при нажатии ctrl + alt + l

* можно автоматически запускать форматирование перед каждым коммитом с помощью <b>husky</b>
        </pre></article><article class="section-info"><pre>
  <b>ESLint</b> - инструмент, который анализирует код на наличие ошибок, которые могут включать
стилистические ошибки, а также ошибки кода, которые приводят к ошибкам и оповещает о них.
  Например, ESLint предупредит, если разработчик использует переменную, не объявив ее
предварительно. Или если разработчик использует bind, когда в этом нет необходимости.
  ESLint сообщит, что он считает неправильным, и <b>с опцией –fix как то это поправит.</b>
  Prettier и ESLint дополняют друг друга, но они также могут конфликтовать, когда
возникает ошибка в стиле кода, т.к. у линтеров обычно также есть стилизация.
  В ESLint можно выключить правила которые конфликтуют или необязательны с Prettier
с помощью этой готовой конфигурации:  eslint-config-prettier

  Чтобы была подсветка в редакторе, нужно поставить ESLint плагин или, в случае
с WebStorm, просто в настройках активировать ESLint.
  Так же лучше установить глобально пакет eslint что бы выполнять авто fix отдельных
файлов или папок в случае ошибок, например из папкт проета:
<b>eslint --fix webpack.config.js src</b> (пофиксить webpack.config.js и /src)


  <b>установка ESLint:</b>
npm install -D eslint

  <b>config example .eslintrc.json:</b>
{
  "extends": [
    "react-app",
    "prettier/@typescript-eslint",
    "plugin:prettier/recommended"
  ],
  "settings": {
    "react": {
      "versions": "detect"
    }
  }
}

  <b>.eslintignore example:</b>
build

  <span>запуск линтинга файла/папки:</span>
npx eslint yourfile.js   /   npx eslint ./src


eslint-config-prettier     - отключает все правила, которые не нужны или могут
                             противоречить Prettier
eslint-plugin-prettier     - запускает Prettier как правило ESLint. Этот плагин работает
                             лучше всего, если вы отключите все другие правила ESLint,
                             связанные с форматированием кода, и включите только правила,
                             которые обнаруживают потенциальные ошибки.
                              Можете использовать eslint-config-prettier, чтобы отключить
                             все правила ESLint, связанные с форматированием.
                               Плагин поставляется с конфигурацией plugin:prettier/Recommended,
                             которая настраивает и плагин, и eslint-config-prettier.
                               Нужно добавить plugin:prettier/recommended в качестве
                             последнего расширения в .eslintrc.json:
                                {
                                  "extends": ["plugin:prettier/recommended"]
                                }
                             Затем вы можете установить собственные параметры Prettier
                             в .prettierrc.json
babel-eslint               - позволяет линтить Babel код (экспериментальные функции, которые
                             пока не поддерживаются в самом ESLint)
eslint-plugin-import       - для поддержки синтаксиса импорта/экспорта ES6+ и предотвращения
                             проблем с неправильным написанием путей к файлам и имен импорта
eslint-plugin-react        - особые React'ие правила линтинга. Также заставит вас приписывать
                             ко всем своим компонентам описания принимаемых ими типов данных
eslint-plugin-react-hooks  - обеспечивает соблюдение правил хуков
eslint-config-react-app    - включает общую конфигурацию ESLint, используемую Create React App
                               в .eslintrc.json:
                             {
                               "extends": "react-app"
                             }
                               можно переопределить настройки eslint-config-react-app,
                             отредактировав .eslintrc.json



* если нужно <b>проигнорировать ругание линтера</b>, можно над строкой с ошибкой поставить:
  // eslint-disable-next-line    или например    // eslint-disable-next-line no-undef
        </pre></article></div></section><!--Babel--><section class="section" id="babel"><div class="section-container"><h2 class="section-title">Babel</h2><article class="section-info"><pre>
  <b>Babel</b> - транспилирует ES6+ в обратно-совместимую версию JavaScript (ES5-), которую
могут запускать старые движки JS. Нестандартный синтаксис JavaScript, такой как JSX, также
можно преобразовать c помощью Babel.
  Т.е. Babel переписывает код, преобразовывая новые синтаксические конструкции (не путать
со встроенными фичами) в старые с помощью babel-плагинов или <b>пресетов (наборов плагинов)</b>

  пример плагинов:
@babel/preset-react                       - для траспилции JSX
@babel/plugin-proposal-class-properties   - для транспиляции статических свойств/методов класса


  Так же Babel предоставляет polyfill'ы для поддержки фич, которые полностью отсутствуют
в средах JavaScript. Например, статические методы, такие как Array.from, и встроенные, такие
как Promise, доступны только в ES6+, но их можно использовать в более старых версиях, если
используется polyfill Babel.
  Т.е. <b>polyfill</b> - код, написанный в старом стандарте для замещения встроенных функций, которых
не существует в старых браузерах

  <b>хранилища полифилов</b>, помимо @babel/polyfill:
core-js (www.npmjs.com/package/core-js) - поддерживает много функций, можно подключать
                                          только нужные
polyfill.io - сервис, который автоматически создаёт скрипт с полифилом в зависимости от
              необходимых функций и браузера пользователя


  <b>установка базовых пакетов:</b>
npm i -D @babel-cli @babel-core @babel/preset-env

  <b>скрипт в package.json:</b>
<span>файлы из app/js транспилируем и помещаем в app/dist, используя --preset-env</span>
"watch": "babel app/js -d app/dist --preset-env -w"

  Чтобы включить только полифилы и преобразования кода, необходимые пользователям, чьи
браузеры занимают >0,25% рынка (игнорируя браузеры без обновлений безопасности, таких
как IE 10) можно в package.json указать поле "browserslist": "> 0.25%, not dead"



   <b>можно так же создать конфиг babel.config.json:</b>
{
  "presets": ["@babel/preset-env"]
}
        </pre></article></div></section><!--webpack--><section class="section" id="webpack"><div class="section-container"><h2 class="section-title">webpack</h2><article class="section-info"><pre>
  При обычном подключении скриптов в html нужно учитывать правильность путей и
последовательность подключения. webpack решает эти задачи. Так же он обрабатыват
всю графику, стили, шрифты и другие файлы

  В webpack js файлы автоматически становятся модулями (как скрипт с type='module')

  С webpack можно взаимодействовать через консоль, но удобней через конфигурационный
файл: для этого в корне нужно создать файл <b>webpack.config.js</b>.
  webpack работает на платформе nodeJS => в webpack.config.js <b>можно использовать
последний синтаксис JS</b> т.к. nodeJS его понимает

  В новой версии Node.js локальные npm пакеты нужно запускать с помощью утилиты npx.
Например: <b>npx webpack вместо webpack</b>.
  В поле scripts в package.json можно не писать npx

  <b>В webpack можно импортировать все виды файлов прямо в js-файл - достаточно загрузить
определенный лоадер</b>. webpack сам по себе может работать только с js-файлами, он не
понимает ни css, ни картинки, ни шрифты... Чтобы webpack мог работать с другими типами
данных ему нужны лоадеры.
  Для json-файлов лоадеры не нужны, их можно просто импортировать в js-файлы


  <b>В webpack есть 2 режима компиляции</b>, которые отличаются скоростью работы и уровнем
оптимизации кода:
--mode=development
--mode=production  (default)
  По дефолту webpack работает в режиме production, если не указывать режим явно с
помощью ключа в скриптах в package.json.
  В webpack.config.js указываем mode: 'development', что бы если не указан ключ в
package.json, webpack запускался в режиме разработки


  <b>флаг --watch</b> в скрипте в package.json позволяет следить за изменением файлов

  <b>webpack-dev-server</b> складывает все бандлы и файлы в оперативную память,
поэтому, <b>пока мы из него не вышли ^C, мы не увидем изменений в /dist</b>
  webpack-dev-server запускается командой serve и можно без слова run:  npm start

  <b>HMR</b> — (Hot Module Replacement) заменяет, добавляет или удаляет модули во
время работы приложения (например при добавлении файла с новым hash'ом в
названии его нужно подключить вместо старого) без полной перезагрузки.
  Так же <b>HMR позволяет сохранять состояние приложения, которое теряется во
время полной перезагрузки</b>

  Команда stats в package.json создает в корне stats.json со статистикой
webpack-bundle-analyzer и открывает инфографику, как и после команды build (в
--mode production)



<b>Команды:</b>

npx webpack                               запускает приложение (создает bundle.js)
cross-env NODE_ENV='&lt;mode>'               устанавливает системному свойству NODE_ENV
                                          режим development или production


<b>Пакеты:</b>

webpack                               корневой функционал webpack
webpack-cli                           отвечает за команды webpack, которые доступны в консоле
html-webpack-plugin                   меняет подключаемые пути и имена файлов и отправляет
                                      html в output каталог + подключает js-бандл в html;
                                      так же минифицирует html
css-loader                            позволяет понимать импорты css файлов в js и отправляет
                                      файл в output каталог
style-loader                          вставляет inline стили в html тег &lt;head>; поэтому
                                      мы его не используем, а исползуем mini-css-extract-plugin,
                                      который ищет импорты стилей и превращает их в отдельный
                                      файл + автоматом подключает его в html
file-loader                           преобразует import/require для файла (картинки, шрифты) в
                                      URL и отправляет файл в output каталог
webpack-dev-server                    разворачивает локальный сервер с вотчингом файлов и
                                      автоперезагрузкой
copy-webpack-plugin                   копирует файл или папку в нужное место без обработки
cross-env                             определяет в какой ОС мы находимся для правильной установки
                                      системной переменной NODE_ENV, указывающей режим разработки
                                      development или production; для этого в package.json при
                                      запуске скрипта указываем значение NODE_ENV. Например,
                                      cross-env NODE_ENV=development и в конфиге webpack юзаем ее
mini-css-extract-plugin               как плагин: ищет импорты стилей и превращает их в отдельный
                                      файл;
                                      как лоадер (MiniCssExtractPlugin.loader): позволяет не
                                      перезагружать страницу при изменениях и добавляет стили в
                                      секцию &lt;head> в html
optimize-css-assets-webpack-plugin            минифицирует css
terser-webpack-plugin                         минифицирует js
node-sass                                     корневой функционал sass и scss
sass-loader                                   для взаимодействия webpack и sass
@babel/core                                   корневой функционал babel
babel-loader                                  для взаимодействия webpack и babel
@babel/preset-env                             preset-env включает все плагины
                                              для преобразования ES6+ в ES5
@babel/polyfill                               для использования async/await
                                              (полифилы устанавливаются в dependencies)
                                              (deprecated! вместо него теперь следует
                                              ставить npm i regenerator-runtime core-js@3.9.0)
@babel/plugin-proposal-class-properties       плагин для транспиляции статических
                                              свойств/методов класса
webpack-bundle-analyzer                       анализирует размер файлов и библиотек в
                                              приложении и воводит инфографику
        </pre><pre>
          <code class="language-js">
                                                                                  package.json

"scripts": {
  "dev":   "cross-env NODE_ENV=development webpack --mode=development",
  "build": "cross-env NODE_ENV=production webpack --mode=production",
  "watch": "cross-env NODE_ENV=development webpack --mode=development --watch",
  "start": "cross-env NODE_ENV=development serve --mode=development --open",
  "stats": "webpack --json > stats.json && webpack-bundle-analyzer stats.json"
},
"browserslist": "> 0.25%, not dead"  // для @babel/preset-env
          </code>
        </pre><pre>
          <code class="language-js">
                                                                             webpack.config.js

// require('plugin-name') подключает встроенные модули или модули из node_modules
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const CopyPlugin = require('copy-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const optimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const terserWebpackPlugin = require('terser-webpack-plugin')
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')

// значение системной переменной NODE_ENV задается в поле package.js
// при вызове скриптов (нужен пакет 'cross-env' в devDependencies)
const isDev = process.env.NODE_ENV === 'development',
      isProd = !isDev

const plugins = () => {  // возвращает массив плагинов
  const base = [ // все плагины добавляются в массив плагинов как инстенсы
    // подключает js-бандл(ы) в html-файл и меняет его(их) подключаемое имя
    // при зменении в js-бандле + отправляет html в output каталог (/dist)
    new HtmlWebpackPlugin({
      // чтобы title и весь контент брался из исходного html указывается template
      template: './index.html',
      minify: { collapseWhitespace: isProd }  // для минификации в режиме production
    }),
    // копируем файл/папку в нужное место без обработки
    new CopyPlugin({
      patterns: [
        {
          from: path.resolve(__dirname, 'src/favicon.ico'),
          to: path.resolve(__dirname, 'dist')
        }
      ],
    }),
    new MiniCssExtractPlugin({
      filename: filename('css')
    })
  ]

  if (isProd) { // используем analyzer в режиме production (когда все оптимизировано)
    base.push(new BundleAnalyzerPlugin())
  }

  return base
}

const optimization = () => {  // возвращает настройку оптимизации (chunks, миниф-е css и js)
  const config = {
    // чтобы в бандлах (если их несколько) не дублировались одни и те же библиотеки и
    // др. файлы, подключаемые в разных точках входа; webpack будет выносить общий для
    // бандлов код (библиотеку) в отдельный файл с префиксом vendors
    splitChunks: {
      chunks: 'all'
    }
  }

  if (isProd) {
    config.minimizer = [ // минифицирование css и js
      new optimizeCssAssetsWebpackPlugin(),
      new terserWebpackPlugin()
    ]
  }

  return config
}

// в режиме development нет смысла в длинных названиях => паттерн [hash] только для production
const filename = ext => isDev ? `[name].${ext}` : `[name].[hash].${ext}`


module.exports = {	// нужно экспортировать объект-конфигурации webpack
  context: path.resolve(__dirname, 'src'), // для упрощения конфига говорим где исходники
  mode: 'development',
  entry: { // точка(и) входа; если несколько точек входа (чанков), то значение объект
    // кастомное название точки входа, например main;
    // для одной точки входа можно: entry: './index.js'
    main: ['@babel/polyfill', './index.js'], // сюда подключается polyfill для babel
    analytics: './analytics.js'
  },
  output: {	 // указываем куда все складывать - точку(и) выхода
    // можно добавить паттерн имени [name] (вместо паттерна станет имя файла) чтобы
    // для каждой точки входа, если их несколько, генерировалась своя точка выхода;
    // если этого не сделать, то в одной точке выхода смешаются независимые файлы из входа;
    //   чтобы не возникало проблем с кэшированием (после изменений в проекте бандл
    // пересобирается, а имя файла не меняется, и оно кэшируется браузером) можно
    // динамически менять имя шаблоном контента [hash]; он генерируется по содержимому
    // файла; т.е. при изменении приложения и залитии на прод юзер сразу увидит обновления
    filename: filename('js'),
    path: path.resolve(__dirname, 'dist'),  // складываем в папку dist бандл(ы)
    clean: true  // чтобы папка /dist очищалась от старых ненужных файлов (со старым [hash])
  },
  // с такой ↑ минимальной конфигурацией (entry, output) нам доступны import, export,
  // require, module.exports в скриптах; и теперь не нужно думать в каком порядке
  // выстраивать различные скрипты и мы можем удобно декомпозировать всё приложение

  plugins: plugins(),

  module: { // loaders для загрузки в js-файлы разных рес-в: картинок, стилей, шрифтов...
    rules: [
      {
        // если webpack встречает импорты в js-файле с расширением .css,
        // то нужно использовать: css-loader -> style-loader;
        test: /\.css$/,
        // use: ['style-loader', 'css-loader']  // порядок важен, справа-налево!

        // вместо style-loader лучше использовать miniCssExtractPlugin.loader
        // (так же подключаем как плагин miniCssExtractPlugin)
        use: [
          {
            loader: MiniCssExtractPlugin.loader, // добавляет стили в &lt;head> в html
            options: {
              hmr: isDev,  // Hot Module Reloading
              reloadAll: true
            }
          },
          'css-loader'
        ]
      },
      {
        test: /\.s[ac]ss$/,
        use: [
          {
            loader: miniCssExtractPlugin.loader,
            options: {
              hmr: isDev,
              reloadAll: true
            }
          },
          'css-loader',
          'sass-loader'
        ]
      },
      {
        test: /\.(png|jpg|svg|gif)$/,
        use: ['file-loader']
      },
      {
        test: /\.(ttf|eot|woff|woff2)$/,
        use: ['file-loader']
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: ['@babel/plugin-proposal-class-properties']
          }
        }
      }
    ]
  },

  // добавлять исходные карты для стилей и скриптов если в режиме development
  devtool: isDev ? 'source-map' : '',

  devServer: {    // настройка webpack-dev-server
    port: 4200,
    open: true,
    hot: isDev,   // HMR
    watchFiles: './src'
  },

  resolve: {  // дополнительные встроенные возможности webpack
    // набор разрешений, которые можно не указывать при импорте (по дефолту только .js)
    // extensions: ['.js', '.png'],
    alias: { // регистрируем псевдонимы для удобного указания путей
      '@': path.resolve(__dirname, 'src')
    }
  },

  optimization: optimization()
}
          </code>
        </pre></article></div></section><!--OOP--><section class="section" id="oop"><div class="section-container"><h2 class="section-title">OOP</h2><article class="section-info"><pre>
  Изначально код писался в функциональном (процедурном) стиле.
Т.е. программа писалась только функциями. Минусы функционального подхода:
много кода, трудности в чтении, организвции логики, сложность в организации
отдельных модулей

  В результате появилось ООП. Его основная идея - любую структуру в приложении
можно представить в виде объекта или класса


                              <b>Концепция ООП состоит из 4 китов:</b>

<b>1. Абстракция</b>
Выразить в абстракцию - выделить какую то сущность, которая объединяет общую логику (как
можно больше высокоуровневых свойств, методов).
  Например, на сайте есть кнопка входа и кнопка поделиться. Можно дать кнопкам одинаковый
класс. Этому классу можно задать общие св-ва и методы, присущие всем кнопкам. А уже на более
низком уровне, в рамках класса конкретной кнопки, реализовывать присущий конкретной кнопке
функционал

<b>2. Наследование</b>
Создаем класс кнопки входа, унаследованный от общего для всех кнопок класса. Затем
добавляем этой кнопке уникальные свойства и методы, отвечающие за вход в личный кабинет

<b>3. Инкапсуляция</b>
Для скрытия внутреннего интерфейса мы используем защищённые или приватные свойства и методы.
То есть прячем (_ или #) внутри класса все методы и свойства, которые нужны для внутреннего
пользования и даем наружу только те, о которых должен знать пользователь

<b>4. Полиморфизм</b>
Буквально переводится - множество форм, многообразие;
Полиморфизм - изменение поведения одноименного метода в рамках разных классов, например,
наследующих друг от друга; Или когда экземпляр класса переопределяет метод из прототипа.
  То есть название метода одинаковое, но сам метод меняет свои действия. Например, кнопка
входа расширяет унаследованный метод deleteBtn, выводя так же в консоль - кнопка входа
удалена.
  Так же это возможность переменной принимать разные типы данных. Или для функции это
возможность возвращать разные значения в зависимости от типа передаваемых аргументов.
  Разная реализация метода toString у встроенных классов это так же пример полиморфизма


  Так же к ООП относится <b>композиция и агрегация</b> - вариант межклассового взаимодействия,
в добавок к наследованию, при котором одни классы или объекты содержат в себе другие.
  Пример композиции - в конструкторе класса свойству присваивается значение в виде
экземпляра какого то класса.
  Пример агрегации - класс, который используется внутри другого класса, передается
в качестве аргумента конструктору
        </pre></article></div></section><!-- js patterns --><section class="section" id="js_patterns"><div class="section-container"><h2 class="section-title">js patterns</h2><article class="section-info"><pre>
  Шаблон проектирования — повторяемая архитектурная конструкция, представляющая собой решение
                          проблемы проектирования в рамках некоторого часто возникающего контекста

  <b>шаблоны проектирования можно поделить на 3 группы:</b>
creational (пораждающие)    - позволяют создавать какие то объекты и классы
structural (структурные)    - для правильного добавления нового функционала в имеющуюся систему
behavioral (поведенческие)  - позволяет выстроить лучшую коммуникацию между объектами, классами...


* не нужно подстраивать свой код под какой то паттерн!


<b>creational patterns:</b>               <b>structural patterns:</b>               <b>behavioral patterns:</b>
<a href="#singleton">singleton</a>                        <a href="#decorator">decorator</a>                        <a href="#mediator">mediator</a>
<a href="#factory-method">factory-method</a>                   <a href="#facade">facade</a>                           <a href="#iterator">iterator</a>
<a href="#abstract-factory">abstract-factory</a>                 <a href="#proxy">proxy</a>                            <a href="#chain-of-responsibility">chain-of-responsibility</a>
<a href="#prototype">prototype</a>                        <a href="#adapter">adapter</a>                          <a href="#strategy">strategy</a>
<a href="#builder">builder</a>                          <a href="#composite">composite</a>                        <a href="#memento">memento</a>
                                   <a href="#bridge">bridge</a>                           <a href="#template-method">template-method</a>
                                   <a href="#flyweight">flyweight</a>                        <a href="#visitor">visitor</a>
                                                                      <a href="#command">command</a>
                                                                      <a href="#observer">observer</a>
                                                                      <a href="#state">state</a>



<b class="center">CREATIONAL PATTERNS:</b>

<b id="singleton">singleton (одиночка)</b>   - используется для того, чтобы ограничиться одним экземпляром класса,
                         т.е. при каждом вызове будет создаваться новая ссылка на один и тот
                         же ранее созданный экземпляр, а не создавать новый.
                         Пример использования: корзина или карта клиента в интернет магазине
        </pre><pre>
          <code class="language-js">
class Counter {
  constructor() {
    if (typeof Counter.instance === 'object') {
      return Counter.instance // если уже был создан объект - возвращаем на него ссылку
    }
    this.count = 0
    Counter.instance = this  // записываем в свойство ссылку на 1й создаваемый объект
    return this
  }

  getCount() {
    return this.count
  }

  increaseCount() {
    return this.count++
  }
}
          </code>
        </pre><hr><pre>
<b id="factory-method">factory method (фабричный метод)</b>   - создание класса для создания множества однотипных
                                     объектов на основании входных данных.
                                       Простая фабрика может состоять из 2 классов:
                                     • конструктор - генерирует новый объект
                                     • фабрика - вызывает создание объекта
                                                 с определенными параметрами
                                       Классов-конструкторов может быть несколько
        </pre><pre>
          <code class="language-js">
class Bmw {   // конструктор
  constructor(model, price, maxSpeed) {
    this.model = model
    this.price = price
    this.maxSpeed = maxSpeed
  }
}

class BmwFactory {   // фабрика
  create(type) {
    if (type === 'X5')
      return new Bmw(type, 108000, 300)
    if (type === 'X6')
      return new Bmw(type, 111000, 320)
  }
}

const factory = new BmwFactory()

const x5 = factory.create('X5')
          </code>
        </pre><hr><pre>
<b id="abstract-factory">abstract factory (абстрактная фабрика)</b>   - класс-фабрика, групирующая другие фабрики
                                           (подфабрики), которые связаны друг с другом.
                                             По сути абстрактная фабрика - надстройка над
                                           другими фабриками.
        </pre><pre>
          <code class="language-js">
// абстрактная фабрика
function bmwProducer(kind) { // производит спорткары или семейные авто
  return kind === 'sport' ? sportCarFactory : familyCarFactory
}

// подфабрики
function sportCarFactory() {
  return new Z4()
}
function familyCarFactory() {
  return new I3()
}

// непосредственное производство авто
class Z4 {
  info() {
    return 'Z4 is a Sport car!'
  }
}
class I3 {
  info() {
    return 'i3 is a Family car!'
  }
}


const produce = bmwProducer('sport')
const myCar = new produce()
console.log(myCar.info()) // Z4 is a Sport car!
          </code>
        </pre><hr><pre>
<b id="prototype">prototype</b>   - создание копий объектов, которые могут понадобиться чтобы в случае
              необходимости изменить их структуру. Копирование удобней
        </pre><pre>
          <code class="language-js">
class TeslaCar {
  constructor(model, price, interior, autopilot) {
    this.model = model
    this.price = price
    this.interior = interior
    this.autopilot = autopilot
  }

  produce() {  // клонирует созданный экземпляр
    return new TeslaCar(this.model, this.price, this.interior, this.autopilot)
  }
}

const prototypeCar = new TeslaCar('S', 80000, 'black', false)

// produce удобней, чем передавать одинаковые аргументы каждый раз для создания авто
const car1 = prototypeCar.produce()
const car2 = prototypeCar.produce()

// changes for particular auto
car1.interior = 'white'
car1.autopilot = true
          </code>
        </pre><hr><pre>
<b id="builder">builder</b>   - что бы конструктор класса сильно не разросся используется паттерн builder,
            который позволяет создавать сложные объекты, инициализацию которых проблематично
            уместить в конструкторе.
              Может иметь дополнительный слой абстракции Director, который управляет
            несколькими builder'ми
        </pre><pre>
          <code class="language-js">
class Car {
  constructor() {
    this.autoPilot = false
    this.parktronic = false
    this.signaling = false
  }
}

class CarBuilder { // билдер для удобного создания объектов
  constructor() {
    this.car = new Car()   // создаем авто базовой комплектации
  }
  addAutoPilot(autoPilot) {
    this.car.autoPilot = autoPilot
    return this
  }
  addParktronic(parktronic) {
    this.car.parktronic = parktronic
    return this
  }
  addSignaling(signaling) {
    this.car.signaling = signaling
    return this
  }
  updateEngine(engine) {
    this.car.engine = engine
    return this
  }
  build() {
    return this.car
  }
}

const myCar = new CarBuilder()
                .addAutoPilot(true)
                .addParktronic(true)
                .addSignaling('V8')
                .build()
          </code>
        </pre><pre>


        <b class="center">STRUCTURAL PATTERNS:</b>

<b id="decorator">decorator</b>   - позволяет добавлять объектам новые свойства и методы,
              т.е. оборачивать объект в класс декоратора
        </pre><pre>
          <code class="language-js">
class Car {
  constructor() {
    this.price = 10000
    this.model = 'Car'
  }

  getPrice() {
    return this.price
  }

  getDescription() {
    return this.model
  }
}

class Tesla extends Car {
  constructor() {
    super();
    this.price = 25000
    this.model = 'Tesla'
  }
}

class Autopilot {   // декоратор, добавляет автопилот
  constructor(car) {
    this.car = car
  }

  getPrice() {
    return this.car.getPrice() + 5000
  }

  getDescription() {
    return `${this.car.getDescription()} with autopilot`
  }
}

let tesla = new Tesla()
tesla = new Autopilot(tesla)
console.log( tesla.getPrice() )    // 30000
          </code>
        </pre><hr><pre>
<b id="facade">facade (фасад)</b>   - скрывает объемную/сложную логику за простым фасадом.
                   Собирает различные сложные структуры, объединяет их
                   и выдает простой способ взаимодействия
        </pre><pre>
          <code class="language-js">
class Сonveyor {
  setBody() {
    console.log('Body set!')
  }
  getEngine() {
    console.log('Dismantle Engine!')
  }
  setEngine() {
  	console.log('Engine set!')
  }
  setWheels() {
  	console.log('Wheels!')
  }
  addElectronics() {
  	console.log('Added electronics!')
  }
  paint() {
  	console.log('Car painted!')
  }
}

class СonveyorFacade {
  constructor(car) {
    this.car = car
  }

  assembleCar() {        // фасад, для сборки
    this.car.setBody()
    this.car.setEngine()
    this.car.setWheels()
    this.car.addElectronics()
    this.car.paint()
  }

  changeEngine() {       // фасад, для замены
    this.car.getEngine()
    this.car.setEngine()
  }
}
          </code>
        </pre><hr><pre>
<b id="proxy">proxy (заместиитель)</b>   - вместо реальных объектов предоставляет объекты-заменители.
                         Эти объекты перехватывают вызовы к оригиналам и позволяют
                         что то сделать до или после обращения к оригинальному объету.
                           Объект-заменитель (заместиитель) должен реализовывать такой же
                         интерфейс (такие же названия методов), как и оригинальный объект.
                           Т.е. это прослойка, которая позволяет произвести дополнительные
                         манипуляций до того, как отдать дальнейший контроль.
                         Пример: - авторизация на сайте, и в зависимости от статуса появляется
                                   или полный доступ или частичный, или полностью закрыт
                                 - логирующий proxy - хранение истории обращения
                                 - кэширующий proxy - частичное кеширование результатов
                                                      запросов клиента и управление ними
                                 - защищающий proxy (пример ниже)
        </pre><pre>
          <code class="language-js">
class CarAccess {
	open() {
		console.log('Opening car door')
	}

	close() {
		console.log('Closing the car door')
	}
}

// proxy-класс  - охранная система (голосовой валидатор) для безопасного открытия дверей
class SecuritySystem {  // заместитель с тем же интерфейсом (open и close) что и оригинал
  constructor(door) {
    this.door = door
  }

  open(password) {
    if (this.authenticate(password)) {
      this.door.open()
    } else {
      console.log('Access denied!')
    }
  }

  authenticate(password) {
    return password === 'Ilon'
  }

  close() {
    this.door.close()
  }
}

const door = new SecuritySystem(new CarAccess())
door.open('Jack')   // Access denied!
door.open('Ilon')   // Opening car door
door.close()        // Closing the car door
          </code>
        </pre><hr><pre>
<b id="adapter">adapter</b>   - оборачивает несовместимый с чем то объект и делает его совместимым,
            не изменяя исходный код объекта
        </pre><pre>
          <code class="language-js">
class Engine2 {
  simpleInterface() { console.log('Engine 2.0 - tr-tr-tr') }
}

class EngineV8 {
  complecatedInterface() { console.log('Engine V8! - wroom wroom!') }
}

class EngineV8Adapter {
  constructor(engine) {
    this.engine = engine
  }

  simpleInterface() {  // адаптируем - делаем совместимый метод из несовместимого
    this.engine.complecatedInterface()
  }
}

class Auto {
  startEngine(engine) {  // знает только simpleInterface метод двигателя
    engine.simpleInterface()
  }
}
          </code>
        </pre><hr><pre>
<b id="composite">composite (компановщик)</b>   - позволяет сгруппировать множество объектов в древовидную
                            структуру и работать с этой структурой так, как будто это
                            один единственный объект
        </pre><pre>
          <code class="language-js">
class Equipment {
  getPrice() {
    return this.price || 0
  }

  getName() {
    return this.name
  }

  setName(name) {
    this.name = name
  }

  setPrice(price) {
    this.price = price
  }
}

class Engine extends Equipment {
  constructor() {
    super()
    this.setName('Engine')
    this.setPrice(800)
  }
}

class Body extends Equipment {
  constructor() {
    super()
    this.setName('Body')
    this.setPrice(3000)
  }
}

class Composite extends Equipment {
  constructor() {
    super()
    this.equipments = []
  }

  add(equipment) {   // добавляет детали авто
    this.equipments.push(equipment)
  }

  getPrice() {    // суммирует цены всех деталей
    return this.equipments
      .map(equipment => equipment.getPrice())
      .reduce((a, b) => a + b)
  }
}

class Car extends Composite {
  constructor() {
    super()
    this.setName('Audi')
  }
}

const myCar = new Car()
myCar.add(new Engine())
myCar.add(new Body())

console.log(`${myCar.getName()} price is ${myCar.getPrice()}`)  // Audi price is 3800
          </code>
        </pre><hr><pre>
<b id="bridge">bridge (мост)</b>   - разделяет один или несколько классов на две отдельные
                  иерархии — абстракцию (обвертка, которая сама не выполняет работу, а
                  делигирует ее объекту реализации) и реализацию, позволяя изменять их
                  независимо друг от друга
        </pre><pre>
          <code class="language-js">
class Model {
  constructor(color) {
    this.color = color
  }
}
// Color - мост, дергающий классы цветов
class Color {   // принимает тип цвета
  constructor(type) {
    this.type = type
  }
  get() {
    return this.type
  }
}

class BlackColor extends Color {
  constructor() {
    super('dark-black')
  }
}

class SilbrigColor extends Color {
  constructor() {
    super('Silbermetallic')
  }
}

// сами модели с цветами не работают, работа делегируется классу Color (метод get)
class Audi extends Model {
  constructor(color) {
    super(color)
  }

  paint() { // связь (мост) между независимыми классами
    return `Auto: Audi, Color: ${this.color.get()}`
  }
}

class Bmw extends Model {
  constructor(color) {
    super(color)
  }

  paint() {
    return `Auto: Bmw, Color: ${this.color.get()}`
  }
}

// что бы не создавать отдельные классы для каждой модели авто
// каждого цвета (классы росли бы в геометрической прогрессия)
const blackBmw = new Bmw(new BlackColor())
          </code>
        </pre><hr><pre>
<b id="flyweight">flyweight (легковес, кэш)</b>   - позволяет вместить большее количество объектов в выделеную
                              оперативную память. Другими словами он позволяет экономить
                              память, разделяя общее состояние объектов между собой, вместо
                              хранения одинаковых данных в каждом объекте, что похоже на
                              кеширование.
                                Например, у нас есть 100 объектов с разной структурой, и в
                              каждом из этих объектов есть общее свойство. Мы можем создать
                              один класс, где собрать все эти повторяющиеся свойства. После
                              чего установить связь между этим и остальныит классами где эти
                              свойства используются. Таким образом мы съэкономим память,
                              необходимую для хранения этих св-в.
                              2 особенности flyweight:
                              - не должно быть возможности менять свойство легковеса
                                после создания (у него не должно быть публичных полей)
                              - создавать легковесы и работать с ними намного удобней
                                с помощью фабрик
        </pre><pre>
          <code class="language-js">
class Auto {  // класс легковеса - то, что будет кешироваться
  constructor(model) {
    this.model = model
  }
}

class AutoFactory {  // вся суть реализации - в фабрике
  constructor(name) {
    this.models = {}
  }

  create(name) {
    let model = this.models[name]
    if (model) return model
    console.count('model')  // для наглядности работы
    this.models[name] = new Auto(name)
    return this.models[name]
  }

  getModels() { // что бы посмотреть заполненый объект
    console.table(this.models)
  }
}

const factory = new AutoFactory()

const bmv = factory.create('BMW')
const audi = factory.create('Audi')
const tesla = factory.create('Tesla')
const blackTesla = factory.create('Tesla')

console.log(factory.getModels())  // 3 раза 'model' и ссылка на уже существующую модель
          </code>
        </pre><pre>


        <b class="center">BEHAVIOUR PATTERNS:</b>

<b id="mediator">mediator (посредник)</b>   - позволяет уменьшить взаимосвязь классов между собой,
                         вынося межклассовые связи в класс-посредник. Благодаря
                         этому намного увеличивается переиспользываемость классов
        </pre><pre>
          <code class="language-js">
class OfficialDealer {  // mediator - посредник между покупателем и производителем
  constructor() {
    this.customers = []
  }

  orderAuto(customer, auto, info) {
    const name = customer.getName()
    console.log(`Order name: ${name}. Order auto is ${auto}`)
    console.log(`Additional info: ${info}`)
    this.addToCustomersList(name)
  }

  addToCustomersList(name) {
    this.customers.push(name)
  }

  getCustomerList() {
    return this.customers
  }
}

class Customer {
  constructor(name, dealerMediator) {
    this.name = name
    this.dealerMediator = dealerMediator
  }

  getName() {
    return this.name
  }

  makeOrder(auto, info) {
    this.dealerMediator.orderAuto(this, auto, info)
  }
}

const mediator = new OfficialDealer()

const yauhen = new Customer('Yauhen', mediator)
const valera = new Customer('Valera', mediator)

yauhen.makeOrder('Tesla', 'With autopilot!')
valera.makeOrder('Audi', 'With parktronik!')

console.log(mediator.addToCustomersList()) // ['Yauhen', 'Valera']
          </code>
        </pre><hr><pre>
<b id="iterator">iterator</b>   - умный перебор коллекции без раскрытия внутреннего представление
             элементов, т.е без возможности повлиять на эти коллекции
        </pre><pre>
          <code class="language-js">
class ArrayIterator {
  constructor(el) {
    this.index = 0
    this.elements = el
  }

  next() {
    return this.elements[this.index++]
  }

  hasNext() {
    return this.index &lt; this.elements.length
  }
}

const collection = new ArrayIterator(['Audi', 'BMW', 'Tesla'])
while (collection.hasNext()) {
  console.log(collection.next()) // 'Audi'  'BMW'  'Tesla'
}


class ObjectIterator { // на вход поступает объект
  constructor(el) {
    this.index = 0
    this.keys = Object.keys(el) // сначало формируем массив его ключей
    this.elements = el
  }

  next() {
    return this.elements[this.keys[this.index++]]
  }

  hasNext() {
    return this.index &lt; this.keys.length
  }
}

const autos = {
  audi: { model: 'Audi', color: 'black', price: 20000 }
  bmw: { model: 'BMW', color: 'white', price: 30000 }
  tesla: { model: 'Tesla', color: 'grey', price: 40000 }
}
const collection = new ObjectIterator(autos)
while (collection.hasNext()) {
  console.log(collection.next())
}
          </code>
        </pre><hr><pre>
<b id="chain-of-responsibility">chain-of-responsibility </b>   - (цепочка обязанностей) позволяет передавать запросы
                             последовательно по цепочке обработчиков. Его особенность
                             в том, что каждый последующий обработчик решает, может ли
                             он сам обработать запрос и вернуть результат, или он может
                             передать его дальше по цепочке.
                               Пример использования: у пользователя подключено несколько
                             систем (карточек) оплаты и при оплате покупки будет попытка
                             оплатить 1й карточкой. Если там не достаточно денег - будет
                             совершена попытка оплаты со 2й и т.д.
        </pre><pre>
          <code class="language-js">
class Account {
  pay(orderPrice) {
    if (this.canPay(orderPrice)) {
      console.log(`Paid ${orderPrice} using ${this.name}`)
    } else if (this.incomer) { // если не хватает денег и есть преемник - поручаем оплату ему
      console.log(`Cannot pay using ${this.name}`)
      this.incomer.pay(orderPrice)
    } else {
      console.log('Unfortunately, not enough money')
    }
  }

  canPay(amount) {
    return this.balance >= amount
  }

  setNext(account) { // устанавливает приемника
    this.incomer = account
  }
}

class Master extends Account {
  constructor(balance) {
    super()
    this.name = 'Master Card'
    this.balance = balance
  }
}

class Paypal extends Account {
  constructor(balance) {
    super()
    this.name = 'Paypal'
    this.balance = balance
  }
}

class Qiwi extends Account {
  constructor(balance) {
    super()
    this.name = 'Qiwi'
    this.balance = balance
  }
}

const master = new Master(100)
const paypal = new Paypal(200)
const qiwi = new Qiwi(500)

// define chain
master.setNext(paypal)
paypal.setNext(qiwi)

master.pay(438)
            <!--
            Cannot pay using Master Card
            Cannot pay using Paypal
            Paid 438 using Qiwi
            -->
          </code>
        </pre><hr><pre>
<b id="strategy">strategy</b>   - определяет схожие алгоритмы и помещает их в каждый отдельный класс.
             После чего между этими алгоритмами можно автоматически переключаться
             в ходе выполнения программы.
              Этот паттерн может быть полезен при расширении возможностей приложения,
             чтобы не превратить код в плохочитаемый или сложноподдерживаемый
        </pre><pre>
          <code class="language-js">
function baseStrategy(amount) {
  return amount
}
function premiumStrategy(amount) {
  return amount * 0.85  // скидка
}
function platinumStrategy(amount) {
  return amount * 0.65  // скидка
}

class AutoCart {    // класс-контекст
  constructor(discount) {
    this.discount = discount
    this.amount = 0
  }

  checkout() {
    return this.discount(this.amount)
  }

  setAmount(amount) {
    this.amount = amount
  }
}

const baseCustomer = new AutoCart(baseStrategy)
const premiumCustomer = new AutoCart(premiumStrategy)
const platinumCustomer = new AutoCart(platinumStrategy)

baseCustomer.setAmount(50000)
console.log(baseCustomer.checkout()) // 50000

premiumCustomer.setAmount(50000)
console.log(premiumCustomer.checkout()) // 42500

platinumCustomer.setAmount(50000)
console.log(platinumCustomer.checkout()) // 32500
          </code>
        </pre><hr><pre>
<b id="memento">memento (снимок)</b>   - позволяет сохранять и восстанавливать предыдущее состояние объекта.
                     Пример: редактор кода с шагом назад (ctrl + z).
        </pre><pre>
          <code class="language-js">
class Memento {   // объект-хранитель
  constructor(value) {
    this.value = value
  }
}

const creator = {   // создание и восстановление снимков
  save: val => new Memento(val),
  restore: memento => memento.value   // memento - объект с полем value
}

class Caretaker {   // хранитель снимков
  constructor() {
    this.values = []
  }

  addMemento(memento) {
    this.values.push(memento)
  }

  getMemento(index) {
    return this.values[index]
  }
}

const caretaker = new Caretaker()

caretaker.addMemento(creator.save('hello'))  // сохраняем в values объект с полем value
caretaker.addMemento(creator.save('hello world'))
caretaker.addMemento(creator.save('hello world !!!'))

console.log(creator.restore(caretaker.getMemento(1)))  // hello world
          </code>
        </pre><hr><pre>
<b id="template-method">template-method (шаблон)</b>   - определяет базовые шаги исполнения алгоритма и выплнение каждого
                             из этих шагов делегирует на соответствующие методы или подклассы
        </pre><pre>
          <code class="language-js">
class Builder {   // базовый класс, определяющий поряд выполнения операций
  build() {
    this.addEngine()
    this.installChassis()
    this.addElectronic()
    this.collectAccessories()
  }
}

class TeslaBuilder extends Builder {
  addEngine() {
    console.log('Add Electronic Engine')
  }

  installChassis() {
    console.log('Install Tesla chassis')
  }

  addElectronic() {
    console.log('Add special electronic')
  }

  collectAccessories() {
    console.log('Collect Accessories')
  }
}

class BmwBuilder extends Builder {
  addEngine() {
    console.log('Add BMW Engine')
  }

  installChassis() {
    console.log('Install BMW chassis')
  }

  addElectronic() {
    console.log('Add electronic')
  }

  collectAccessories() {
    console.log('Collect Accessories')
  }
}

const teslaBuilder = new TeslaBuilder()
const bmwBuilder = new BmwBuilder()

teslaBuilder.build()
bmwBuilder.build()
          </code>
        </pre><hr><pre>
<b id="visitor">visitor (посетитель)</b>   - добавляет новую функциональность к уже существующим классам,
                         не изменяя исходный код класса
        </pre><pre>
          <code class="language-js">
class Auto {
  accept(visitor) {
    visitor(this)  // передает посетителю контекст вызова класса
  }
}

class Tesla extends Auto {
  info() {
    return 'It is a Tesla car!'
  }
}

class Bmw extends Auto {
  info() {
    return 'It is a BMW car!'
  }
}

class Audi extends Auto {
  info() {
    return 'It is an Audi car!'
  }
}

function exportVisitor(auto) {   // посетитель, добавляет метод export для экспорта данных
  if (auto instanceof Tesla)
    auto.export = console.log(`Exported data: ${auto.info()}`)
  if (auto instanceof Bmw)
    auto.export = console.log(`Exported data: ${auto.info()}`)
  if (auto instanceof Audi)
    auto.export = console.log(`Exported data: ${auto.info()}`)
}

const tesla = new Tesla()
const bmw = new Bmw()

console.log(tesla.accept(exportVisitor))  // Exported data: It is a Tesla car!
          </code>
        </pre><hr><pre>
<b id="command">command (команда)</b>   - помогает инкапсулировать некоторые действия и необходимые для них
                      данные и таким образом позволяет отделить клиента (водителя) от
                      получателя (движок)
        </pre><pre>
          <code class="language-js">
class Driver {
  constructor(command) {
    this.command = command
  }

  execute() {  // 1. водитель, знает о командах
    this.command.execute()
  }
}

class Engine {  // 3. бизнес логика
  constructor() {
    this.state = false  // по умолчанию двигатель выключен
  }

  on() {
    this.state = true
  }

  off() {
    this.state = false
  }
}

// вынесли отдельно команды из Engine
class OnStartCommand {  // ключ для заведения двигателя
  constructor(engine) {
    this.engine = engine
  }

  execute() {  // 2. комманда знает о бизнес логике
    this.engine.on()
  }
}
class onSwitchOffCommand {  // ключ для остановки двигателя
  constructor(engine) {
    this.engine = engine
  }

  execute() {  // 2. комманда знает о бизнес логике
    this.engine.off()
  }
}
          </code>
        </pre><hr><pre>
<b id="observer">observer (наблюдатель)</b>   - создает механизм подписки, позволяющий одним объектам
                           следить за изменениями других объектов.
                             С ростом приложения может понадобится хранить данные от которых
                           зависит несколько компонентов в одном объекте или классе. Этот класс
                           играет роль хранителя (store). В свою очередь он содержит определенные
                           свойства, от изменения которых зависит логика определенных компонентов.
                           Он соответственно содержит список этих зависящих компонентов, которые
                           называются подписчиками. Так же у этого класса есть методы для
                           изменения наблюдаемых свойств и методы которые оповещают о том, что
                           свойство изменилось и на это нужно отреагировать.
                             Пример: подписка на новости ресурса
        </pre><pre>
          <code class="language-js">
class AutoNews {
  constructor() {
    this.news = ''
    this.actions = []   // массив подписчиков на изменение св-ва news
  }

  setNews(text) {
    this.news = text
    this.notifyAll()
  }

  notifyAll() {
    return this.actions.forEach(subs => subs.inform(this))
  }

  register(observer) {
    this.actions.push(observer)
  }

  unregister(observer) {
    this.actions = this.actions.filter(el => !(el instanceof observer))
  }
}

class Jack {
  inform(message) {
    console.log(`Jack has been informed about: ${message.news}`)
  }
}

class Max {
  inform(message) {
    console.log(`Max has been informed about: ${message.news}`)
  }
}

const autoNews = new AutoNews()

autoNews.register(new Jack())
autoNews.register(new Max())

autoNews.setNews('New Tesla price is 40000')
// Jack has been informed about: New Tesla price is 40000
// Max has been informed about: New Tesla price is 40000
          </code>
        </pre><hr><pre>
<b id="state">state (состояние)</b>   - позволяет объектам менять свое поведение в зависимости от состояния,
                      что со стороны выглядит как будто в работу включился другой класс
        </pre><pre>
          <code class="language-js">
class OrderStatus {
  constructor(name, nextStatus) {
    this.name = name
    this.nextStatus = nextStatus
  }

  next() {
    return new this.nextStatus()
  }
}

class WaitingForPayment extends OrderStatus {
  constructor() {
    super('waitingForPayment', Shipping)
  }
}

class Shipping extends OrderStatus {
  constructor() {
    super('shipping', Delivered)
  }
}

class Delivered extends OrderStatus {
  constructor() {
    super('delivered', Delivered)
  }
}

class Order {
  constructor() {
    this.state = new WaitingForPayment()
  }

  nextState() {
    this.state = this.state.next()
  }

  cancelOrder() {
    this.state.name === 'waitingForPayment'
      ? console.log('Order is canceled!')
      : console.log('Order can not be canceled!')
  }
}


const myOrder = new Order()

console.log(myOrder.state.name)  // waitingForPayment
myOrder.cancelOrder()            // Order is canceled!

myOrder.nextState()
console.log(myOrder.state.name)  // shipping
myOrder.cancelOrder()            // Order can not be canceled!
          </code>
        </pre></article><ul class="section-refs"><li><a href="https://github.com/YauhenKavalchuk/design-patterns" target="_blank">design patterns Yauhen Kavalchuk</a></li><li><a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">все паттерны проектирования</a></li></ul></div></section><!--MVC--><section class="section" id="mvc"><div class="section-container"><h2 class="section-title">MVC</h2><article class="section-info"><pre>
  Model-View-Controller - схема разделения данных приложения и управляющей логики на три
отдельных компонента: модель, представление и контроллер — таким образом, что модификация
каждого компонента может осуществляться независимо

<b>Controller</b>   интерпретирует действия пользователя, оповещая модель о необходимости изменений
<b>Model</b>        предоставляет данные и реагирует на команды контроллера, изменяя своё состояние
             (Model должна содержать бизнес-логику)
<b>View</b>         отвечает за отображение данных модели пользователю, реагируя на изменения модели

<img src="images/misc/MVC.png" alt="MVC">

  Классический подход подразумевает отсутствие в Model (содержащей бизнес-логику) вообще
хоть какого-то взаимодействия с View или Controller. Controller должен запрашивать у Model
результат и отдать его View.
  Если вы хотите, чтоб Model взаимодействовала с View, это уже MVVM а не MVC
        </pre><pre>
          <code class="language-js">
const model = {
  number: 0,
  calculate: function (x, y) {
    this.number = x * y
    return this.number
  }
}

const controller = {
  handleCalc: function () {
    const result = model.calculate(2, 6)
    view.showNumber(result)
  }
}

const view = {
  showNumber: function (numb) {
    const $elem = document.querySelector('#showResult')
    $elem.innerHTML = numb
  }
}
          </code>
        </pre></article></div></section><!--SOLID principles--><section class="section" id="solid"><div class="section-container"><h2 class="section-title">SOLID principles</h2><article class="section-info"><b>S (single responsibility)</b><pre>
  Каждый класс должен решать лишь одну задачу. Все ресурсы, необходимые для его
осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче
        </pre><pre>
          <code class="language-js">
class News {  // класс новость должен отвечать только за новость
  constructor(title, text) {
    this.title = title
    this.text = text
    this.modified = false
  }

  update(text) {
    this.text = text
    this.modified = true
  }
}

class NewsPrinter {  // методы для приведения к нужному формату выносим в отдельный класс
  constructor(news) {
    this.news = news
  }

  html() {
    return `
      &lt;div class='news'>
        &lt;h1>${this.news.title}&lt;/h1>
        &lt;p>${this.news.text}&lt;/p>
      &lt;/div>
    `
  }

  json() {
    return JSON.stringify({
      title: this.news.title,
      text: this.news.text,
      modified: this.news.modified
    }, null, 2)
  }

  xml() {
    return `
      &lt;news>
        &lt;title>${this.news.title}&lt;/title>
        &lt;text>${this.news.text}&lt;/text>
      &lt;/news>
    `
  }
}


const printer = new NewsPrinter(
  new News('Байден', 'Лендлиз')
)

console.log(printer.html())
console.log(printer.xml())
console.log(printer.json())
          </code>
        </pre></article><article class="section-info"><b>O (open-closed)</b><pre>
  Программные сущности (классы, функции) должны быть открыты для
расширения, но не для модификации
        </pre><pre>
          <code class="language-js">
class Shape {
  area() {  // если у фигур не задан метод area для вычисления площади, будет выброшена ошибка
    throw new Error('area method should be implemented')
  }
}

class Square extends Shape {
  constructor(size) {
    super()
    this.size = size
  }

  // вычисление площади должно быть в классе фигуры, что бы при добавлении новых
  // фигур не делать новые проверки в методе sum и не вычислять площадь в нем
  area() {
    return this.size ** 2
  }
}

class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  area() {
    return (this.radius ** 2) * Math.PI
  }
}

class Triangle extends Shape {
  constructor(a, b) {
    super()
    this.a = a
    this.b = b
  }

  area() {
    return (this.a * this.b) / 2
  }
}

// AreaCalculator открыт для расширений (можно добавлять новые фигуры
// для просчета площади), но закрыт для модификации (не модифицируем sum)
class AreaCalculator {
  constructor(shapes = []) {
    this.shapes = shapes
  }

  sum() {
    return this.shapes.reduce((acc, shape) => {
      acc += shape.area()
      return acc
    }, 0)
  }
}


const calc = new AreaCalculator([
  new Square(10),
  new Circle(1),
  new Circle(5),
  new Triangle(10, 15)
])

console.log(calc.sum())
          </code>
        </pre></article><article class="section-info"><b>L (Liskov substitution)</b><pre>

  Наследующий класс должен дополнять, а не замещать поведение базового класса.
Цель принципа заключаются в том, чтобы классы-наследники могли бы использоваться
вместо родительских классов
        </pre><pre>
          <code class="language-js">
👎Bad:

class Rectangle {
  constructor(width, height) {}

  setWidth(width) {
    this.width = width
  }

  setHeight(height) {
    this.height = height
  }

  areaOf() {
    return this.width * this.height
  }
}

class Square extends Rectangle {
  width = 0
  height = 0

  constructor(size) {
    super(size, size)
  }

  setWidth(width) {
    this.width = width
    this.height = width
  }

  setHeight(height) {
    this.width = height
    this.height = height
  }
}


👍Good:

interface Figure {
	setWidth(width: number): void;
	setHeight(height: number): void;
	areaOf(): void;
}

class Rectangle implements Figure {
	setWidth(width: number) { }
	setHeight(height: number) { }
	areaOf() { }
}

class Square implements Figure {
	setWidth(width: number) { }
	setHeight(height: number) { }
	areaOf() { }
}
          </code>
        </pre></article><article class="section-info"><b>I (interface segregation)</b><pre>
  Много интерфейсов, специально предназначенных для клиентов, лучше,
чем один интерфейс общего назначения
        </pre><pre>
          <code class="language-js">
👎Bad:

class Animal {
  constructor(name) {
    this.name = name
  }

  walk() {
    console.log(`${this.name} умеет ходить`)
  }

  swim() {
    console.log(`${this.name} умеет плавать`)
  }

  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

class Dog extends Animal {
  fly() {
    return null   // убираем ненужный функционал (это плохо)
  }
}

class Eagle extends Animal {
  swim() {
    return null
  }
}

class Whale extends Animal {
  fly() {
    return null
  }

  walk() {
    return null
  }
}


👍Good:

class Animal {
  constructor(name) {
    this.name = name
  }
}

const swimmer = {
  swim() {
    console.log(`${this.name} умеет плавать`)
  }
}

const flier = {
  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

const walker = {
  walk() {
    console.log(`${this.name} умеет ходить`)
  }
}

class Dog extends Animal {}
class Eagle extends Animal {}
class Whale extends Animal {}

Object.assign(Dog.prototype, swimmer, walker)  // добавляем только нужные способности
Object.assign(Eagle.prototype, flier, walker)
Object.assign(Whale.prototype, swimmer)
          </code>
        </pre></article><article class="section-info"><b>D (dependency inversion)</b><pre>
  Модули высших уровней не должны зависить от модулей низких уровней. Оба должны
зависеть от абстракций.
  Абстракции должны зависеть от деталей. Детали должны зависеть от абстракций

Итого: верхнеуровневые сущности не должны зависеть от нижнеуровневых реализаций,
       а любые зависимости лучше выносить в абстракции, т.е. инкапсулировать в
       отдельных сущностях
        </pre><pre>
          <code class="language-js">
class Fetch {
  request(url) {
    return Promise.resolve('data from fetch')
  }
}

class LocalStorage {
  get() {
    return 'data from local storage'
  }
}

class FetchClient {  // абстракция с универсальным методом
  constructor() {
    this.fetch = new Fetch()
  }

  clientGet() {
    return this.fetch.request('test.com')
  }
}

class LocalStorageClient {  // абстракция с универсальным методом
  constructor() {
    this.localStorage = new LocalStorage()
  }

  clientGet(key) {
    return this.localStorage.get(key)
  }
}

// база данных не зависит от вида приходящих данных (Fetch или LocalStorage), т.е. не нужно
// менять класс Database, если вместо данных из Fetch нужно получать данные из LocalStorage
class Database {
  constructor(client) {
    this.client = client
  }

  getData(key) {
    return this.client.clientGet(key)
  }
}


const db = new Database(new LocalStorageClient())

console.log(db.getData('rand'))
          </code>
        </pre></article><ul class="section-refs"><li><a href="https://github.com/YauhenKavalchuk/useful/blob/main/solid.md" target="_blank">SOLID - bad/good examples</a></li></ul></div></section><!--DRY / KISS / YAGNI--><section class="section" id="other_js_principles"><div class="section-container"><h2 class="section-title">DRY / KISS / YAGNI</h2><article class="section-info"><pre>
<b>DRY</b>        - don’t repeat yourself

<b>KISS</b>       - keep it simple, stupid

<b>YAGNI</b>      - you aren't gonna need it    (отказ добавления функциональности, в
                                          которой нет непосредственной надобности)
        </pre></article></div></section></main><script src="https://unpkg.com/scrollnav@3.0.1/dist/scrollnav.min.umd.js"></script><script src="index.js"></script></body></html>
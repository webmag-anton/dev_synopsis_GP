<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>JS Browser</title><link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="index.css"></head><body data-name="js_browser"><main class="sections-wrapper"><!--Browser Engines--><section class="section" id="browser-engines"><div class="section-container"><h2 class="section-title">Browser Engines</h2><article class="section-info"><pre>
  <b>в браузере 2 движка:</b>

движок браузера  - (например Blink) для преобразования содержимого веб-страниц (файлы
                   HTML, XML, картинки...) и информации о форматировании (в форматах CSS,
                   XSL...) в изображение на экране. Движок браузера запускает JS движок
JS движок        - (например V8) для компиляции js в машинный код


  Компьютер не работает напрямую c js (не понимает js). Для работы компу нужен машинный
код (machine code runs on the CPU). Таким образом браузер, например Chrome (под капотом V8),
с помощью JS движка компилирует js в машинный код.

  V8 — самый популярный JS движок (стоит во всех Cromium подобных браузерах). V8 также
стоит в Node.js
  JavaScriptCore (SquirrelFish) — JS движок для Safari
  SpiderMonkey — JS движок для Firefox

  WebKit (Apple), Blink (Google, fork of WebKit), Gecko (Mozilla) — движки браузеров для
отображения веб-страниц. Эти движки управляют макетом сайта, а также включают движок JS,
который интерпретирует и компилирует JS код. Самый популярный из этих JS движков - V8;
он поддерживает не только браузер Chrome. V8 также поддерживает JS фреймворк Electron
(разработан GitHub), который позволяет создавать десктопные приложения.
        </pre></article></div></section><!-- chrome devtools --><section class="section" id="chrome_devtools"><div class="section-container"><h2 class="section-title">chrome devtools</h2><article class="section-info"><pre>
        <b>вкладка Network</b>:

- вес переданных данных указывается во вкладке resources снизу:
  4.1 MB transferred

- время загрузки:
  Finish: 12.08 s (по идее, Finish учитывает async скрипты, а Load нет)

- Time = такой сумме времен из tooltip'a Waterfall:
  Stalled (время остановки по какой то причине)
  +
  Request sent (время запроса)
  +
  Waiting (TTFB) (время до получения первого байта)
  +
  Content Download (время загрузки)

  Queueing из tooltip'a Waterfall показывает прошедшее от
  начала загрузки страницы время, после которого начался запрос
        </pre></article></div></section><!--Critical Rendering Path--><section class="section" id="critical-rendering-path"><div class="section-container"><h2 class="section-title">Critical Rendering Path</h2><article class="section-info"><pre>
  Критические этапы рендеринга (Critical Rendering Path) - это последовательность шагов,
которые выполняет браузер, когда преобразуется HTML, CSS и JavaScript в пиксели, которые
вы видите на экране

  Браузер загружает и отображает страницу постепенно по мере выполнения <b>Critical Rendering Path:</b>
DOM + CSSOM = render tree -> layout (flow) -> render (paint)

  <b>Чтобы нарисовать на экране результат работы нашего кода,
браузеру нужно выполнить несколько этапов:</b>
- Сперва ему нужно скачать исходники (fetching)
- Затем их нужно прочитать (parsing)
- После этого браузер приступает к отрисовке (rendering)


      <b>parsing:</b>

  Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких
абстракций, результат парсинга HTML-кода, называется DOM. DOM — это дерево (корень — HTML)

  Пока браузер парсит документ и строит DOM, он натыкается на элементы типа img, link,
script, которые содержат ссылки на другие ресурсы

  Если ресурс неблокирующий (изображение), браузер запрашивает его параллельно с парсингом
оставшейся части документа

  Т.к. картинки не блокируют рендеринг страницы, они могут рендериться после отрисовки
документа => для них нужно предусмотреть placeholder

  <b>Блокирующие ресурсы (скрипты, стили, шрифты)</b> приостанавливают обработку до своей
полной загрузки, а для js - до загрузки и до выполнения

  Когда браузер находит элемент link, который указывает на файл стилей, браузер скачивает
и парсит его. Результат парсинга CSS-кода — CSSOM

  Благодаря оптимизациям (например, сканеру предзагрузки) <b>стили</b> могут не блокировать чтение
HTML, но они точно <b>блокируют выполнение JavaScript</b>, потому что в JS могут использоваться
CSS-селекторы для выборки элементов
        </pre><img src="images/js_browser/browser-parsing-scheme.webp" alt="browser-parsing-scheme"><pre>

  После того как у браузера появилось Render Tree, он начинает «расставлять» элементы на
странице. Этот процесс называется Layout (flow)


      <b>rendering (paint):</b>

   Во время отрисовки браузер наполняет пиксели на экране нужными цветами в зависимости от
того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени,
рамки и т.д.


   <b>Что влияет на CRP?</b>

<b>HTML-код:</b>      невозможно отобразить веб-страницу без полной загрузки HTML и построения
               объектной модели документа (DOM). Отрисовка страницы может начаться только
               после полной загрузки HTML.
<b>CSS:</b>           имеет свою собственную объектную модель, CSSOM, которая также должна
               быть создана и применена к DOM. Процесс построения CSSOM блокирует процесс
               отрисовки.
<b>Шрифты:</b>        загрузка всех подключаемых шрифтов страницы, на которые имеются ссылки
               в DOM/CSSOM, также блокирует парсинг => рендеринг.
<b>JavaScript:</b>    взаимодействуя как с HTML, так и с CSS, JavaScript потенциально является
               наиболее “разрушительным” компонентом, влияющим на CRP. Пока JavaScript
               загружается и выполняется, браузеры прекращают парсинг => рендеринг, если
               не предпринимаются дополнительные шаги. В результате выполнения JS может
               быть изменен DOM/CSSOM, что влечет за собой повторение всех шагов CRP сначала.


  Изображения представляют собой простое содержимое и не оказывают никакого
влияния на рендеринг


* CSS блокирует рендеринг, а также выполнение JavaScript, но не блокирует парсинг

* JavaScript блокирует парсинг, потому что он блокирует построение DOM, когда мы
  сталкиваемся с тегом script. Но если скрипт с defer (выполняется после парсинга
  документа), то ни загрузка ни выполнение скрипта не повлияют на парсинг html-документа
  и следовательно на рендеринг.
  Некоторые скрипты не изменяют DOM или CSSOM и не должны блокировать рендеринг. Для них
  лучше использовать async, чтобы они не блокировали построение DOM и не блокировались CSSOM'ом

* есть кроссбраузерный хак для внешнего стиля, чтобы его загрузка не блокировала
  рендеринг (стиль применится только после загрузки):
  &lt;link rel='stylesheet' href='./style.css' media='print' onload='this.media="all"'>
    Суть подхода в том, что бы разделить стили на критичные (для стилизации первого экрана)
  и не кретичные (не влияющие на первый экран). Не кретичные стили нужно загружать этим
  хаком, а критичные инлайново
        </pre></article><article class="section-info"><b>оптимизация загрузки 1го экрана (above-the-fold - над сгибом)</b><pre>
  Контент (все компоненты, входящие в CRP) загружается браузером отдельными «фрагментами».
Каждый фрагмент сайта состоит из пакета данных размером до 14 KB, что в результате ведет к
более быстрой загрузке веб-страницы размером 14 KB или меньше (каждый пакет TCP может быть
до 14 KB). Для страницы 15 KB потребуются уже два фрагмента.

  В CRP должны быть включены только коды/ресурсы, необходимые для визуализации первого
экрана (Above The Fold).

  Нужно поместить критически важные компоненты (части HTML/CSS/JS/шрифты, которые имеют
решающее значение для отрисовки содержимого в одном экране) в первые 14 КБ. А оставшееся
содержимое загружать асинхронно, либо переместить ниже в коде.
        </pre></article><article class="section-info"><b>conclusion, web performance optimizations:</b><pre>
<b>html:</b>
   - минифицировать html-документ
<b>css:</b>
   - минифицировать css
   - разделить стили на критичные (для стилизации первого экрана)
     и не кретичные (не влияющие на первый экран). Не кретичные
     стили нужно загружать с помощью media='print', а критичные -
     прописывать инлайново в html
<b>fonts:</b>
   - использовать fallback шрифт (sans-serif...), который отобразит
     текст до подгрузки основного кастомного шрифта
<b>images:</b>
   - минифицировать, использовать webp, svg, по возможности
     перегнать в base-64 для экономии числа запросов
   - лучше предусмотреть placeholder для картинок, что бы
     не было скачков в момент их отрисовки
<b>js:</b>
   - минифицировать
   - чтобы не блокировать парсинг html - добавить скрипт перед
     закрывающим тегом body + добавить defer (если взаимодействует
     с DOM) или async (если не взаимодействует с DOM)
<b>other:</b>
   - use HTTP/2 on your server (or CDN)
   - lazy loading parts of your application outside the viewport,
     for example, by using the loading attribute on the img and
     iframe elements. If you do, have a backup plan for SEO (e.g
     render full page for bot traffic)
   - using resource hints such as:
     rel=preconnect, rel=dns-prefetch, rel=prefetch, rel=preload
       </pre></article><ul class="section-refs"><li><a href="https://dev.to/coderedjack/critical-rendering-path-web-performance-23ij" target="_blank">Critical Rendering Path</a></li><li><a href="https://doka.guide/js/how-the-browser-creates-pages/#poluchenie-resursov-fetching" target="_blank">Critical Rendering Path 2</a></li><li><a href="https://blog.clickio.com/ru/kak-optimizirovat-critical-rendering-path/" target="_blank">CRP optimization</a></li><li><a href="https://3perf.com/talks/web-perf-101/" target="_blank">a comprehencive guide into modern loading performance</a></li><li><a href="https://habr.com/ru/post/445264/" target="_blank">preload · prefetch · preconnect · dns-prefetch · prerender</a></li><li><a href="https://developer.mozilla.org/ru/docs/Web/Performance/Lazy_loading" target="_blank">lazy loading</a></li></ul></div></section><!--Window / Web APIs--><section class="section" id="window / web-apis"><div class="section-container"><h2 class="section-title">Window / Web APIs</h2><article class="section-info"><pre>
  Для JS на стороне клиента существует множество Web APIs, которые <b>не являются частью языка</b>.
  <b>Web APIs</b> - это различные API предоставляемые браузером и используемые в нашем JS-коде
для выполнения различных действий.
  Пример Web API: DOM API для манипуляции с DOM, Fetch API для сетевых запросов, IndexedDB API,
Canvas API, Intersection Observer API, Blob...


  * объект Windows создается автоматически для каждого окна браузера

  Окружение предоставляет свои объекты и дополнительные функции, в дополнение
базовым языковым.
  На схеме в общих чертах показана часть того, что доступно для JS в браузерном окружении:

                                      window (globalThis)

               /                              |                               \
              DOM                            BOM                            JavaScript

document (window.document             navigator (window.navigator)       Object (window.Object)
- экземпляр класса HTMLDocument)      screen                             Array
...                                   location                           Function
                                      frames                             Error
                                      history                            ...
                                      console
                                      XMLHttpRequest
        </pre><img class="img-window" src="images/js_browser/window.jpg" alt="window"> * window.document.location === window.location</article><ul class="section-refs"><li><a href="http://xn--80adth0aefm3i.xn--j1amh/window" target="_blank">Window</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank">Web APIs</a></li></ul></div></section><!--asynchrony / event loop--><section class="section" id="asynchrony"><div class="section-container"><h2 class="section-title">асинхронность / event loop</h2><article class="section-info"><pre>
  JavaScript работает в <b>однопоточном</b> режиме (один стек вызовов), т.е.
только одна операция может быть выполнена в определенный момент времени.

  * Для многопоточности нужно использовать <b>Web Workers</b> - механизм, который
позволяет скрипту выполняться в фоновом потоке, который отделен от основного потока
веб-приложения. Преимущество заключается в том, что ресурсоёмкие вычисления могут
выполняться в отдельном потоке, позволяя запустить основной (обычно пользовательский)
поток без блокировки и замедления.

синхронное выполнение кода — следующая операция не выполняется до завершения
                             предыдущей (например, пока не закроется alert).
                             Или допустим у нас есть 2 строки кода: строка 2
                             не может запуститься до тех пор, пока строка 1 не
                             закончит своё выполнение

<b>call stack</b> — структура данных в JS, которая в основном записывает, где
             мы находимся в программе. Если мы переходим в функцию, мы помещаем ее
             на вершину стека. Если мы возвращаемся из функции, мы убирает ее из
             верхней части стека. Каждая запись в стеке вызовов называется кадром
             стека (<b>stack trace</b>; console.trace() - выведет все кадры стека).
             * За обработку call stack отвечает JS движок


  Когда движок начнет выполнять этот код, стек вызовов будет пуст:

function multiply(x, y) {
  return x * y
  console.trace()  // выведет текущий call stack
}
function printSquare(x) {
  var s = multiply(x, x)
  console.log(s)
}
printSquare(4)
                                              call stack:
    step 1      ->      step 2      ->      step 3      ->      step 4      ->   step 5
                                                                                 (empty stack)
                    multiply(x, x)      console.log(s)
printSquare(4)      printSquare(4)      printSquare(4)      printSquare(4)



                                <b>Event Loop:</b>

* механизм Event Loop, реализующий неблокирующую модель ввода и вывода callback'ов
  в очередь, не является частью js, а относится к браузерному JS движку (V8), который
  компилирует js в машинный код.
    Не смотря на то что и в браузере и в NodeJS движок V8, Event Loop в браузере и
  в NodeJS работают по разному, хоть и решают одну задачу.

  Работа Event Loop в браузере:

  1. когда интерпритатор доходит до асинхронной функции, относящейся
к <b>web api</b> (манипуляции с DOM (рендеринг чего либо), addEventListener, fetch,
setTimeout, postMessage...), он пропускает ее и идет дальше, а эта функция начинает
выполняться браузером
  2. когда функция из web api готова (прошло время setTimeout, зарегистрировался
слушатель...), она попадает в очередь <b>callback queue (macrotask queue)</b>
  3. после выполнения синхронного кода, колбэки из callback queue по очереди,
по которой попали в callback queue, попадают в call stack и исполняются


* колбэк из setTimeout с заданым временем выполнится через >= этого время, т.к.
  колбэки из очереди попадают в call stack только когда тот пуст; (в call stack может
  выполняться затратная операция на момент истечения времени заданого в setTimeout)

* если нужно выполнять функцию, время выполнения которой существенно, строго
  через определенное время после выполнения предыдущей, то лучше вместо setInterval
  использовать <b>вложенный setTimeout</b>. Т.к. setInterval начнет отсчет сразу после
  запуска колбэка не дожидаясь его выполнения. Пример:
  setTimeout(cb = () => {
    // some actions
    setTimeout(cb, 200)
  }, 200)

* <b>рендеринг изменений в браузере происходит только после выполнения ф-ии, а не в процессе</b>,
  т.к. рендеринг чего либо - это манипуляции с DOM => задача из callback queue.
    Если ф-я тяжелая, то пока ее выполнение не завершится мы не увидим результат на экране
  => что бы браузер рендерил каждое изменение на экране, нужно разбить тяжелую ф-ю на
  множество легких с помощью setTimeout;
  это касается не только отрисовки, но и впринципе event loop - <b>пока в call stack
  выполняется тяжелая ф-я, интерфейс браузера заблокирован</b> - не будут выполняться
  обработчики событий и прочие колбэки из callback queue. <b>Поэтому тяжелые задачи лучше
  разбивать на части с помощью setTimeout</b>



                            <b>макро и микро задачи:</b>

  Существуют макро и микро задачи и соответственно <b>macrotask queue (callback queue)
и microtask queue (promise jobs)</b>

<b>Макрозадачи приходят из web api, а микрозадачи - только из js кода!</b>

<b>Макрозадачи</b>: загрузка внешнего скрипта, манипуляции с DOM (изменение контента,
             узлов...), fetch, обработка событий, setTimeout, setInterval, postMessage...
<b>Микрозадачи</b>: обработчики промисов, async/await и MutationObserver

* <b>сразу после выполнения каждой макрозадачи движок исполняет все задачи из очереди
  микрозадач c отрисовкой изменений (если они есть) после выполнения всех микрозадач</b>
  перед тем, как выполнить следующую макрозадачу.
  У микрозадач приоритет над макрозадачами, они выполняются как можно быстрее!

* чтобы добавить в очередь новую макрозадачу используется setTimeout(func) с нулевой
  задержкой;
  для добавления в очередь новой микрозадачи применяется ф-ия <b>queueMicrotask(func)</b>
  или резолвится промис: Promise.resolve().then(func)


<b>requestIdleCallback(func)</b> - ставит в очередь функцию, которая будет вызываться
                            во время периодов простоя браузера - когда event loop
                            в режиме ожидания. Возвращает id, который может быть
                            использован для отмены: cancelIdleCallback(id)
          </pre><pre>

  <b>пример 1:</b>
            <code class="language-js">
console.log('script start')

const interval = setInterval(() => {
  console.log('setInterval')
}, 0)

setTimeout(() => {
  console.log('setTimeout 1')

  Promise.resolve()
    .then(() => console.log('promise 3'))
    .then(() => console.log('promise 4'))
    .then(() => {
      setTimeout(() => {
        console.log('setTimeout 2')
        Promise.resolve().then(() => console.log('promise 5'))
          .then(() => console.log('promise 6'))
          .then(() => clearInterval(interval))
      }, 0)
    })
}, 0)

Promise.resolve()
  .then(() => console.log('promise 1'))
  .then(() => console.log('promise 2'))

<b>консоль выведет:</b>
'script start'
'promise 1'
'promise 2'
'setInterval'
'setTimeout 1'
'promise 3'
'promise 4'
'setInterval'
'setTimeout 2'
'promise 5'
'promise 6'
              </code>
          </pre><pre>

<b>пример 2:</b>

<img id="async1" src="images/js_browser/async1.jpg" alt="async1">
            <code class="language-js">
<b>консоль выведет:</b> 3 6 7 2 5 1 4
// в момент нажатия стэк пустой => в стэк из очереди макрозадач попадут обработчики;
// т.к. эмитируем клик програмно, то клики совершены одновременно и 2 обработчика
// попадут в стэк один за другим, не пропуская микротаски
              </code>
        </pre><pre>

  <b>пример 3:</b>
            <code class="language-js">

(function() {
  console.log('start')

  for (var i = 0; i &lt; 100; i++) {
    // здесь IIFE будет сохранять локальную переменную i при каждом вызове =>
    // колбэк в setTimeout будет брать ее, а не var, который уже к моменту попадания
    // первого колбэка в call stack будет равен 100.
    //   Если бы не было IIFE, то решением было бы поменять var на let, что бы внутри
    // каждого блока (тела цикла) создавалась новая i, т.к. у var нет блочного scope
    ((i) => setTimeout(() => console.log(i), 15))(i)
  }

  console.log('end')
})()
              </code>
        </pre></article><ul class="section-refs"><li><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank">Event Loop</a></li><li><a href="https://www.jsv9000.server/" target="_blank">Event Loop with Microtask Queue</a></li><li><a href="https://www.youtube.com/watch?v=-t9TWD9FEfw" target="_blank">Event Loop крутится, task'и мутятся</a></li></ul></div></section><!--Document / nodes / styles--><section class="section" id="document"><div class="section-container"><h2 class="section-title">Document / nodes / styles</h2><article class="section-info"><pre>
<a href="#nodes_navigation" class="react__nav-link">навигация по DOM-элементам</a>
<a href="#nodes_attributes" class="react__nav-link">атрибуты и свойства</a>
<a href="#nodes_creation" class="react__nav-link">создание / вставка / удаление узлов</a>
<a href="#nodes_styles" class="react__nav-link">стили и классы</a>
<a href="#nodes_table" class="react__nav-link">table</a>
        </pre></article><article class="section-info"><b>basis</b><pre>
  DOM – объектная модель документа, которая представляет все содержимое страницы
в виде объектов, которые можно менять. Все, что есть в HTML, даже комментарии,
является частью DOM

  <b>DOM-узлы</b> – это обычные объекты JS. Мы можем их изменять, добавлять св-ва,
методы.
  Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию.
  Весь набор свойств (href, value...) и методов (querySelector, append...)
является результатом наследования

  Для узлов-элементов большинство стандартных HTML-атрибутов автоматически
становятся свойствами DOM-объектов. Например, для &lt;body id='page'> у DOM-объекта
будет такое свойство body.id='page'.
  Для нестандартных атрибутов (например, &lt;body type=''>) не будет соответствующих
DOM-свойств (alert(body.type) - undefined). Но такие атрибуты доступны с помощью
методов для атрибутов ( elem.getAttribute(name)... )

  <b>Получив DOM-node мы получаем объект со встроенными DOM-свойства (href, value...)
и DOM-методами (querySelector, append...) + со стандартными св-ми и методами объектов JS</b>

  Можно выделить какой то элемент в devTools и в консоле набрать console.dir($0).
Мы увидем огромное количество свойств у DOM-node объекта.
  <b>Поэтому самая затратная работа в JS - работа с DOM</b>

  DOM-узлы можно изменять, добавлять св-ва, методы.
Например, создадим новое св-во у document.body:
document.body.myData = {
  name: 'Caesar',
  title: 'Imperator'
}
<b>DOM-свойства и методы ведут себя так же, как и обычные объекты JS</b>:
- им можно присвоить любое значение
- они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe)

  Получая набор из нескольких DOM-узлов с помощью, например, метода childNodes,
мы получаем <b>коллекцию NodeList - особый перебираемый псевдомассив</b> (можно
перебрать в for..of, есть forEach()).
  Можно использовать Array.from() или [...nodes] для создания массива из коллекции


                                    <b>главные свойства DOM-узла:</b>
node/elem.nodeType == 1 для узлов-элементов
                   == 3 для текстовых
                   == 9 для объектов документа
node/elem.nodeName/tagName      - только для чтения
elem.innerHTML                  - внутреннее HTML-содержимое узла-элемента
elem.outerHTML                  - внешнее HTML-содержимое узла-элемента, т.е. включая elem
node.data                       - cодержимое узла-неэлемента: текста, комментария
elem.textContent                - читает текст без учета тегов;
                                  записывает «как текст», даже если есть теги
elem.hidden                     - если значение true, делает то же, что и CSS display: none
        </pre></article><article class="section-info" id="nodes_navigation"><b>навигация по DOM-элементам</b><pre>
<b>&lt;html/></b> - document.documentElement
<b>&lt;head/></b> - document.head
<b>&lt;body/></b> - document.body

  Получив DOM-узел, мы можем перейти к его ближайшим соседям используя
навигационные ссылки. Есть два основных набора ссылок:
  <b>для всех узлов (теги, текст, комментарии...):</b>
* childNodes содержит и текстовые узлы в т.ч.
parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling
  <b>только для узлов-элементов (тегов):</b>
parentElement, children, firstElementChild, lastElementChild,
previousElementSibling, nextElementSibling


elem.matches(selector)      - [boolean], проверяет, удовлетворяет ли elem CSS-селектору
elem.closest(selector)      - ищет ближайшего предка включая себя, соответствующего CSS-селектору
elemA.contains(elemB)       - вернёт true, если elemB находится внутри elemA
        </pre></article><article class="section-info" id="nodes_attributes"><b>атрибуты и свойства</b><pre>
Атрибуты – это то, что написано в HTML.
Свойства – это то, что находится в DOM-объектах.
Значением атрибута может быть только строка, а свойства - любой тип, как у обычного объекта.
У св-ва имя регистрозависимо, а у атрибута - нет.
В большинстве ситуаций предпочтительнее использовать DOM-свойства

<b>методы для работы с атрибутами:</b>
elem.hasAttribute(name)         – проверить на наличие
elem.getAttribute(name)         – получить значение
elem.setAttribute(name, value)  – установить значение
elem.removeAttribute(name)      – удалить атрибут
elem.attributes                 – это коллекция всех атрибутов


атрибуты «data-...» доступны в свойстве <b>dataset</b> (например, data-about='')
elem.dataset.about - доступно чтение и запись
        </pre></article><article class="section-info" id="nodes_creation"><b>создание / вставка / удаление узлов</b><pre>
  <b>создание:</b>
document.createElement(tag)       – создаёт элемент с заданным тегом
document.createTextNode(value)    – создаёт текстовый узел
elem.cloneNode(deep)              – клонирует элемент, если deep==true,
                                    то со всеми дочерними элементами

  <b>вставка и удаление:</b>
  <span>если добавить существующий элемент, то он вырежется</span>
node.append(...nodes or strings)      – добавляет узлы или строки (текст) в конец node
node.prepend(...nodes or strings)     – вставляет узлы или строки в начало node
node.before(...nodes or strings)      – вставляет узлы или строки перед node
node.after(...nodes or strings)       – вставляет узлы или строки после node
node.replaceWith(...nodes or strings) - заменяет node заданными узлами или строками, не удаляя
node.remove()                         – удаляет node

elem.insertAdjacentHTML(where, html)        - вставляет фрагмент HTML в зависимости от where
                                              'beforebegin' – вставляет html прямо перед elem
                                              'afterbegin' – вставляет html в elem в начало
                                              'beforeend' – вставляет html в elem в конец
                                              'afterend' – вставляет html сразу после elem
elem.insertAdjacentText(where, text)        - вставляет текстовые строки
elem.insertAdjacentElement(where, element)  - вставляет элементы


  HTML5 не позволяет динамически добавлять теги script с помощью innerHTML,
insertAdjacentHTML! Нужно создавать тег script и динамически добавлять в DOM.
  <b>Например создание инлайн скрипта:</b>
var newScript = document.createElement("script")
var inlineScript = document.createTextNode("alert('Hello World!')")
newScript.appendChild(inlineScript)
        </pre></article><article class="section-info" id="nodes_styles"><b>стили и классы</b><pre>
elem.className – строковое значение, удобно для управления всем набором классов
elem.classList – объект с методами add/remove/toggle/contains, для
                 управления отдельными классами; classList перебираемый


  <span>elem.style – это объект, который соответствует только тому, что есть в атрибуте 'style';
используя elem.style, мы не можем прочитать ничего, что приходит из классов CSS (для
этого есть getComputedStyle()); возвращает строку; все св-ва с дефисом через camelCase:</span>
elem.style.width = '5px'  <span>document.body.style.display = '' - для удаления стиля</span>

  <span>свойство style.cssText соответствует всему атрибуту 'style', полной строке стилей;
для задания нескольких стилей в одной строке используется свойство style.cssText:</span>
div.style.cssText = `color: red;
                     width: 100px;`


  <span>для чтения окончательных стилей из css + атрибута style (после
применения всех CSS-правил и CSS-наследования) используется getComputedStyle:</span>
let computedObj = getComputedStyle(elem, [pseudo]).marginTop    - только для чтения,
                                                                  возвращает строку '5px'


  <b>записывать св-ва можно только в атрибут 'style', в css нельзя! из css только чтение</b>
        </pre></article><article class="section-info" id="nodes_table"><b>&lt;table></b><pre>
  <b>таблица поддерживает следующие свойства:</b>
table.rows                   – коллекция строк &lt;tr> таблицы
table.caption/tHead/tFoot    – ссылки на элементы таблицы &lt;caption/>, &lt;thead/>, &lt;tfoot/>
table.tBodies                – коллекция элементов таблицы &lt;tbody/>
                               (по спецификации их может быть больше одного)
thead/tbody/tfoot.rows       – коллекция строк &lt;tr> секции
tr.cells                     – коллекция &lt;td> и &lt;th> ячеек, находящихся внутри строки &lt;tr>
tr.sectionRowIndex           – номер строки &lt;tr> в текущей секции &lt;thead>/&lt;tbody>/&lt;tfoot>
tr.rowIndex                  – номер строки &lt;tr> в таблице (включая все строки таблицы)
td.cellIndex                 – номер ячейки в строке &lt;tr>
        </pre></article><ul class="section-refs"><li><a href="https://dom.spec.whatwg.org" target="_blank">Спецификация DOM</a></li><li><a href="https://www.w3.org/TR/cssom-1/" target="_blank">Спецификация CSSOM</a></li><li><a href="https://html.spec.whatwg.org" target="_blank">Спецификация HTML</a></li><li><a href="https://learn.javascript.ru/selection-range" target="_blank">Selection и Range / выделение в элементах форм</a></li></ul></div></section><!--size / scroll / coordinates--><section class="section" id="size-scroll-coordinates"><div class="section-container"><h2 class="section-title">size / scroll / coordinates</h2><article class="section-info"><b>размеры и прокрутка элементов</b><pre>
<b>все св-ва только для чтения, кроме scrollLeft и scrollTop
все св-ва возвращают number</b>

offsetParent                – ближайший CSS-позиционированный родитель
                              или ближайший td, th, table, body
offsetLeft / offsetTop      – позиция в пикселях верхнего левого угла относительно offsetParent
                              (transform не влияет; значение округляется до целого числа)
offsetWidth / offsetHeight  – «внешняя» ширина/высота элемента <span>clientWidth + scrollBar + border</span>

clientLeft / clientTop      – расстояние от верхнего левого внешнего угла до
                              внутренного <span>offsetWidth - clientWidth = scrollBar + border</span>
clientWidth / clientHeight  – ширина/высота видимого содержимого вместе с padding,
                              но без scrollbar <span>content + padding - scrollBar</span>

scrollLeft / scrollTop      – ширина/высота прокрученной части элемента от верхнего левого угла
scrollWidth / scrollHeight  – ширина/высота содержимого, аналогично clientWidth/Height,
                              но учитывает прокрученную, невидимую область элемента

<span><b>offset</b>: content + padding + scrollBar + border
<b>client</b>: content + padding (только видимая область элемента, если у него есть скролл.
                          Если скролла нет - вся область элемента, даже если его не видно
                          в окне браузера из-за прокрутки страницы)
<b>scroll</b>: content + padding (учитывает и прокрученую невидимую область элемента со скроллом)</span>

* scrollbar вообще, если есть, является частью padding'a - прибавляется к величине padding
        </pre></article><ul class="section-refs"><li><a href="https://learn.javascript.ru/size-and-scroll" target="_blank">размеры и прокрутка элементов</a></li></ul><article class="section-info"><b>размеры и прокрутка окна</b><pre>
<span>window.clientWidth не бывает</span>
window.innerWidth/Height    - ширина/высота окна с учетом scrollBar, только для чтения

<span>способ получить полную высоту документа,
учитывая несоответствия/ошибки браузеров:</span>
const scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
)


window.pageXOffset/pageYOffset  - текущая прокрутка страницы, только для чтения

window.scrollBy(x,y)            - прокручивает страницу относительно её текущего положения
window.scrollTo(pageX,pageY)    - прокручивает страницу на абсолютные координаты;
                                    возможен вызов с объектом опций <b>для плавной прокрутки</b>:
                                  window.scrollTo({ top: 0, behavior: 'smooth' })


<span>если top=true (по умолчанию) - elem появится в верхней части окна;
если false - нижний край элемента будет совмещён с нижним краем окна</span>
elem.scrollIntoView(top)        - прокручивает страницу к элементу
        </pre></article><article class="section-info"><b>координаты</b><pre>
                Любая точка на странице имеет координаты:

  <b>- относительно окна браузера, даже если элемент находится
    вне окна (вне видимости). Отсчет от border, если есть:</b>
elem.getBoundingClientRect()      - возвращает объект со св-ми:
                                    x/y, width/height, top/bottom, left/right

  <b>- относительно документа, например:</b>
elem.getBoundingClientRect().top + window.pageYOffset
        </pre></article><article class="section-info"><b>MediaQueryList</b><pre>
  Объект MediaQueryList хранит информацию о мультимедийном запросе, примененном к документу
        </pre><pre>
          <code class="language-js">
var mql = window.matchMedia('(max-width: 600px)')

function screenTest(e) {
  if (e.matches) {
    /* the viewport is 600 pixels wide or less */
  } else {
    /* the viewport is more than 600 pixels wide */
  }
}

screenTest(mql)
mql.addEventListener('change', screenTest, false)
          </code>
        </pre></article></div></section><!-- events --><section class="section" id="events"><div class="section-container"><h2 class="section-title">events</h2><article class="section-info"><pre>
<a href="#events_add_handlers" class="react__nav-link">3 способа назначения / удаления обработчиков</a>
<a href="#events_bubbling_sinking" class="react__nav-link">всплытие и погружение</a>
<a href="#events_delegation" class="react__nav-link">делегирование</a>
<a href="#events_default_browser_actions" class="react__nav-link">действия браузера по умолчанию</a>
<a href="#events_generating_custom_events" class="react__nav-link">генерация пользовательских событий</a>
<a href="#events_interface_events" class="react__nav-link">интерфейсные события</a>
        </pre></article><article class="section-info" id="events_add_handlers"><pre>
  <b>3 способа назначения / удаления обработчиков:</b>

  <span>on{event}</span>
- aтрибут:     onclick='functionDo(this.innerHTML)' <span>тут functionDo возвращает function(event){}</span>

  <span>on{event}; убрать обработчик: elem.onclick = null;
    т.к. у элемента может быть только одно свойство с именем
  onclick, то назначить более одного обработчика нельзя!</span>
- DOM_свойство:     elem.onclick = function(event) { alert('click') }

  <span>позволяют повесить несколько обработчиков на одно событие!
  для удаления нужно передать именно ту же функцию-обработчик которая была назначена</span>
- метод:      elem.addEventListener(event, handler[, options])     - для добавления
              elem.removeEventListener(event, handler[, options])  - для удаления


  <b>внутри обработчиков this ссылается на текущий элемент!</b>
        </pre></article><article class="section-info" id="events_bubbling_sinking"><b>всплытие и погружение</b><pre>
<b>принцип всплытия</b> - когда на элементе происходит событие, обработчики
                   сначала срабатывают на нём, потом на его родителе,
                   затем выше и так далее, вверх по цепочке предков
<img class="img-bubbling" src="images/js_browser/event-order-bubbling.svg" alt="event-order-bubbling">
<b>* почти все события всплывают</b>

event.target                      - самый глубокий элемент, вызывающий событие, называется
                                    целевым элементом
event.currentTarget               - элемент, до которого дошло всплытие, на нём сейчас
                                    выполняется обработчик (он же this в обработчике)

event.stopPropagation()           - останавливает всплытие
event.stopImmediatePropagation()  - не только останавливает всплытие, но и
                                    останавливает обработку событий у текущего элемента

  <b>любой промежуточный обработчик может решить, что
событие полностью обработано, и остановить всплытие</b>

  * не прекращайте всплытие без необходимости, т.к. stopPropagation может
создать «мёртвую зону» для статистики, когда мы кликаем на элемент со stopPropagation



  Существует ещё одна фаза из жизненного цикла события – <b>погружение</b> (иногда
её называют перехват). Она очень редко используется в реальном коде, однако тоже
может быть полезной

  стандарт DOM Events описывает <b>3 фазы прохода события</b>:
фаза погружения (capturing phase)    – событие сначала идёт сверху вниз
фаза цели (target phase)             – событие достигло целевого элемента
фаза всплытия (bubbling stage)       – событие начинает всплывать


  <span>чтобы поймать событие на стадии погружения, нужно
использовать третий аргумент capture вот так</span>:
elem.addEventListener(..., {capture: true}) <span>или просто true, как сокращение для {capture: true}</span>
<span>если аргумент false (по умолчанию), то событие будет поймано при всплытии</span>

  <b>чтобы убрать обработчик removeEventListener, нужна та же фаза, например:
removeEventListener(..., true)</b>


  Если несколько обработчиков одного события, назначенных addEventListener на один
элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены
        </pre></article><article class="section-info" id="events_delegation"><b>делегирование</b><pre>
  <b>Делегирование событий</b> - прием, когда на общий для нескольких элементов предок-элемент
вешается обработчик, и в зависимости от цели (event.target) обрабатывются дочерние
элементы.
  Это <b>позволяет создавать один обработчик для нескольких элементов</b>
        </pre></article><article class="section-info" id="events_default_browser_actions"><b>действия браузера по умолчанию</b><pre>
  Действий браузера по умолчанию достаточно много, например:

mousedown    – начинает выделять текст (если двигать мышкой)
submit       – при нажатии на &lt;input type='submit'> или при нажатии
               клавиши Enter в форме данные отправляются на сервер
keydown      – при нажатии клавиши в поле ввода появляется символ
contextmenu  – при правом клике показывается контекстное меню браузера


  <b>Бывают события, вытекающие из других</b>
Например, mousedown для &lt;input> приводит к фокусировке на нём и запускает
событие focus. Если мы отменим событие mousedown (т.е. действие браузера по
умолчанию), то фокусирование не произойдёт


  Можно использовать <b>event.cancelable</b> чтобы проверить, является ли событие отменяемым


<b>event.preventDefault()</b> - отменить действие браузера по умолчанию; для обработчиков
                         назначенных через on{event} можно так же return false

* сначало выполняются действия в обработчике события, а затем действие по умолчанию, если
  не отменено. Но действия в обработчике могут занимать много времени и для таких событий
  как touchmove (пользователь перемещает палец по экрану => происходит прокрутка) это
  критично, т.к. скролл будет запоздалым.
    Есть способ выполнять дефолтное действие на событие одновременно с нашей обработкой,
  а не после: указать необязательную опцию <b>passive: true</b>, которая сообщает браузеру,
  что обработчик не собирается отменять дефолтное действие


* останавливать всплытие – плохо, т.к. например клик при всплытии может быть ипользован
  для статистических счетчиков, а stopPropagation() закроет доступ к этому обработчику.
    Лучше вместо этого проверять св-во <b>event.defaultPrevented</b> в обработчике вышестоящего
  элемента, чтобы понимать что в обработчике одного из дочерних элементов уже отменялось
  дефолтное действие и обрабатывалось такое же событие => не обрабатывать лишний раз в
  родительском, если это не нужно:
  в верхнем обработчике: if (event.defaultPrevented) return <span> выходим из обработчика</span>
        </pre></article><article class="section-info" id="events_generating_custom_events"><b>генерация пользовательских событий</b><pre>
  Событие встроенного класса Event можно создать так:
const event = <b>new Event(type[, options])</b>

type    – тип события, например 'click' или
          любой придуманный нами: 'my-event'
options – объект с двумя необязательными свойствами
          (по умолчанию оба свойства false):
            - bubbles:      если true - всплывает
            - cancelable:   если true - можно использовать preventDefault()


  Для некоторых конкретных типов событий есть свои <b>специфические конструкторы</b>, например:
<b>UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent...</b> Стоит использовать их
вместо new Event. Специфический конструктор позволяет указать стандартные свойства для
данного типа события (clientX/clientY для события мыши)
const event = new MouseEvent('click', {bubbles: true, clientX: 100, clientY: 100})

  Для генерации событий совершенно новых типов, таких как, например, 'hello', следует
использовать <b>конструктор new CustomEvent</b>. Технически CustomEvent абсолютно идентичен Event
за исключением небольшой детали: у второго аргумента-объекта есть дополнительное свойство
detail, в котором можно указывать информацию для передачи в событие, например:
let customEvent = new CustomEvent( 'hello', {detail: {name: 'Вася'}} )
  Нужно использовать addEventListener для наших собственных событий.
on{event}-свойства существуют только для встроенных событий: document.onhello не сработает

  после того, как объект события создан, мы должны запустить его на элементе, вызвав метод
<b>elem.dispatchEvent(event)</b>


  можно отличить настоящее событие от сгенерированного кодом с помощью св-ва
объекта события <b>event.isTrusted</b>  <span> true для реальных действий пользователя</span>
        </pre></article><article class="section-info" id="events_interface_events"><b>интерфейсные события</b><pre>
<b class="center">события мыши</b>
<b>простые события:</b>
mousedown/mouseup      - кнопка мыши нажата/отпущена над элементом
mouseover/mouseout     - курсор появляется над элементом и уходит с него;
                         имеют дополнительное св-во relatedTarget, которое
                         содержит ссылку на элемент с/на который мы переходим
mouseenter/mouseleave  - курсор переходит на элемент или уходит с него;
                         но переходы внутри элемента на его потомки и с них не
                         считаются; так же есть св-во relatedTarget; эти события
                         не всплывают, поэтому нельзя использовать делегирование!
mousemove              - каждое движение мыши над элементом генерирует это событие
contextmenu            - вызывается при попытке открытия контекстного меню правой кнопки мыши

<b>комплексные события:</b>
click                  - вызывается при mousedown и затем mouseup над одним
                         и тем же элементом, если использовалась левая кнопка мыши
dblclick               - вызывается двойным кликом на элементе

<b>cобытия мыши имеют следующие свойства:</b>
- кнопка: button (0 - левая, 1 - колесо, 2 - правая)
- клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (на Mac)
- координаты относительно окна: clientX/clientY
- координаты относительно документа: pageX/pageY
- скролл колеса мыши: wheel

  В современном стандарте HTML5 есть раздел о Drag and Drop – и там есть специальные
события именно для Drag’n’Drop переноса, такие как dragstart, dragend и т.д.

  Браузер имеет свой собственный Drag’n’Drop (события dragstart, dragend...), который
автоматически запускается и вступает в конфликт с нашим; это происходит именно для
картинок и некоторых других элементов; чтобы его отключить:
elem.ondragstart = function() { return false }



<b class="center">события клавиатуры</b>
keydown   – при нажатии на клавишу (если клавиша
            остаётся нажатой, происходит автоповтор)
keyup     – при отпускании клавиши

<b>главные свойства:</b>
code      – код ('KeyA', 'ArrowLeft'), привязанный к
            физическому расположению клавиши на клавиатуре
key       – символ ('A', 'a' ...); при изменении
            языка раскладки меняется и символ
repeat    - для событий вызванных автоповтором свойство repeat равно true



<b class="center">событие прокрутки</b>
scroll - событие позволяет реагировать на прокрутку страницы или элемента
        </pre></article></div></section><!-- forms --><section class="section" id="forms"><div class="section-container"><h2 class="section-title">forms</h2><article class="section-info"><b>свойства и методы формы</b><pre>

<span>«именованная» коллекция форм (document.forms.my (name='my') или document.forms[0])</span>
<b>document.forms</b>

получаем элемент формы &lt;input name='one'> с помощью <b>св-ва elements</b>;
если несколько элементов с одним и тем же именем (radio), то form.elements[name] - коллекция
const form = document.forms.my
const elem = form.elements.one

<span>cокращённая форма записи</span>
form.elements.login == form.login


* для любого элемента форма доступна через element.form (элементы хранят ссылку на свою форму)


input.value     = 'Новое значение'
textarea.value  = 'Новый текст'
input.checked   = boolean <span>для чекбоксов и переключателей</span>


<b>элемент &lt;select> имеет 3 важных свойства:</b>
select.options        – коллекция из подэлементов &lt;option>
select.value          – значение выбранного в данный момент &lt;option>
select.selectedIndex  – номер выбранного &lt;option>

<b>свойства элемента &lt;option>:</b>
option.selected   - boolean
option.index      - номер опции среди других в списке
option.text       - содержимое опции

<b>создание элемента &lt;option>:</b>
new Option(text, value, defaultSelected, selected)
defaultSelected  – если true, то ставится HTML-атрибут selected
selected         – если true, то элемент &lt;option> будет выбранным
        </pre></article><article class="section-info"><b>фокусировка</b><pre>
  Элемент получает фокус (если он фокусируемый или если у него установлен tabIndex),
когда пользователь кликает по нему или использует клавишу Tab.
  Существует <b>HTML-атрибут autofocus</b> - устанавливает фокус, когда страница загружается

  <b>Событие focus/blur не всплывают</b>, но можно использовать или фазу погружения,
установив 3й параметр метода addEventListener в true, или <b>всплывающие focusin/focusout</b>
focus     - вызывается в момент фокусировки, не всплывает
blur      - вызывается когда элемент теряет фокус, не всплывает
focusin   - вызывается в момент фокусировки, всплывает
focusout  - вызывается когда элемент теряет фокус, всплывает

* нельзя отменить потерю фокуса, вызвав event.preventDefault() в обработчике
события blur потому, что onblur срабатывает после потери фокуса элементом


<b>elem.focus()</b>  - устанавливеют фокус элементу
<b>elem.blur()</b>   - снимает фокус c элемента


  Многие элементы по умолчанию не поддерживают фокусировку; elem.focus() не работает
для них, и события focus/blur никогда не срабатывают.
  Однако любой элемент поддерживает фокусировку, если имеет <b>HTML-атрибут tabindex</b>.
  Порядок перебора табом таков: сначала идут элементы со значениями tabindex от 1
и выше, в порядке tabindex, а затем элементы без tabindex (например, обычный &lt;input>)
elem.tabIndex  - добавление tabindex из JavaScript
tabindex="-1"  - позволяет фокусироваться на элементе только программно (методом elem.focus())
tabindex="0"   - ставит элемент в один ряд с элементами без tabindex; то есть, при
                 переключении такие элементы будут после элементов с tabindex ≥ 1

<b>document.activeElement</b>     - получить текущий элемент с фокусом
        </pre></article><article class="section-info"><b>события: change, input, cut, copy, paste</b><pre>
change             - срабатывает по окончании изменения элемента; для текстовых &lt;input>;
                     это означает, что событие происходит при потере фокуса; при печатанье
                     событие не происходит;
                     для select/checkbox/radio запускается сразу после изменения значения
input              - срабатывает каждый раз при изменении значения; если значение не меняется,
                     например при нажатии стрелочки влево, то событие не срабатывает;
                     событие input происходит после изменения значения, поэтому
                     event.preventDefault() не сработает для отмены ввода
cut, copy, paste   - события происходят при вырезании/копировании/вставке данных; свойство
                     event.clipboardData предоставляет доступ на чтение/запись в буфер обмена
        </pre></article><article class="section-info"><b>отправка формы</b><pre>

  Есть два основных способа отправить форму
  (оба действия сгенерируют событие submit на форме):
– нажать кнопку &lt;input type='submit'> или &lt;input type='image'>
– нажать Enter, находясь на каком-нибудь поле


событие submit - срабатывает при отправке формы; обычно используется
                 для валидации формы перед её отправкой на сервер или
                 для предотвращения отправки и обработки её с помощью JS

* при отправке формы генерируется событие click на кнопке c type='submit'


form.submit() - инициирует отправку формы из JavaScript
        </pre></article></div></section><!-- загрузка документа и ресурсов --><section class="section" id="load"><div class="section-container"><h2 class="section-title">load document and resources</h2><article class="section-info"><pre>
    <b>defer</b>
- скрипты с defer не блокируют страницу: ждут окончания парсинга HTML, полного
  формирования DOM (=> подгрузки и выполнения остальных обычных скриптов (не
  важно внешних или нет) без defer)
- скрипты с defer сохраняют порядок относительно друг друга
- выполняются до события DOMContentLoaded

    <b>async</b> (скрипт абсолютно независим)
- скрипты с async не блокируют страницу
- остальные скрипты не ждут async, и скрипты c async не ждут другие скрипты
- скрипты с async не ждут друг друга
- событие DOMContentLoaded и асинхронные скрипты не ждут друг друга

* скрипты с async очень полезны для добавления на
  страницу сторонних скриптов: счётчиков, рекламы и т.д.


  Можно <b>добавить скрипт динамически</b>:
const script = document.createElement('script')
script.src = '/article/script-async-defer/long.js'
document.body.append(script)
  Динамически загружаемые скрипты по умолчанию <b>ведут себя как async</b>. Можно изменить
относительный порядок скриптов с «первый загрузился – первый выполнился» на порядок,
в котором они идут в документе (как в обычных скриптах) с помощью явной установки
свойства async в false


<b>DOMContentLoaded             – (событие у document)</b> браузер полностью загрузил HTML,
                               было построено DOM-дерево (=> загружены и выполнены все
                               скрипты (кроме скриптов с async и динамически сген-ых)),
                               но внешние ресурсы, такие как картинки, шрифты, стили,
                               могут быть ещё не загружены

<b>load                         – (событие у window, после DOMContentLoaded)</b> браузер
                               загрузил HTML и все внешние ресурсы (картинки, стили,
                               все скрипты (в т.ч. с async)...)

<b>beforeunload                 – (событие у window)</b> когда пользователь покидает страницу;
                               можно отменить переход на другую страницу в confirm

<b>unload                       – (событие у window)</b> когда пользователь покидает страницу
                               (обычно здесь отсылают статистику); отменить переход на
                               другую страницу нельзя


<b>document.readyState</b>      – текущее состояние документа;
                           изменения можно отследить <b>событием readystatechange (у document)</b>:
loading       – документ грузится
interactive   – документ прочитан, происходит примерно в то же
                время, что и DOMContentLoaded, но до него
complete      – документ и ресурсы загружены, происходит примерно
                в то же время, что и window.onload, но до него
        </pre></article><article class="section-info"><b>загрузка ресурсов: onload и onerror</b><pre>

  изображения, внешние стили, скрипты и другие ресурсы
предоставляют события load и error для отслеживания загрузки:
<b>load</b>        - срабатывает при успешной загрузке
<b>error</b>       - срабатывает при ошибке загрузки

* единственное <b>исключение – это &lt;iframe></b>: по историческим причинам
  срабатывает всегда load вне зависимости от того, как завершилась
  загрузка, даже если страница не была найдена
        </pre></article></div></section><!--network / requests--><section class="section" id="network"><div class="section-container"><h2 class="section-title">network / requests</h2><article class="section-info"><pre>
<a href="#internet_server" class="react__nav-link">internet / server / domain / HTTP / Socket</a>
<a href="#url" class="react__nav-link">URL, URI methods</a>
<a href="#punycode" class="react__nav-link">ASCII / Punycode</a>
<a href="#request_methods" class="react__nav-link">request methods (CRUD) / AJAX / REST API / HTTP status codes</a>
<a href="#XMLHttpRequest" class="react__nav-link">XMLHttpRequest</a>
<a href="#fetch" class="react__nav-link">fetch / headers / body</a>
        </pre></article><article class="section-info" id="internet_server"><b>internet / server / domain / HTTP / Socket</b><pre>
  <b>интернет</b> - очень большая сеть компьютеров, которые могут взаимодействовать друг с другом

  <b>сервер</b> - мощный вычислительный компьютер, постоянно подключенный к сети интернет
           и к электропитанию 24/7 (обычно хранит веб-страницы, сайты или приложения)

  <b>хост</b> - сервер, который хранит веб-страницы, сайты или приложения

  Каждый компьютер (включая сервер), подключённый к сети, имеет свой уникальный адрес
для связи: этот адрес называют <b>IP-адресом</b> (например 192.168.2.10).
  Чтобы упростить себе жизнь, мы можем присвоить каждому IP-адресу псевдоним с понятным
для человека именем. Такой псевдоним называют <b>доменным именем</b>.
  <b>DNS</b> хранит доменные имена связанные с IP-адресами.
  Когда вы вводите веб-адрес в своём браузере, браузер обращается кближайшему DNS-серверу,
чтобы найти реальный адрес сервера (меняем домен на IP), на котором находится сайт, и
отправить на него запрос через 80 порт.
  <b>HTTP</b> — это протокол (система правил) клиент-серверного взаимодействия (как и, например,
WebSocket), позволяющий получать различные ресурсы, например HTML-документы, и инициировать
запросы к серверу.

  Что бы отправить запрос или получить ответ, между клиентом (браузером) и сервером нужно
установить некий канал связи для передачи данных. Этот канал получил название <b>Socket</b>.
  Отправка данных между клиентом и сервером происходит по протоколу <b>TCP</b> (Transmission
Control Protocol - протокол управления передачей) с помощью <b>пакетов (блоков данных)</b>, т.е.
частями. Каждый пакет TCP может быть до 14 KB.
  <b>HTTP vs TCP</b>: TCP это протокол транспортного уровня, а HTTP — это протокол прикладного
уровня, работающий поверх TCP. Сам TCP работает поверх IP. В основном это означает, что
если вы общаетесь по HTTP, вы делаете это с помощью TCP/IP.



.com                    – домены первого уровня (доменные зоны)
example.com             - домен второго уровня (example.com - поддомен домена .com)
subdomain.example.com   - домены третье уровня

  Обычно сайты лежат на сервере хостинг-провайдера (хостера) и к ним есть <b>ftp доступ</b>.
Самый простой способ определить хостинг сайта по домену:
- открываем консоль (Win + R: ввести 'cmd')
- вводим 'ping [domainName]' (ping anton-byshok.web.server). Видим IP (199.36.158.100)
- на сервисе https://sweb.ru/whois/, позволяющему определить какому провайдеру
  принадлежит тот или иной IP-адрес вводим наш IP
        </pre></article><article class="section-info" id="url"><b>URL, URI methods</b><pre>
  У любого ресурса (HTML-страница, CSS-файл, изображение и т.д.) в интернете есть адрес,
называемый URL

<b>URI</b> (Uniform Resource Identifier) - универсальный id ресурса ( <b>URI = URL + URN</b> )
<b>URN</b> (Uniform Resource Name)       - универсальное имя ресурса; почти не используется в web
<b>URL</b> (Uniform Resource Locator)    - универсальный локатор ресурса (web address, link)



   <b>компоненты URL (URI):</b>
<svg xmlns="http://www.w3.org/2000/svg" width="567" height="200" viewBox="0 0 698 246"><defs><style>@import url(https://fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic%7CPT+Mono);

@font-face {
  font-family: 'PT Mono';
  font-weight: 700;
  font-style: normal;
  src: local('PT MonoBold'), url(/font/PTMonoBold.woff2) format('woff2'), url(/font/PTMonoBold.woff) format('woff'), url(/font/PTMonoBold.ttf) format('truetype')
}</style></defs><g id="network" fill="none" fill-rule="evenodd" stroke="none" stroke-width="1"><g id="url-object.svg"><path id="Line-Copy" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M27 38v180"/><path id="Line-Copy-2" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M109 132v86"/><path id="Line-Copy-6" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M136 112v106"/><path id="Line-Copy-10" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M27 38l665 .5"/><path id="Line-Copy-11" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M27 74.5h280"/><path id="Line-Copy-7" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M254 132v86"/><path id="Line-Copy-8" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M243 132v86"/><path id="Line-Copy-9" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M308 38v180"/><path id="Line-Copy-13" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M439 132v86"/><path id="Line-Copy-14" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M622 132v86"/><path id="Line-Copy-15" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M692 39v179"/><text id="href" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="270" y="30">href (полный URL-адрес)</tspan></text><text id="origin" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="135" y="68">origin</tspan></text><path id="Line-Copy-12" fill="#C06334" stroke="#C06334" stroke-dasharray="1" stroke-linecap="square" stroke-width="2" d="M136 112.5h170"/><text id="host" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="202" y="106">host</tspan></text><text id="protocol" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="30.6" y="152">protocol</tspan></text><path id="https://site.com:8080/path/page?p1=v1&amp;p2=v2…#hash" fill="#181717" fill-rule="nonzero" d="M31.772 196.4h2.808v4.716h.09a4.03 4.03 0 011.296-.981c.492-.234 1.104-.351 1.836-.351.576 0 1.077.06 1.503.18.426.12.774.33 1.044.63s.471.711.603 1.233c.132.522.198 1.185.198 1.989V209h-1.404v-4.914c0-.516-.03-.966-.09-1.35-.06-.384-.177-.705-.351-.963a1.626 1.626 0 00-.711-.585c-.3-.132-.684-.198-1.152-.198a2.76 2.76 0 00-.954.171c-.312.114-.597.27-.855.468s-.48.438-.666.72a2.693 2.693 0 00-.387.927V209h-1.386v-11.394h-1.422V196.4zm13.686 3.6H47.6v-1.782l1.404-.396V200h4.806v1.206h-4.806v4.248c0 .876.213 1.524.639 1.944.426.42 1.035.63 1.827.63.54 0 1.011-.102 1.413-.306a7.614 7.614 0 001.089-.666l.468 1.062c-.42.336-.921.606-1.503.81a5.377 5.377 0 01-1.791.306c-.48 0-.933-.069-1.359-.207a3.12 3.12 0 01-1.125-.639 3.06 3.06 0 01-.774-1.107c-.192-.45-.288-.987-.288-1.611v-4.464h-2.142V200zm13.2 0H60.8v-1.782l1.404-.396V200h4.806v1.206h-4.806v4.248c0 .876.213 1.524.639 1.944.426.42 1.035.63 1.827.63.54 0 1.011-.102 1.413-.306a7.614 7.614 0 001.089-.666l.468 1.062c-.42.336-.921.606-1.503.81a5.377 5.377 0 01-1.791.306c-.48 0-.933-.069-1.359-.207a3.12 3.12 0 01-1.125-.639 3.06 3.06 0 01-.774-1.107c-.192-.45-.288-.987-.288-1.611v-4.464h-2.142V200zm14.37 3.15a18.063 18.063 0 00-.081-1.512 5.988 5.988 0 00-.063-.468h-1.206V200h2.394l.18 1.26h.09a4.06 4.06 0 011.233-1.053c.498-.282 1.107-.423 1.827-.423 1.284 0 2.25.354 2.898 1.062.648.708.972 1.866.972 3.474 0 .756-.111 1.437-.333 2.043a4.295 4.295 0 01-.945 1.539c-.408.42-.9.744-1.476.972a5.141 5.141 0 01-1.908.342c-.252 0-.477-.009-.675-.027a5.93 5.93 0 01-.54-.072 4.255 4.255 0 01-.477-.117 6.561 6.561 0 01-.504-.18v3.78h-1.386v-9.45zm4.14-2.052c-.36 0-.699.066-1.017.198a3.034 3.034 0 00-1.449 1.242 2.118 2.118 0 00-.288.792v4.104a3.3 3.3 0 00.891.423c.33.102.765.153 1.305.153.96 0 1.728-.315 2.304-.945.576-.63.864-1.551.864-2.763 0-1.02-.201-1.809-.603-2.367-.402-.558-1.071-.837-2.007-.837zm15.216 5.472c0-.384-.15-.681-.45-.891-.3-.21-.672-.378-1.116-.504a20.643 20.643 0 00-1.449-.351 8.36 8.36 0 01-1.449-.432 3.247 3.247 0 01-1.116-.729c-.3-.306-.45-.735-.45-1.287 0-.456.099-.846.297-1.17.198-.324.459-.591.783-.801.324-.21.702-.366 1.134-.468a5.856 5.856 0 011.35-.153c.84 0 1.563.105 2.169.315.606.21 1.089.429 1.449.657l-.576 1.134a15.16 15.16 0 00-1.287-.621c-.462-.198-1.041-.297-1.737-.297-.264 0-.525.027-.783.081a2.767 2.767 0 00-.702.243c-.21.108-.378.249-.504.423a1.06 1.06 0 00-.189.639c0 .312.15.552.45.72.3.168.672.309 1.116.423.444.114.927.222 1.449.324a7.044 7.044 0 011.449.441c.444.192.816.45 1.116.774.3.324.45.762.45 1.314 0 .828-.327 1.512-.981 2.052-.654.54-1.635.81-2.943.81-.396 0-.786-.036-1.17-.108a7.096 7.096 0 01-1.08-.288 6.498 6.498 0 01-.918-.405 3.86 3.86 0 01-.684-.459l.72-1.17c.144.144.336.291.576.441a5.437 5.437 0 001.719.693 4.833 4.833 0 001.908.027c.282-.054.531-.138.747-.252.216-.114.387-.264.513-.45s.189-.411.189-.675zm9.51-5.634c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm0 7.074c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm17.124-11.826l1.134.504-6.57 14.832-1.134-.504 6.57-14.832zm13.2 0l1.134.504-6.57 14.832-1.134-.504 6.57-14.832zm12.966 10.386c0-.384-.15-.681-.45-.891-.3-.21-.672-.378-1.116-.504a20.643 20.643 0 00-1.449-.351 8.36 8.36 0 01-1.449-.432 3.247 3.247 0 01-1.116-.729c-.3-.306-.45-.735-.45-1.287 0-.456.099-.846.297-1.17.198-.324.459-.591.783-.801.324-.21.702-.366 1.134-.468a5.856 5.856 0 011.35-.153c.84 0 1.563.105 2.169.315.606.21 1.089.429 1.449.657l-.576 1.134a15.16 15.16 0 00-1.287-.621c-.462-.198-1.041-.297-1.737-.297-.264 0-.525.027-.783.081a2.767 2.767 0 00-.702.243c-.21.108-.378.249-.504.423a1.06 1.06 0 00-.189.639c0 .312.15.552.45.72.3.168.672.309 1.116.423.444.114.927.222 1.449.324a7.044 7.044 0 011.449.441c.444.192.816.45 1.116.774.3.324.45.762.45 1.314 0 .828-.327 1.512-.981 2.052-.654.54-1.635.81-2.943.81-.396 0-.786-.036-1.17-.108a7.096 7.096 0 01-1.08-.288 6.498 6.498 0 01-.918-.405 3.86 3.86 0 01-.684-.459l.72-1.17c.144.144.336.291.576.441a5.437 5.437 0 001.719.693 4.833 4.833 0 001.908.027c.282-.054.531-.138.747-.252.216-.114.387-.264.513-.45s.189-.411.189-.675zm7.206 2.43v-1.206h3.132v-6.588h-3.132V200h4.572v7.794h3.06V209h-7.632zm2.646-11.556c0-.324.108-.603.324-.837.216-.234.492-.351.828-.351.348 0 .639.117.873.351.234.234.351.513.351.837 0 .312-.117.576-.351.792a1.238 1.238 0 01-.873.324c-.336 0-.612-.108-.828-.324a1.077 1.077 0 01-.324-.792zm9.222 2.556h2.142v-1.782l1.404-.396V200h4.806v1.206h-4.806v4.248c0 .876.213 1.524.639 1.944.426.42 1.035.63 1.827.63.54 0 1.011-.102 1.413-.306a7.614 7.614 0 001.089-.666l.468 1.062c-.42.336-.921.606-1.503.81a5.377 5.377 0 01-1.791.306c-.48 0-.933-.069-1.359-.207a3.12 3.12 0 01-1.125-.639 3.06 3.06 0 01-.774-1.107c-.192-.45-.288-.987-.288-1.611v-4.464h-2.142V200zm22.164 7.866a4.53 4.53 0 01-.765.54 5.645 5.645 0 01-.963.432 7.06 7.06 0 01-1.089.279 6.633 6.633 0 01-1.143.099c-.72 0-1.356-.111-1.908-.333a3.674 3.674 0 01-1.386-.954 4.158 4.158 0 01-.846-1.485c-.192-.576-.288-1.224-.288-1.944 0-.756.105-1.428.315-2.016.21-.588.513-1.08.909-1.476a3.959 3.959 0 011.44-.909c.564-.21 1.194-.315 1.89-.315.504 0 1.002.066 1.494.198a2.95 2.95 0 011.305.747c.378.366.669.87.873 1.512.204.642.276 1.473.216 2.493h-6.966c0 1.08.291 1.887.873 2.421.582.534 1.359.801 2.331.801.324 0 .645-.039.963-.117.318-.078.621-.171.909-.279.288-.108.543-.228.765-.36.222-.132.393-.252.513-.36l.558 1.026zm-3.798-6.894a4.86 4.86 0 00-1.125.126 2.564 2.564 0 00-.936.423c-.27.198-.492.456-.666.774-.174.318-.285.711-.333 1.179h5.598c-.06-.792-.315-1.407-.765-1.845-.45-.438-1.041-.657-1.773-.657zm11.67 7.038c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm16.908-6.624a7.111 7.111 0 00-.891-.243 4.64 4.64 0 00-.945-.099c-1.176 0-2.052.276-2.628.828-.576.552-.864 1.428-.864 2.628 0 .528.084.999.252 1.413.168.414.408.765.72 1.053.312.288.687.51 1.125.666.438.156.921.234 1.449.234.564 0 1.113-.096 1.647-.288.534-.192.981-.444 1.341-.756l.63 1.044a5.095 5.095 0 01-.63.45 6.053 6.053 0 01-1.971.774 6.38 6.38 0 01-1.305.126c-.78 0-1.467-.111-2.061-.333a3.914 3.914 0 01-1.485-.954 4.083 4.083 0 01-.9-1.494 5.818 5.818 0 01-.306-1.935c0-.756.105-1.428.315-2.016.21-.588.513-1.08.909-1.476a3.959 3.959 0 011.44-.909c.564-.21 1.194-.315 1.89-.315.888 0 1.611.078 2.169.234.558.156 1.029.33 1.413.522l-.018.054v2.502h-1.296v-1.71zm6.324 3.114c0-1.452.378-2.601 1.134-3.447.756-.846 1.836-1.269 3.24-1.269.756 0 1.407.123 1.953.369s.999.579 1.359.999c.36.42.627.918.801 1.494.174.576.261 1.194.261 1.854 0 .72-.096 1.371-.288 1.953a4.057 4.057 0 01-.846 1.485 3.738 3.738 0 01-1.377.945c-.546.222-1.167.333-1.863.333-.744 0-1.392-.123-1.944-.369a3.815 3.815 0 01-1.368-.999 4.073 4.073 0 01-.801-1.494 6.381 6.381 0 01-.261-1.854zm1.494 0c0 .42.051.84.153 1.26.102.42.267.798.495 1.134.228.336.525.606.891.81.366.204.813.306 1.341.306.96 0 1.683-.297 2.169-.891.486-.594.729-1.467.729-2.619 0-.432-.051-.855-.153-1.269a3.353 3.353 0 00-.504-1.125 2.656 2.656 0 00-.9-.81c-.366-.204-.813-.306-1.341-.306-.96 0-1.68.294-2.16.882-.48.588-.72 1.464-.72 2.628zm15.396 4.5v-5.994a9.51 9.51 0 00-.027-.729 2.442 2.442 0 00-.126-.63 1.01 1.01 0 00-.288-.441.734.734 0 00-.495-.162c-.408 0-.753.168-1.035.504-.282.336-.495.756-.639 1.26V209h-1.368v-9h.936l.27 1.098h.072c.12-.18.237-.351.351-.513.114-.162.246-.303.396-.423.15-.12.327-.213.531-.279.204-.066.462-.099.774-.099.18 0 .366.027.558.081.192.054.369.138.531.252.162.114.303.267.423.459s.198.426.234.702c.276-.468.585-.834.927-1.098.342-.264.813-.396 1.413-.396.396 0 .717.066.963.198s.438.321.576.567c.138.246.234.54.288.882.054.342.081.723.081 1.143V209h-1.368v-6.12c0-.252-.012-.489-.036-.711a2.268 2.268 0 00-.135-.585.967.967 0 00-.27-.396c-.114-.096-.267-.144-.459-.144-.42 0-.774.168-1.062.504-.288.336-.504.816-.648 1.44V209h-1.368zm12.678-8.064c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm0 7.074c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm10.356-2.07c0-1.452.882-2.622 2.646-3.51-.336-.18-.648-.366-.936-.558a3.746 3.746 0 01-.747-.648 2.737 2.737 0 01-.495-.828 2.996 2.996 0 01-.18-1.08c0-.444.09-.858.27-1.242.18-.384.438-.714.774-.99a3.842 3.842 0 011.224-.657 4.988 4.988 0 011.602-.243c.552 0 1.053.072 1.503.216a3.5 3.5 0 011.152.603c.318.258.561.561.729.909.168.348.252.72.252 1.116 0 .684-.171 1.311-.513 1.881-.342.57-.891 1.089-1.647 1.557.348.18.672.372.972.576.3.204.561.432.783.684.222.252.396.537.522.855.126.318.189.681.189 1.089 0 .504-.09.975-.27 1.413a3 3 0 01-.801 1.125 3.88 3.88 0 01-1.305.738c-.516.18-1.116.27-1.8.27-.636 0-1.2-.09-1.692-.27a3.696 3.696 0 01-1.233-.72c-.33-.3-.579-.648-.747-1.044a3.148 3.148 0 01-.252-1.242zm6.678-.18c0-.348-.081-.657-.243-.927a2.74 2.74 0 00-.648-.729 5.59 5.59 0 00-.927-.594c-.348-.18-.708-.36-1.08-.54-.864.42-1.479.882-1.845 1.386-.366.504-.549.978-.549 1.422 0 .3.057.585.171.855.114.27.282.507.504.711.222.204.498.366.828.486.33.12.711.18 1.143.18.348 0 .681-.048.999-.144.318-.096.6-.237.846-.423s.441-.42.585-.702c.144-.282.216-.609.216-.981zm-4.986-6.498c0 .336.078.636.234.9.156.264.363.501.621.711.258.21.555.402.891.576.336.174.69.345 1.062.513.636-.42 1.113-.84 1.431-1.26.318-.42.477-.882.477-1.386 0-.3-.063-.567-.189-.801a1.948 1.948 0 00-.504-.603 2.292 2.292 0 00-.729-.387 2.77 2.77 0 00-.864-.135c-.384 0-.726.054-1.026.162-.3.108-.552.252-.756.432-.204.18-.363.381-.477.603a1.463 1.463 0 00-.171.675zm11.148 3.438c0-1.02.09-1.935.27-2.745.18-.81.45-1.494.81-2.052.36-.558.816-.984 1.368-1.278.552-.294 1.206-.441 1.962-.441.804 0 1.485.144 2.043.432a3.466 3.466 0 011.359 1.26c.348.552.6 1.233.756 2.043.156.81.234 1.737.234 2.781 0 1.02-.09 1.935-.27 2.745-.18.81-.45 1.494-.81 2.052-.36.558-.816.984-1.368 1.278-.552.294-1.206.441-1.962.441-.792 0-1.467-.159-2.025-.477a3.8 3.8 0 01-1.368-1.341c-.354-.576-.609-1.263-.765-2.061a13.774 13.774 0 01-.234-2.637zm7.326 0c0-.636-.036-1.242-.108-1.818l-5.346 4.878c.204.684.51 1.23.918 1.638.408.408.942.612 1.602.612 1.056 0 1.809-.438 2.259-1.314.45-.876.675-2.208.675-3.996zm-5.832 0c0 .3.009.588.027.864.018.276.039.546.063.81l5.364-4.86c-.204-.648-.507-1.164-.909-1.548-.402-.384-.945-.576-1.629-.576-1.068 0-1.821.441-2.259 1.323-.438.882-.657 2.211-.657 3.987zm12.066 3.24c0-1.452.882-2.622 2.646-3.51-.336-.18-.648-.366-.936-.558a3.746 3.746 0 01-.747-.648 2.737 2.737 0 01-.495-.828 2.996 2.996 0 01-.18-1.08c0-.444.09-.858.27-1.242.18-.384.438-.714.774-.99a3.842 3.842 0 011.224-.657 4.988 4.988 0 011.602-.243c.552 0 1.053.072 1.503.216a3.5 3.5 0 011.152.603c.318.258.561.561.729.909.168.348.252.72.252 1.116 0 .684-.171 1.311-.513 1.881-.342.57-.891 1.089-1.647 1.557.348.18.672.372.972.576.3.204.561.432.783.684.222.252.396.537.522.855.126.318.189.681.189 1.089 0 .504-.09.975-.27 1.413a3 3 0 01-.801 1.125 3.88 3.88 0 01-1.305.738c-.516.18-1.116.27-1.8.27-.636 0-1.2-.09-1.692-.27a3.696 3.696 0 01-1.233-.72c-.33-.3-.579-.648-.747-1.044a3.148 3.148 0 01-.252-1.242zm6.678-.18c0-.348-.081-.657-.243-.927a2.74 2.74 0 00-.648-.729 5.59 5.59 0 00-.927-.594c-.348-.18-.708-.36-1.08-.54-.864.42-1.479.882-1.845 1.386-.366.504-.549.978-.549 1.422 0 .3.057.585.171.855.114.27.282.507.504.711.222.204.498.366.828.486.33.12.711.18 1.143.18.348 0 .681-.048.999-.144.318-.096.6-.237.846-.423s.441-.42.585-.702c.144-.282.216-.609.216-.981zm-4.986-6.498c0 .336.078.636.234.9.156.264.363.501.621.711.258.21.555.402.891.576.336.174.69.345 1.062.513.636-.42 1.113-.84 1.431-1.26.318-.42.477-.882.477-1.386 0-.3-.063-.567-.189-.801a1.948 1.948 0 00-.504-.603 2.292 2.292 0 00-.729-.387 2.77 2.77 0 00-.864-.135c-.384 0-.726.054-1.026.162-.3.108-.552.252-.756.432-.204.18-.363.381-.477.603a1.463 1.463 0 00-.171.675zm11.148 3.438c0-1.02.09-1.935.27-2.745.18-.81.45-1.494.81-2.052.36-.558.816-.984 1.368-1.278.552-.294 1.206-.441 1.962-.441.804 0 1.485.144 2.043.432a3.466 3.466 0 011.359 1.26c.348.552.6 1.233.756 2.043.156.81.234 1.737.234 2.781 0 1.02-.09 1.935-.27 2.745-.18.81-.45 1.494-.81 2.052-.36.558-.816.984-1.368 1.278-.552.294-1.206.441-1.962.441-.792 0-1.467-.159-2.025-.477a3.8 3.8 0 01-1.368-1.341c-.354-.576-.609-1.263-.765-2.061a13.774 13.774 0 01-.234-2.637zm7.326 0c0-.636-.036-1.242-.108-1.818l-5.346 4.878c.204.684.51 1.23.918 1.638.408.408.942.612 1.602.612 1.056 0 1.809-.438 2.259-1.314.45-.876.675-2.208.675-3.996zm-5.832 0c0 .3.009.588.027.864.018.276.039.546.063.81l5.364-4.86c-.204-.648-.507-1.164-.909-1.548-.402-.384-.945-.576-1.629-.576-1.068 0-1.821.441-2.259 1.323-.438.882-.657 2.211-.657 3.987zm18.834-6.516l1.134.504-6.57 14.832-1.134-.504 6.57-14.832zm6.81 6.966a18.063 18.063 0 00-.081-1.512 5.988 5.988 0 00-.063-.468h-1.206V200h2.394l.18 1.26h.09a4.06 4.06 0 011.233-1.053c.498-.282 1.107-.423 1.827-.423 1.284 0 2.25.354 2.898 1.062.648.708.972 1.866.972 3.474 0 .756-.111 1.437-.333 2.043a4.295 4.295 0 01-.945 1.539c-.408.42-.9.744-1.476.972a5.141 5.141 0 01-1.908.342c-.252 0-.477-.009-.675-.027a5.93 5.93 0 01-.54-.072 4.255 4.255 0 01-.477-.117 6.561 6.561 0 01-.504-.18v3.78h-1.386v-9.45zm4.14-2.052c-.36 0-.699.066-1.017.198a3.034 3.034 0 00-1.449 1.242 2.118 2.118 0 00-.288.792v4.104a3.3 3.3 0 00.891.423c.33.102.765.153 1.305.153.96 0 1.728-.315 2.304-.945.576-.63.864-1.551.864-2.763 0-1.02-.201-1.809-.603-2.367-.402-.558-1.071-.837-2.007-.837zm9.276-.396a5.717 5.717 0 011.746-.648 9.544 9.544 0 011.908-.198c.612 0 1.113.096 1.503.288.39.192.696.441.918.747.222.306.372.654.45 1.044.078.39.117.783.117 1.179 0 .456-.012.942-.036 1.458a66.688 66.688 0 00-.054 1.548c0 .6.036 1.17.108 1.71h1.206V209h-2.394l-.162-1.35h-.09c-.072.108-.18.246-.324.414a2.964 2.964 0 01-.567.495 3.664 3.664 0 01-.855.423c-.336.12-.732.18-1.188.18-.888 0-1.59-.228-2.106-.684-.516-.456-.774-1.08-.774-1.872 0-.612.135-1.122.405-1.53.27-.408.657-.72 1.161-.936.504-.216 1.113-.342 1.827-.378.714-.036 1.515.012 2.403.144.06-.552.069-1.011.027-1.377-.042-.366-.138-.657-.288-.873a1.206 1.206 0 00-.63-.459c-.27-.09-.603-.135-.999-.135-.54 0-1.056.075-1.548.225-.492.15-.93.303-1.314.459l-.45-1.044zm2.646 7.254c.336 0 .648-.054.936-.162.288-.108.54-.246.756-.414a2.743 2.743 0 00.864-1.116v-1.26c-.624-.108-1.2-.162-1.728-.162s-.984.057-1.368.171c-.384.114-.684.291-.9.531-.216.24-.324.552-.324.936 0 .396.135.741.405 1.035.27.294.723.441 1.359.441zm9.168-7.956h2.142v-1.782l1.404-.396V200h4.806v1.206h-4.806v4.248c0 .876.213 1.524.639 1.944.426.42 1.035.63 1.827.63.54 0 1.011-.102 1.413-.306a7.614 7.614 0 001.089-.666l.468 1.062c-.42.336-.921.606-1.503.81a5.377 5.377 0 01-1.791.306c-.48 0-.933-.069-1.359-.207a3.12 3.12 0 01-1.125-.639 3.06 3.06 0 01-.774-1.107c-.192-.45-.288-.987-.288-1.611v-4.464h-2.142V200zm12.714-3.6h2.808v4.716h.09a4.03 4.03 0 011.296-.981c.492-.234 1.104-.351 1.836-.351.576 0 1.077.06 1.503.18.426.12.774.33 1.044.63s.471.711.603 1.233c.132.522.198 1.185.198 1.989V209h-1.404v-4.914c0-.516-.03-.966-.09-1.35-.06-.384-.177-.705-.351-.963a1.626 1.626 0 00-.711-.585c-.3-.132-.684-.198-1.152-.198a2.76 2.76 0 00-.954.171c-.312.114-.597.27-.855.468s-.48.438-.666.72a2.693 2.693 0 00-.387.927V209h-1.386v-11.394h-1.422V196.4zm21.246-.216l1.134.504-6.57 14.832-1.134-.504 6.57-14.832zm6.81 6.966a18.063 18.063 0 00-.081-1.512 5.988 5.988 0 00-.063-.468h-1.206V200h2.394l.18 1.26h.09a4.06 4.06 0 011.233-1.053c.498-.282 1.107-.423 1.827-.423 1.284 0 2.25.354 2.898 1.062.648.708.972 1.866.972 3.474 0 .756-.111 1.437-.333 2.043a4.295 4.295 0 01-.945 1.539c-.408.42-.9.744-1.476.972a5.141 5.141 0 01-1.908.342c-.252 0-.477-.009-.675-.027a5.93 5.93 0 01-.54-.072 4.255 4.255 0 01-.477-.117 6.561 6.561 0 01-.504-.18v3.78h-1.386v-9.45zm4.14-2.052c-.36 0-.699.066-1.017.198a3.034 3.034 0 00-1.449 1.242 2.118 2.118 0 00-.288.792v4.104a3.3 3.3 0 00.891.423c.33.102.765.153 1.305.153.96 0 1.728-.315 2.304-.945.576-.63.864-1.551.864-2.763 0-1.02-.201-1.809-.603-2.367-.402-.558-1.071-.837-2.007-.837zm9.276-.396a5.717 5.717 0 011.746-.648 9.544 9.544 0 011.908-.198c.612 0 1.113.096 1.503.288.39.192.696.441.918.747.222.306.372.654.45 1.044.078.39.117.783.117 1.179 0 .456-.012.942-.036 1.458a66.688 66.688 0 00-.054 1.548c0 .6.036 1.17.108 1.71h1.206V209h-2.394l-.162-1.35h-.09c-.072.108-.18.246-.324.414a2.964 2.964 0 01-.567.495 3.664 3.664 0 01-.855.423c-.336.12-.732.18-1.188.18-.888 0-1.59-.228-2.106-.684-.516-.456-.774-1.08-.774-1.872 0-.612.135-1.122.405-1.53.27-.408.657-.72 1.161-.936.504-.216 1.113-.342 1.827-.378.714-.036 1.515.012 2.403.144.06-.552.069-1.011.027-1.377-.042-.366-.138-.657-.288-.873a1.206 1.206 0 00-.63-.459c-.27-.09-.603-.135-.999-.135-.54 0-1.056.075-1.548.225-.492.15-.93.303-1.314.459l-.45-1.044zm2.646 7.254c.336 0 .648-.054.936-.162.288-.108.54-.246.756-.414a2.743 2.743 0 00.864-1.116v-1.26c-.624-.108-1.2-.162-1.728-.162s-.984.057-1.368.171c-.384.114-.684.291-.9.531-.216.24-.324.552-.324.936 0 .396.135.741.405 1.035.27.294.723.441 1.359.441zm18.042 1.494c0 .564-.108 1.059-.324 1.485a2.917 2.917 0 01-.891 1.053 4.02 4.02 0 01-1.323.621 6.185 6.185 0 01-1.638.207c-.708 0-1.326-.072-1.854-.216a5.515 5.515 0 01-1.368-.558l.684-1.278c.108.096.249.189.423.279.174.09.375.174.603.252.228.078.471.141.729.189.258.048.513.072.765.072.528 0 .969-.048 1.323-.144.354-.096.639-.246.855-.45.216-.204.372-.468.468-.792.096-.324.144-.72.144-1.188v-1.008h-.072c-.276.396-.63.702-1.062.918-.432.216-.99.324-1.674.324-1.368 0-2.373-.381-3.015-1.143-.642-.762-.963-1.947-.963-3.555 0-1.536.408-2.697 1.224-3.483.816-.786 2.028-1.179 3.636-1.179.744 0 1.377.051 1.899.153.522.102.999.231 1.431.387v9.054zm-4.014-1.44c.732 0 1.308-.189 1.728-.567.42-.378.714-.957.882-1.737v-4.266c-.528-.252-1.266-.378-2.214-.378-.96 0-1.716.282-2.268.846-.552.564-.828 1.428-.828 2.592 0 .516.048.987.144 1.413.096.426.249.795.459 1.107.21.312.486.555.828.729.342.174.765.261 1.269.261zm17.304-.144a4.53 4.53 0 01-.765.54 5.645 5.645 0 01-.963.432 7.06 7.06 0 01-1.089.279 6.633 6.633 0 01-1.143.099c-.72 0-1.356-.111-1.908-.333a3.674 3.674 0 01-1.386-.954 4.158 4.158 0 01-.846-1.485c-.192-.576-.288-1.224-.288-1.944 0-.756.105-1.428.315-2.016.21-.588.513-1.08.909-1.476a3.959 3.959 0 011.44-.909c.564-.21 1.194-.315 1.89-.315.504 0 1.002.066 1.494.198a2.95 2.95 0 011.305.747c.378.366.669.87.873 1.512.204.642.276 1.473.216 2.493h-6.966c0 1.08.291 1.887.873 2.421.582.534 1.359.801 2.331.801.324 0 .645-.039.963-.117.318-.078.621-.171.909-.279.288-.108.543-.228.765-.36.222-.132.393-.252.513-.36l.558 1.026zm-3.798-6.894a4.86 4.86 0 00-1.125.126 2.564 2.564 0 00-.936.423c-.27.198-.492.456-.666.774-.174.318-.285.711-.333 1.179h5.598c-.06-.792-.315-1.407-.765-1.845-.45-.438-1.041-.657-1.773-.657zm11.652 4.842a1.011 1.011 0 01-.018-.198v-.198c0-.504.093-.936.279-1.296.186-.36.417-.681.693-.963a6.74 6.74 0 01.891-.765c.318-.228.615-.471.891-.729s.507-.543.693-.855c.186-.312.279-.684.279-1.116 0-.228-.054-.474-.162-.738a2.314 2.314 0 00-.495-.738 2.501 2.501 0 00-.864-.558c-.354-.144-.777-.216-1.269-.216a3.7 3.7 0 00-1.071.144 4.343 4.343 0 00-.864.36 4.644 4.644 0 00-.702.477c-.21.174-.399.339-.567.495l-.918-.828a4.62 4.62 0 011.953-1.431c.798-.318 1.713-.477 2.745-.477.624 0 1.17.102 1.638.306.468.204.855.465 1.161.783.306.318.534.672.684 1.062.15.39.225.771.225 1.143 0 .576-.099 1.059-.297 1.449-.198.39-.447.738-.747 1.044-.3.306-.621.582-.963.828-.342.246-.663.51-.963.792-.3.282-.549.597-.747.945-.198.348-.297.774-.297 1.278h-1.188zm-.36 2.358c0-.324.093-.579.279-.765.186-.186.435-.279.747-.279.324 0 .582.093.774.279.192.186.288.441.288.765 0 .312-.096.564-.288.756-.192.192-.45.288-.774.288-.312 0-.561-.096-.747-.288-.186-.192-.279-.444-.279-.756zm11.112-5.022a18.063 18.063 0 00-.081-1.512 5.988 5.988 0 00-.063-.468h-1.206V200h2.394l.18 1.26h.09a4.06 4.06 0 011.233-1.053c.498-.282 1.107-.423 1.827-.423 1.284 0 2.25.354 2.898 1.062.648.708.972 1.866.972 3.474 0 .756-.111 1.437-.333 2.043a4.295 4.295 0 01-.945 1.539c-.408.42-.9.744-1.476.972a5.141 5.141 0 01-1.908.342c-.252 0-.477-.009-.675-.027a5.93 5.93 0 01-.54-.072 4.255 4.255 0 01-.477-.117 6.561 6.561 0 01-.504-.18v3.78h-1.386v-9.45zm4.14-2.052c-.36 0-.699.066-1.017.198a3.034 3.034 0 00-1.449 1.242 2.118 2.118 0 00-.288.792v4.104a3.3 3.3 0 00.891.423c.33.102.765.153 1.305.153.96 0 1.728-.315 2.304-.945.576-.63.864-1.551.864-2.763 0-1.02-.201-1.809-.603-2.367-.402-.558-1.071-.837-2.007-.837zm9.618 6.606h2.826v-9.468l-2.88 2.016-.702-1.026 3.96-2.826h1.008v11.304h2.772V209h-6.984v-1.296zm12.138-6.93h8.352v1.296h-8.352v-1.296zm0 2.952h8.352v1.296h-8.352v-1.296zm17.412 3.528h.198L502.16 200h1.566l-3.798 9h-1.584l-3.87-9h1.656l3.006 7.254zm10.05.45h2.826v-9.468l-2.88 2.016-.702-1.026 3.96-2.826h1.008v11.304h2.772V209h-6.984v-1.296zm11.454-2.43c0-.792.222-1.548.666-2.268.444-.72 1.062-1.326 1.854-1.818a11.046 11.046 0 01-.747-1.296c-.21-.432-.315-.9-.315-1.404 0-.288.048-.57.144-.846.096-.276.249-.522.459-.738.21-.216.48-.39.81-.522.33-.132.729-.198 1.197-.198.492 0 .906.063 1.242.189.336.126.606.291.81.495.204.204.351.432.441.684.09.252.135.51.135.774 0 .504-.195 1.023-.585 1.557-.39.534-1.005 1.047-1.845 1.539.192.348.417.705.675 1.071.258.366.531.729.819 1.089.288.36.582.717.882 1.071.3.354.6.681.9.981a3.19 3.19 0 00.351-.702c.102-.276.186-.564.252-.864a8.368 8.368 0 00.189-1.728h1.278a10.485 10.485 0 01-.36 2.259c-.204.75-.504 1.383-.9 1.899a5.657 5.657 0 001.35 1.188v1.53c-.636-.312-1.362-.87-2.178-1.674-.216.216-.435.423-.657.621a4.088 4.088 0 01-1.692.909 4.734 4.734 0 01-1.233.144c-.492 0-.972-.081-1.44-.243a3.787 3.787 0 01-1.26-.729 3.608 3.608 0 01-.9-1.224c-.228-.492-.342-1.074-.342-1.746zm6.678 1.368c-.348-.348-.69-.726-1.026-1.134a34.295 34.295 0 01-1.809-2.403 30.16 30.16 0 01-.657-.999c-.648.492-1.101.99-1.359 1.494a3.505 3.505 0 00-.387 1.62c0 .468.087.873.261 1.215.174.342.393.627.657.855.264.228.555.396.873.504.318.108.627.162.927.162.6 0 1.101-.135 1.503-.405.402-.27.741-.573 1.017-.909zm-3.816-8.154c0 .36.075.717.225 1.071.15.354.345.705.585 1.053.636-.408 1.077-.78 1.323-1.116.246-.336.369-.63.369-.882 0-.384-.093-.696-.279-.936-.186-.24-.507-.36-.963-.36-.432 0-.75.108-.954.324-.204.216-.306.498-.306.846zm11.526 4.662a18.063 18.063 0 00-.081-1.512 5.988 5.988 0 00-.063-.468h-1.206V200h2.394l.18 1.26h.09a4.06 4.06 0 011.233-1.053c.498-.282 1.107-.423 1.827-.423 1.284 0 2.25.354 2.898 1.062.648.708.972 1.866.972 3.474 0 .756-.111 1.437-.333 2.043a4.295 4.295 0 01-.945 1.539c-.408.42-.9.744-1.476.972a5.141 5.141 0 01-1.908.342c-.252 0-.477-.009-.675-.027a5.93 5.93 0 01-.54-.072 4.255 4.255 0 01-.477-.117 6.562 6.562 0 01-.504-.18v3.78h-1.386v-9.45zm4.14-2.052c-.36 0-.699.066-1.017.198a3.034 3.034 0 00-1.449 1.242 2.118 2.118 0 00-.288.792v4.104a3.3 3.3 0 00.891.423c.33.102.765.153 1.305.153.96 0 1.728-.315 2.304-.945.576-.63.864-1.551.864-2.763 0-1.02-.201-1.809-.603-2.367-.402-.558-1.071-.837-2.007-.837zm16.332-1.512c0 1.104-.522 2.334-1.566 3.69-1.044 1.356-2.502 2.832-4.374 4.428h6.336V209h-7.992v-1.296c.228-.216.54-.498.936-.846a57.05 57.05 0 001.278-1.161c.456-.426.921-.885 1.395-1.377a15.64 15.64 0 001.287-1.512 8.867 8.867 0 00.936-1.548c.24-.516.36-1.014.36-1.494 0-.72-.189-1.287-.567-1.701-.378-.414-.945-.621-1.701-.621-.648 0-1.194.072-1.638.216a3.988 3.988 0 00-1.206.63l-.612-.99a5.806 5.806 0 011.719-.846 6.962 6.962 0 011.989-.27c1.128 0 1.98.306 2.556.918.576.612.864 1.44.864 2.484zm5.424 1.188h8.352v1.296h-8.352v-1.296zm0 2.952h8.352v1.296h-8.352v-1.296zm17.412 3.528h.198L581.36 200h1.566l-3.798 9h-1.584l-3.87-9h1.656l3.006 7.254zm16.764-7.668c0 1.104-.522 2.334-1.566 3.69-1.044 1.356-2.502 2.832-4.374 4.428h6.336V209h-7.992v-1.296c.228-.216.54-.498.936-.846s.822-.735 1.278-1.161c.456-.426.921-.885 1.395-1.377a15.64 15.64 0 001.287-1.512 8.867 8.867 0 00.936-1.548c.24-.516.36-1.014.36-1.494 0-.72-.189-1.287-.567-1.701-.378-.414-.945-.621-1.701-.621-.648 0-1.194.072-1.638.216a3.988 3.988 0 00-1.206.63l-.612-.99a5.806 5.806 0 011.719-.846 6.962 6.962 0 011.989-.27c1.128 0 1.98.306 2.556.918.576.612.864 1.44.864 2.484zm12.966 8.424c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm-4.572 0c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm-4.536 0c0-.384.108-.681.324-.891.216-.21.504-.315.864-.315.384 0 .684.105.9.315.216.21.324.507.324.891 0 .348-.108.636-.324.864-.216.228-.516.342-.9.342-.36 0-.648-.114-.864-.342-.216-.228-.324-.516-.324-.864zm32.898-3.06h-2.61l-.702 3.006h-1.242l.702-3.006h-1.764l.252-1.152h1.782l.558-2.358h-1.692l.252-1.152h1.71l.684-2.844h1.242l-.684 2.844h2.61l.684-2.844h1.242l-.684 2.844h1.746l-.288 1.152h-1.728l-.558 2.358h1.674l-.288 1.152h-1.656l-.702 3.006h-1.242l.702-3.006zm-2.34-1.152h2.61l.558-2.358h-2.61l-.558 2.358zm9.456-7.398h2.808v4.716h.09a4.03 4.03 0 011.296-.981c.492-.234 1.104-.351 1.836-.351.576 0 1.077.06 1.503.18.426.12.774.33 1.044.63s.471.711.603 1.233c.132.522.198 1.185.198 1.989V209h-1.404v-4.914c0-.516-.03-.966-.09-1.35-.06-.384-.177-.705-.351-.963a1.626 1.626 0 00-.711-.585c-.3-.132-.684-.198-1.152-.198a2.76 2.76 0 00-.954.171c-.312.114-.597.27-.855.468s-.48.438-.666.72a2.693 2.693 0 00-.387.927V209h-1.386v-11.394h-1.422V196.4zm15.072 4.302a5.717 5.717 0 011.746-.648 9.544 9.544 0 011.908-.198c.612 0 1.113.096 1.503.288.39.192.696.441.918.747.222.306.372.654.45 1.044.078.39.117.783.117 1.179 0 .456-.012.942-.036 1.458a66.688 66.688 0 00-.054 1.548c0 .6.036 1.17.108 1.71h1.206V209h-2.394l-.162-1.35h-.09c-.072.108-.18.246-.324.414a2.964 2.964 0 01-.567.495 3.664 3.664 0 01-.855.423c-.336.12-.732.18-1.188.18-.888 0-1.59-.228-2.106-.684-.516-.456-.774-1.08-.774-1.872 0-.612.135-1.122.405-1.53.27-.408.657-.72 1.161-.936.504-.216 1.113-.342 1.827-.378.714-.036 1.515.012 2.403.144.06-.552.069-1.011.027-1.377-.042-.366-.138-.657-.288-.873a1.206 1.206 0 00-.63-.459c-.27-.09-.603-.135-.999-.135-.54 0-1.056.075-1.548.225-.492.15-.93.303-1.314.459l-.45-1.044zm2.646 7.254c.336 0 .648-.054.936-.162.288-.108.54-.246.756-.414a2.743 2.743 0 00.864-1.116v-1.26c-.624-.108-1.2-.162-1.728-.162s-.984.057-1.368.171c-.384.114-.684.291-.9.531-.216.24-.324.552-.324.936 0 .396.135.741.405 1.035.27.294.723.441 1.359.441zm16.494-1.386c0-.384-.15-.681-.45-.891-.3-.21-.672-.378-1.116-.504a20.643 20.643 0 00-1.449-.351 8.36 8.36 0 01-1.449-.432 3.247 3.247 0 01-1.116-.729c-.3-.306-.45-.735-.45-1.287 0-.456.099-.846.297-1.17.198-.324.459-.591.783-.801.324-.21.702-.366 1.134-.468a5.856 5.856 0 011.35-.153c.84 0 1.563.105 2.169.315.606.21 1.089.429 1.449.657l-.576 1.134a15.16 15.16 0 00-1.287-.621c-.462-.198-1.041-.297-1.737-.297-.264 0-.525.027-.783.081a2.767 2.767 0 00-.702.243c-.21.108-.378.249-.504.423a1.06 1.06 0 00-.189.639c0 .312.15.552.45.72.3.168.672.309 1.116.423.444.114.927.222 1.449.324a7.044 7.044 0 011.449.441c.444.192.816.45 1.116.774.3.324.45.762.45 1.314 0 .828-.327 1.512-.981 2.052-.654.54-1.635.81-2.943.81-.396 0-.786-.036-1.17-.108a7.096 7.096 0 01-1.08-.288 6.498 6.498 0 01-.918-.405 3.86 3.86 0 01-.684-.459l.72-1.17c.144.144.336.291.576.441a5.437 5.437 0 001.719.693 4.833 4.833 0 001.908.027c.282-.054.531-.138.747-.252.216-.114.387-.264.513-.45s.189-.411.189-.675zm5.388-10.17h2.808v4.716h.09a4.03 4.03 0 011.296-.981c.492-.234 1.104-.351 1.836-.351.576 0 1.077.06 1.503.18.426.12.774.33 1.044.63s.471.711.603 1.233c.132.522.198 1.185.198 1.989V209h-1.404v-4.914c0-.516-.03-.966-.09-1.35-.06-.384-.177-.705-.351-.963a1.626 1.626 0 00-.711-.585c-.3-.132-.684-.198-1.152-.198a2.76 2.76 0 00-.954.171c-.312.114-.597.27-.855.468s-.48.438-.666.72a2.693 2.693 0 00-.387.927V209h-1.386v-11.394h-1.422V196.4z"/><text id="hostname" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="147" y="152">hostname</tspan></text><text id="port" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="261" y="152">port</tspan></text><text id="pathname" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="334" y="152">pathname</tspan></text><text id="search" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="458" y="152">search (params)</tspan></text><text id="hash" fill="#AF6E24" font-family="PTMono-Regular, PT Mono" font-size="16" font-weight="normal"><tspan x="637" y="152">hash</tspan></text></g></g></svg>


  <b>Класс URL</b> предоставляет интерфейс для создания и разбора URL-адресов. Существует
стандарт, который определяет список разрешённых и запрещённых символов в URL.
  К счастью, <b>URL кодирует запрещённые символы автоматически:</b>
const url = new URL('https://ru.wikipedia.org/wiki/Тест')
url.searchParams.set('key', 'ъ')    <span>у экземпляра URL есть св-во <b>searchParams</b></span>
alert(url)    <span>https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A</span>



  <b>Нет сетевых методов, которые требуют именно объект URL, обычные строки тоже подходят.</b>
Но, <b>если мы используем строку, надо самим позаботиться о кодировании специальных символов,</b>
в отличае от использования класса URL, где кодировка автоматическая.
  Для кодирования строк есть встроенные функции:

encodeURI           – кодирует URL-адрес целиком
decodeURI           – декодирует URL-адрес целиком
encodeURIComponent  – кодирует компонент URL, например, параметр, хеш, имя пути и т.п.
decodeURIComponent  – декодирует компонент URL

* <b>URL считается устаревшим термином, более новый - URI</b>, поэтому и нет метода encodeURL


  Разница между encodeURIComponent() и encodeURI() в том, что <b>encodeURIComponent()
кодирует больше символов.</b>
  encodeURI не кодирует значения queryString или hash, а encodeURIComponent кодирует

<b>encodeURI не кодирует</b>:               цифры, латинские буквы, #-_.!~*'(),;,/?:@&=+$
<b>encodeURIComponent не кодирует</b>:      цифры, латинские буквы, -_.!~*'()


  Для построения параметров поиска есть специальный класс <b>URLSearchParams</b>:
const querySearchParams = new URLSearchParams({ offset: 0, page_number: 1 })
        </pre><pre>
          <code class="language-js">
   Пример 1

encodeURI('http://www.yourdomain.com/a file.html')  // http://www.yourdomain.com/a%20file.html



   Пример 2

const music = encodeURIComponent('Rock&Roll')
const url = `https://google.com/search?q=${music}`
alert(url)   // https://google.com/search?q=Rock%26Roll



   Пример 3

const link = `mailto:?subject=${encodeURIComponent(name)}
                &body=${encodeURIComponent(`Event Name: ${name}
                  Event Link: ${currentUrl}
                `)}
             `


   Пример 4

function buildNextPageURL(request, token) {
  const url = new URL(request)
  const { search } = url  // св-во search инстенса URL отдает компонент поиска (?p1=v1&p2=v2)

  url.search = search + encodeURIComponent(`&pageToken=${token}`)  // добавляем pageToken

  return url.toString()
}


   Пример 5

const page = (rawData) => {
  const querySearchParams = new URLSearchParams({ offset: 0, page_number: 1 })

  if (rawData) {
    const offset = rawData.response?._links?.next?.query_params?.offset
    querySearchParams.set('offset', offset)
  }

  return buildProxyURL(SOURCE_TYPE, `blog/${source}/posts?${querySearchParams}`)
}

export function buildProxyURL(provider, requestURL, params = {}) {
  const baseURL = `${meta.proxyUrl}/api/${provider}`
  const searchParams = new URLSearchParams({ q: requestURL, ...params })

  if (meta.proxyBypassCache) {
    searchParams.append('cache_bypass', 'true')
  }

  return `${baseURL}?${searchParams}`
}
          </code>
        </pre></article><article class="section-info" id="punycode"><b>ASCII / Punycode</b><pre>

  Изначально стандартом DNS была разрешена регистрация доменов, содержащих только
символы в кодировке <b>ASCII</b> — 26 букв латинского алфавита (a-z), цифры (0-9) и символ
дефиса (всего 37 символов)

  Однако с ростом количества пользователей, языки которых основаны на алфавитах отличающихся
от латинского, было решено ввести регистрацию доменов в кодировке Unicode, которая включает
символы всех национальных алфавитов. В результате этого решения появились многоязычные доменные
имена — Internationalized Domain Names (<b>IDN-домены</b>)

  <b>Punycode</b> — это стандартизированный метод преобразования символов, относящихся
к стандарту Unicode, в формат ASCII, поддерживаемый инфраструктурой DNS.
  Чтобы IDN-домен после преобразования нельзя было спутать с обычным доменом, <b>все IDN-домены
начинаются со специального префикса «XN--»</b>.
  Например, домен «домен.com.ua» в формате punycode будет выглядеть следующим образом:
xn--d1acufc.com.ua

  Преобразование домена в Punycode и обратно производится на стороне браузера, поэтому
при введении в адресную строку IDN-домена браузер сам конвертирует введенное значение для
взаимодействия с DNS

  <span>кодирует/декодирует разные форматы, например toASCII кодирует
  доменные имена на разных языках в латиницу (в кодировку ASCII):
  punycode.toASCII('mañana.com') → 'xn--maana-pta.com'</span>
  import { toASCII } from 'punycode'
        </pre></article><article class="section-info" id="request_methods"><b>request methods (CRUD) / AJAX / REST API / HTTP status codes</b><pre>

  <b>некоторые методы HTTP-запроса:</b>

<b>POST</b>     - (создание) sending new data                                <b>C - create</b>
<b>GET</b>      - (получение) getting new data                               <b>R - read</b>
<b>PUT</b>      - (полное обновление) updating existing data                 <b>U - update</b>
<b>DELETE</b>   - (удаление) delete existing data                            <b>D - delete</b>
<b>HEAD</b>     - запрашивает ресурс как и GET, но без тела ответа
<b>PATCH</b>    - (частичное обновление (например, какое то поле))
<b>OPTIONS</b>  - возвращает список доступных методов на сервере


* В GET запросах нельзя отправлять чувствительную информацию (например авторизационные
  данные), т.к. у GET запросов нет тела (body) запроса => данные можно отправить только
  в query параметрах, а это опасно, т.к. query параметры видны всем и не шифруются.
  А в https в теле, например, POST запроса передавать такую инфу безопасно.

* Передаваемые по сети данные в формате JSON-строки для обработки сначало нужно распарсить.

  Для сетевых запросов из JS есть широко известный термин <b>AJAX</b> - подход, позволяющий
отправлять сетевые запросы и получать ответы в фоновом режиме (без перезагрузки страницы
браузером) для обновления интерфейса.

<b>REST API</b>  —  (Representational State Transfer — «передача состояния представления»).
             По сути это API сервера: набор Еndpoint'ов для взаимодействия с ним.
               Сервер, получая какой то HTTP-запрос на REST API, может делать определенные
             запросы в DB и на основании полученных данных отвечать клиенту.
               В документациях прописывается правила взаимодействия: на какой Еndpoint
             слать запрос, какого типа делать запрос, что отправлять в запросе, какие
             данные отдаст сервер (html-документ (SSR), JSON (удобней всего) и т.д.)...

<b>Еndpoint</b>  —  url-адрес, на который мы шлем запрос на сервер, например для
             авторизации (то есть это интерфейс сервера)



<img src="/images/js_browser/http-status-codes.png" alt="http-status-codes" style="width: 65%;">
        </pre></article><article class="section-info" id="XMLHttpRequest"><b>XMLHttpRequest</b><pre>
  <b>XMLHttpRequest</b> – это встроенный в браузер объект, который даёт возможность
делать HTTP-запросы к серверу без перезагрузки страницы


                <b>3 шага чтобы сделать запрос:</b>

1. создать XMLHttpRequest:    const xhr = new XMLHttpRequest(); <span>у конструктора нет аргументов</span>

2. инициализировать его:      xhr.open(method, URL, [async, user, password])
<span>async           – если указать false, тогда запрос будет выполнен синхронно
user, password  – логин и пароль для базовой HTTP-авторизации (если требуется)</span>

3. Послать запрос:            xhr.send([body])
<span>Некоторые типы запросов, такие как GET, не имеют тела. А некоторые,
как, например, POST, используют body, чтобы отправлять данные на сервер</span>


  наиболее используемые <b>события на xhr</b>:
load      – происходит, когда получен ответ, включая ответы с HTTP-ошибкой, например 404
error     – когда запрос не может быть выполнен, например, нет соединения или невалидный URL
progress  – происходит периодически во время загрузки ответа, сообщает о прогрессе

  после ответа сервера мы можем получить <b>результат запроса в следующих свойствах xhr</b>:
status      - код состояния (200, 404, 403...)
statusText  - сообщение о состоянии ответа HTTP: обычно 'OK' для 200, 'Not Found' для 404
response    - тело ответа сервера

  можно использовать свойство <b>xhr.responseType, чтобы указать ожидаемый тип ответа:</b>
'' (по умолчанию)    – строка
'text'               – строка
'arraybuffer'        – ArrayBuffer (для бинарных данных)
'blob'               – Blob (для бинарных данных)
'document'           – XML-документ (может использовать XPath и другие XML-методы)
'json'               – JSON (чтобы ответ был в виде распаршеного json)

  у XMLHttpRequest есть <b>состояния, которые меняются по мере выполнения запроса;</b>
текущее состояние можно посмотреть в свойстве xhr.readyState (старое); список всех состояний:
UNSENT = 0;              исходное состояние
OPENED = 1;              вызван метод open
HEADERS_RECEIVED = 2;    получены заголовки ответа
LOADING = 3;             ответ в процессе передачи (данные частично получены)
DONE = 4;                запрос завершён


  XMLHttpRequest умеет как указывать свои <b>заголовки</b> в запросе,
так и читать присланные в ответ. Для работы с HTTP-заголовками есть 3 метода:
setRequestHeader(name, value)  ( xhr.setRequestHeader('Content-Type', 'application/json') )
getResponseHeader(name)        ( xhr.getResponseHeader('Content-Type') )
getAllResponseHeaders()        возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2;
                               в виде единой строки


        </pre><pre>

<b class="center">пример XMLHttpRequest</b>
<code class="language-js">
const requestURL = 'https://jsonplaceholder.typicode.com/users'

function sendRequest(method, url, body = null) {
  return new Promise( (resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open(method, url)
    // указываем, что отправляем данные в формате json (по дефолту стоит text/plain)
    xhr.setRequestHeader('Content-Type', 'application/json')
    xhr.send( JSON.stringify(body) ) // для GET без аргумента!
    xhr.responseType = 'json' // чтобы ответ был в виде распарсеного json
    xhr.onload = () => {
      if (xhr.status >= 400) { // если статус-код > 400 (ошибка)
        reject(xhr.response)
      } else {
        resolve(xhr.response)
      }
    }
    xhr.onerror = () => {
      console.log('нет соединения или невалидный URL')
    }
  })
}

sendRequest('GET', requestURL)
  .then(data => console.log(data))
  .catch(err => console.log(err))

const body = {
  name: 'anton',
  age: 27
}
// во вкладке network видно как статус становится 201 - created (создание чего-то)
sendRequest('POST', requestURL, body)
  .then(data => console.log(data))
  .catch(err => console.log(err))
        </code>
        </pre></article><article class="section-info" id="fetch"><b>fetch / headers / body</b><pre>
<b>fetch</b> – современный браузерный метод для сетевых AJAX запросов и получения информации от сервера

  типичный <b>запрос с помощью fetch</b> состоит из двух операторов await:

<b>const response = await fetch(url, options)</b>   <span>завершается с заголовками ответа</span>
<b>const result = await response.json()</b>         <span>читать тело ответа в формате JSON</span>

  или:

  fetch(url, options)
    .then(response => response.json())
    .then(result => console.log(result))

* без options это простой GET-запрос, скачивающий содержимое по адресу url


    <b>процесс получения ответа обычно происходит в два этапа:</b>

1. promise выполняется с объектом встроенного класса Response в качестве
   результата, как только сервер пришлёт заголовки ответа.
    На этом этапе можно проверить статус HTTP-запроса и определить,
   выполнился ли он успешно, а также посмотреть заголовки, но пока без
   тела ответа. Можно увидеть HTTP-статус в свойствах ответа:
<b>response.status</b>  - код статуса HTTP-запроса
<b>response.ok</b>      – будет true, если код HTTP-статуса в диапазоне 200-299

2. для получения тела ответа нам нужно использовать дополнительный вызов
   метода. Response предоставляет несколько <b>методов (возвращающих промисы)
   для доступа к телу ответа в различных форматах:</b>
<b>response.text()</b>        – читает ответ и возвращает как обычный текст
<b>response.json()</b>        – декодирует ответ в формате JSON
<b>response.formData()</b>    – возвращает ответ как объект FormData
<b>response.blob()</b>        – возвращает объект как Blob (бинарные данные с типом)
<b>response.arrayBuffer()</b> – возвращает ответ как ArrayBuffer (низкоуровневое
                         представление бинарных данных)
<b>response.body</b>          – это объект ReadableStream («поток для чтения»), с
                         помощью которого можно считывать тело запроса по частям


  <b>заголовки ответа</b> хранятся в похожем на Map объекте <b>response.headers</b>. Это не
совсем Map, но мы можем использовать такие же методы, как с Map, чтобы получить
заголовок по его имени или перебрать заголовки в цикле:
const url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits'
const response = await fetch(url)
  <span>получить один заголовок</span>
alert(response.headers.get('Content-Type'))   // application/json; charset=utf-8
  <span>перебрать все заголовки</span>
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`)
}


  <b>для отправки POST запроса в fetch нужно указывать дополнительные параметры (method,
body (тело запроса то есть то с чем отправляется запрос), headers)</b>, например:

let user = {
  name: 'John',
  surname: 'Smith'
}
let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'  <span>указываем серверу отправляемый формат данных (MIME type).</span>
                                        <span>При отправке объекта FormData (форма) - 'form/multipart'</span>
  },
  body: JSON.stringify(user)
})
let result = await response.json()
alert(result.message)
        </pre><pre>

<b class="center">пример fetch (GET)</b>
<code class="language-js">
const requestFetchURL = 'https://jsonplaceholder.typicode.com/todos'

async function sendFetchGET(url) {
  try {
    let response = await fetch(url)
    if (response.ok) {  // если HTTP-статус в диапазоне 200-299
      // получаем тело ответа (await возвращает результат промиса; json() возвращает промис)
      let json = await response.json()
      console.log(json)
    } else {
      // попадем сюда, если напимер запрос на 'https://jsonplaceholder.typicode.com/todosqqq'
      console.error(`Ошибка HTTP: статус ${response.status}`)
    }
  }
  catch(err) {
    // если например мы обратились к несуществующей странице
    // 'https://jsonplaceholder.typicode.com/todosqqq' на сервере
    // (404 ошибка) и response.ok == false, то мы сюда не попадем
    console.error(`ошибка при запросе, возможно не дошел до сервера`)
  }
}
sendFetchGET(requestFetchURL)
        </code>
        </pre><pre>

<b class="center">пример fetch (POST)</b>
<code class="language-js">
const requestFetchURL_POST = 'https://jsonplaceholder.typicode.com/albums'

function sendFetchPOST(method, url, body = null) {
  // т.к. тело запроса body – строка, то заголовок Content-Type по умолчанию будет text/plain
  const headers = {
    'Content-Type': 'application/json'
  }
  return fetch(url, {
    method: method,
    body: JSON.stringify(body),
    headers: headers
  })
    .then( response => {
      if (response.ok) {
        return response.json()
      }
      // если код HTTP-статуса не в диапазоне 200-299
      return response.json().then( error => {
        const e = new Error(`Что то пошло не так...  ошибка ${response.status}`)
        e.data = error
        throw e
      })
    })
}

const body = {
  name: 'Vladilen',
  age: 26
}
sendFetchPOST('POST', requestFetchURL_POST, body)
  .then(data => console.log(data))
  .catch(err => console.log(err))
        </code>
        </pre></article><ul class="section-refs"><li><a href="http://xn--80adth0aefm3i.xn--j1amh/fetch" target="_blank">fetch</a></li></ul></div></section><!-- http caching --><section class="section" id="http_caching"><div class="section-container"><h2 class="section-title">http caching</h2><article class="section-info"><img src="images/js_browser/http_caching_1.png" alt="http_caching_1" style="max-width: 49%; display: inline-block;"> <img src="images/js_browser/http_caching_2.png" alt="http_caching_2" style="max-width: 49%; display: inline-block;"> <img src="images/js_browser/http_caching_3.png" alt="http_caching_3" style="max-width: 49%; display: inline-block;"> <img src="images/js_browser/http_caching_4.png" alt="http_caching_4" style="max-width: 49%; display: inline-block;"> <img src="images/js_browser/http_caching_5.png" alt="http_caching_5" style="max-width: 49%; display: inline-block;"></article></div></section><!-- CORS --><section class="section" id="cors"><div class="section-container"><h2 class="section-title">CORS</h2><article class="section-info"><pre>
  Две страницы имеют одинаковый origin (источник) если протокол, хост (домен)
и порт (если указан) одинаковы для обоих страниц.
  <b>origin</b> - это протокол + домен + порт (если указан): https://javascript.info


            <b>Правило одного источника (same-origin)</b>:
  Если браузер запросил страницу из домена a.com, то и ajax-запрос из
загруженного на странице js файла должен быть послан по домену a.com.
Это касается и картинок, шрифтов, стилей запрашиваемых из других источников.

  При запросе на другой источник браузер всегда ставит «от себя»
заголовок Origin, значением которого является домен источника
(Origin: https://www.a.com).

            <b>Доверенный источник (CORS)</b>:
  <b>CORS</b> (Cross-Origin Resource Sharing) — механизм, использующий дополнительные
HTTP-заголовки, чтобы дать возможность браузеру получать разрешения на доступ
к выбранным ресурсам с сервера на источнике (домене), отличном от того, что
сайт использует в данный момент.
  Что бы сервер (b.com) разрешил браузеру делать запрос на другой источник (b.com),
сервер может проверить Origin (Origin: https://www.a.com) и, если он согласен принять
такой запрос, добавить особый заголовок <b>Access-Control-Allow-Origin</b> к ответу:
Access-Control-Allow-Origin: a.com


            Есть два вида запросов на другой источник:

- <b>Простые</b>. Простой запрос – это запрос, удовлетворяющий следующим условиям:
    Простой метод: GET, POST или HEAD
    Простые заголовки – разрешены только:
      Accept,
      Accept-Language,
      Content-Language,
      Content-Type со значением application/x-www-form-urlencoded,
                                multipart/form-data или text/plain
- <b>Все остальные</b>.
  Когда мы пытаемся сделать непростой запрос, браузер посылает специальный
  предварительный запрос (<b>preflight</b>) с методом OPTIONS, который спрашивает
  у сервера – согласен ли он принять такой непростой запрос или нет?
  И, если сервер явно не даёт согласие в заголовках preflight-ответа, непростой
  запрос не посылается.


            <b>CORS proxy</b> (для избежания CORS ошибок):
  CORS proxy - прокси-сервер (посредник между браузером и другим
источником (b.com)), на который идет запрос браузера.
  При запросе прокси-сервер отсылает запрос другому источнику (b.com) ->
получает ответ без CORS заголовка (Access-Control-Allow-Origin) ->
добавляет заголовки и отправляет ответ браузеру уже с заголовком.
Пример:
CORS_PROXY = 'https://cors-proxy.elfsight.com/'
Запрос: CORS_PROXY + 'https://files.elfsight.com/storage/a277.png'



              <b>XSS (Cross-site Scripting)</b>
  Cross-site Scripting - распространенный тип веб-атаки, заключающийся во
внедрении на страницу сайта или приложения вредоносного js-кода.
  XSS является способом обхода правила одного источника.
  Нельзя просто взять и вставить скрипт, чтобы он подгружался/исполнялся
на другом домене, это называется XSS (межсайтовый скриптинг)
        </pre></article></div></section><!-- Cookies & Storages --><section class="section" id="cookies&storages"><div class="section-container"><h2 class="section-title">Cookies & L/S Storages</h2><article class="section-info"><pre>
<b>Способы хранения данных в браузере:</b>

1. Local Storage
2. Session Storage
3. Cookies


- Cookies в отличае от Local Storage могут хранить намного меньше данных
  (LS ~5mb, Cookies 4kb)
- Local / Session Storage как и Cookies так же привязан к конкретному домену
- Мы можем сами устанавливать время жизни для Cookie
- С каждым запросом на сервер автоматически отправляются Cookies (которые установил
  сервер в header'е Set-Cookie при первом запросе от клиента) и сервер так же может
  перезаписывать эти Cookies в последующих ответах на клиент
- В отличае от LS, Cookies служат для передачи данных между клинтом и сервером,
  в то время как LS только для хранения данных на клиенте
        </pre></article><article class="section-info"><b>Local / Session Storage:</b><pre>
  Разница между Local Storage и Session Storage только в том, что в Session Storage данные
стираются каждый раз, когда пользователь закрывает браузер (т.е. когда завершается сеанс),
а в Local Storage нет

* key и value должны быть строками;
  если value объект/массив..., то JSON.stringify(value)

* лимит 2 Мб+, зависит от браузера


    <span>API (localStorage и sessionStorage)</span>:
setItem(key, value) – сохранить пару ключ/значение
getItem(key)        – получить данные по ключу key
removeItem(key)     – удалить значение по ключу key
clear()             – удалить всё
key(index)          – получить ключ на заданной позиции
length              – количество элементов в хранилище

* все методы синхронны

* событие storage срабатывает при вызове setItem, removeItem, clear
        </pre></article><article class="section-info"><b>Cookies:</b><pre>
  Cookie – это небольшие строки данных, которые я <b>получаю от сервера при первом запросе
(сохраняются в браузере с привязкой к домену)</b>, когда захожу на сайт. А <b>при последующих
запросах (например, браузер запрашивает другую страницу) cookie автоматически отпраляются
на сервер в header'e запроса</b>.
  Как и любой другой HTTP-заголовок, cookie передаются в браузер до того, как будут
переданы какие-либо другие данные. Header от сервера, сохраняющий куку в браузер:
Set-Cookie: name=value. Браузер запоминает строку name=value и отправляет её обратно
серверу в качестве header'a с каждым последующим запросом (Cookie: name=value). Таким
образом, сервер узнает, что этот запрос связан с предыдущим. Сервер отвечает, отправляя
запрашиваемую страницу и, возможно, добавив новые cookie. Значение cookie может быть
изменено сервером путём отправления новых строк Set-Cookie: name=new_value. После этого
браузер заменяет старое cookie с тем же name на новую строку.
  Cookie также могут устанавливаться из JavaScrip.

  * Cookie служат для клиент-серверной коммуникация с поддержанием состояния
(например, в куках храним тему сайта или статус авторизации).




                                 <b>виды cookies:</b>

<img src="/images/js_browser/cookies.png" alt="cookies">
- сессионые (temporary) - они существуют только во время посещения сайта и
удаляются только когда закрою браузер. В отличие от других типов cookie,
сессионные cookie не имеют истечения срока действия. Любой файл "cookie",
созданный без даты истечения срока действия, автоматически является сеансовым.
Простой пример использования временного файла "cookie" - запись в память данных
о наполнении корзины в интернет-магазине.
- постоянные (first-party cookies) - хранятся определенный промежуток времени
установленный в Expires и потом удаляются
- сторонние (third-party cookies) - куки, которые не принадлежат текущему домену
- zombie-cookie - куки, которые разработчики так прячут в браузере, что
они остаются и после очистки. Там используется дополнительное хранилище
(Local Storage, Session Storage)

  Часто в таблице с куками во вкладке Application можно встретить куки, которые
не принадлежат этому домену (сторонние куки: <b>third-party cookies</b>). Это происходит
потому что сайт использует не только свои рессурсы, но и какие то сторонние (рекламы,
карты, виджеты, даже подключение скриптов через cdn), которые и создают сторонние куки.
  third-party cookie – это cookie, созданная не тем доменом, который вы посетили.
  third-party cookies, также известные как <b>отслеживающие</b>, т.к. могут использоваться
для слежки и аналитики.
  В отличие от основных файлов cookie, сторонние cookie создаются на чужом сайте с помощью
различных виджетов (т.е посещая такой сайт вы цепляете файл cookie этого сайта + файл cookie,
который создан виджетами и принадлежит другому сайту).
  Это позволяет создателю third-party cookie собирать и получать данные в любое время, когда
пользователь посещает другие страницы/сайты с принадлежащим ему (создателю third-party
cookies) ресурсом.
  Таким образом создатель third-party cookies знает какие сайты и страницы посещал
пользователь



                            <b>запись / чтение cookies</b>

  Получить все куки для сайта (домена), кроме тех у которых стоит галочка в
колонке HTTPOnly, можно с помощью <b>document.cookie</b>. Значение состоит из пар
ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки

  Чтобы найти определённое куки, достаточно разбить строку из document.cookie
по ;, и затем найти нужный ключ

  <b>Пример создания cookie</b>, которая добавляется в хранилище:
document.cookie = 'someKey=someValue;expires=Sun, 16 Jul 3567 06:23:41 GMT'

 * Запись в document.cookie обновит только упомянутые в ней куки, но при этом
не затронет все остальные
document.cookie = 'user=John' <span>обновляем только куки с именем 'user'</span>

  * специальные символы (пробелы), требуется кодирование
let name = 'my name'
let value = 'John Smith'
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value)

 * одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера)





           Файлы Cookie хранятся в специальном <b>хранилище Cookies (вкладка Application):</b>

  <b>Name</b>      <b>Value</b>            <b>Domain</b>                     <b>Path</b>                    <b>Expires</b>
любое      любое      показывает какой домен     путь к дерриктории         время когда кука
название   строковое  или поддомен имеет         на сервере, для которой    будет просрочена
           значение   доступ к этой Cookie:      будут доступны куки        и удалена из        ->
                       .google.com - доступна    (/ - корневой католог,     браузера
                      для всего домена,          т.е. куки доступны всему
                      включая поддомены          домену)
                       .pol.google.com -
                      только для поддомена

 <b>Size</b>       <b>HTTPOnly</b>          <b>Secure</b>                          <b>SameSite</b>
размер   параметр который   указывает что     указывает что куки не должны отсылаться с
куки     запрещает доступ   куки должны       межсайтовыми запросами (сайты могут общаться
         к куки с помощью   передаваться на   между собой запросами и так же передавать
         встроенного API    сервер только с   друг другу куки, особенно когда на свой сайт
         внутри браузера:   помощью HTTPS     подключаю сторонние плагины (гугл-карта...).
         document.cookie                      Они могут устанавливать куки на ваш сайт)
                                               None - на передачу куки не накладывается
                                              никаких ограничений
                                               Strict - блокирует отправку куки с любыми
                                              запросами от других рессурсов. Это значит
                                              что куки будут передаваться только в пределах
                                              домена, указанного в поле Domain (&lt;-)
                                               Lax - разрешает передачу куки только
                                              безопасными HTTP-методами: GET, HEAD, OPTIONS
                                              и TRACE



  Я принимаю куки в попапе cookies consent => срабатывает callback, подгружающий или
инициализирующий метрики, google-аналитики или другие сервисы, запрашивающие согласие
на принятие куки.




                         <b>Cookies могут использоваться для</b>:

- Аутентификации. Например, куки может уведомлять сервер, что я уже залогинен на сайте
и что сессия еще не истекла. В куки файлах почти не хранятся логин и пароль от какого то
сайта, но хранится идентификатор того, что конкретный пользователь уже залогинен на сайте.
  При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы
установить куки со специальным уникальным идентификатором сессии. Во время следующего
запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie. Таким образом,
сервер понимает, кто сделал запрос.
- Аналитики. cookie будет автоматически отправляться браузером на сервер каждый раз,
когда запрашивается новая страница с сайта. Сервер не только отправляет страницу как
обычно, но также сохраняет URL запрошенной страницы, дату / время запроса и файл cookie
в файле журнала. Анализируя этот файл журнала, можно определить, какие страницы посетил
пользователь, в какой последовательности и как долго.
- Персонализация. Каждый раз, когда пользователь получает доступ к странице на веб-сайте,
сервер может персонализировать страницу в соответствии с ранее выбранными предпочтениями
(например, светлая/темная тема)
- Отслеживание. Если вы когда-либо покупали или просто смотрели продукт на Amazon, а
затем начали видеть объявления о похожих продуктах на других веб-сайтах - вы попали под
ретаргетинг. Синхронизация файлов cookie происходит, когда две рекламные компании
объединяются или приобретают базы друг у друга. Эта консолидация помогает им конкурировать
с Google, но также оказывает негативное влияние на конфиденциальность пользователей.



  Если я логинюсь на сайте без ssl-сертификата (http) в общественной сети (например
из кафе), то теоретически хакеры могут взламать мой трафик и получить доступ к куки,
благодаря чему использовать его на этом же сайте, обойдя логин и пароля и быть
авторизированными под моим акком. Установленный в куке параметр Secure предотвратит
такой взлом, т.к. такие куки передаются только с помощью HTTPS.
        </pre></article></div></section><!--animation--><section class="section" id="animation"><div class="section-container"><h2 class="section-title">animation</h2><article class="section-info"><pre>
  Есть несколько известных способов работать с анимацией в JS. Например, можно
использовать функцию таймера — setTimeout или setInterval — и обновлять стили каждые
несколько миллисекунд.
  Другой подход — создать цикл, который изменяет стили насколько возможно часто в
тот период, пока анимация продолжается. <b>Логика обоих подходов такая</b>: дать браузеру
большое количество кадров анимации и надеяться на то, что он выдаст плавное движение.
  Однако на практике эти решения оставляют желать лучшего. Движок рендеринга часто
захлебывается на большом количестве задач рендеринга — и зачастую еще не может отобразить
кадр, когда уже получает инструкции на отображение следующего. Так что даже если браузер и
рендерит столько кадров анимации, сколько может, из-за выпавших кадров анимация все равно
получается рваной, не говоря уже о проблемах с производительностью, к которым приводит
решение нагрузить процессор слишком большим количеством задач.

  В действительности лучше отображать меньшее количество кадров в секунду, но сделать это
количество постоянным. Дело в том, что наш глаз воспринимает небольшие отклонения в частоте,
и несколько выпавших кадров режут глаз больше, чем более низкое количество кадров в секунду.
Вот здесь на помощь приходит встроенный в HTML5 API <b>requestAnimationFrame</b>.
  Анимация реализуется через последовательность кадров, каждый из которых немного меняет
HTML/CSS-свойства. requestAnimationFrame выполняет передаваемый в нее callback примерно
каждые 16,7ms - 60fps ( 1000ms / 60frames = 16.7ms ).
  Стандарт обновления монитора 60 Герц, то есть 60 раз/секунду; requestAnimationFrame не
ривязана ко времени, она привязана к частоте обновления экрана

let requestId = requestAnimationFrame(callback) - выполнить callback при первой
                                                  возможности, а не с заданным интервалом
callback имеет один аргумент – время прошедшее с момента начала загрузки страницы в
                               миллисекундах (timestamp); такой вызов планирует запуск
                               функции callback на ближайшее время, когда браузер сочтёт
                               возможным осуществить анимацию

  если в callback происходит изменение элемента, тогда оно будет сгруппировано с другими
requestAnimationFrame и CSS-анимациями. Таким образом браузер выполнит один геометрический
пересчёт и отрисовку, вместо нескольких

                                  <b>пример requestAnimationFrame:</b>
animateBar(bar) {
  const animate = () => {
    if (this.start &lt; this.end) {
      this.start++;
      bar.style.width = `${this.start}%`
      requestAnimationFrame(animate)
    }
  }

  requestAnimationFrame(animate)
}


  значение requestId может быть использовано для отмены анимации:
<b>cancelAnimationFrame(requestId)</b>

  Когда завершается анимация, срабатывает событие <b>transitionend</b>.
Объект события transitionend содержит ряд полезных свойств:
event.propertyName - имя свойства, анимация которого завершилась.
                     Может быть полезным, если мы анимируем несколько свойств
event.elapsedTime  - время (в сек), которое заняла анимация, без учёта transition-delay
        </pre></article></div></section><!--FormData--><section class="section" id="formData"><div class="section-container"><h2 class="section-title">FormData</h2><article class="section-info"><pre>
  <b>FormData</b> - это объект, представляющий данные HTML формы. Если передать в конструктор
элемент HTML-формы form, то создаваемый объект автоматически прочитает из неё поля

const formData = new FormData([form])

  Методы для работы с сетью, например fetch, позволяют указать объект FormData в свойстве
тела запроса body. Он будет соответствующим образом закодирован и отправлен с заголовком
<b>Content-Type: form/multipart</b>. То есть, для сервера это выглядит как обычная отправка формы.


  <b>методы для изменения полей в объекте FormData:</b>

<b>formData.append(name, value)</b>          – добавляет к объекту поле с именем name и значением value
<b>formData.append(name, blob, fileName)</b> – добавляет поле, как будто в форме имеется элемент
                                        &lt;input type="file">, третий аргумент fileName
                                        устанавливает имя файла, как будто это имя из файловой
                                        системы пользователя
<b>formData.delete(name)</b>                 – удаляет поле с заданным именем name
<b>formData.get(name)</b>                    – получает значение поля с именем name
<b>formData.has(name)</b>                    – если существует поле с именем name, то возвращает true

  set удаляет все уже имеющиеся поля с именем name и только затем
добавляет новое. То есть этот метод гарантирует, что будет существовать
только одно поле с именем name, в остальном он аналогичен .append:
<b>formData.set(name, value)</b>
<b>formData.set(name, blob, fileName)</b>

  Поля объекта formData можно перебирать, используя цикл for..of:
for (let [name, value] of formData)
        </pre><pre>

  <b>пример:</b>
          <code class="language-js">
&lt;form id='formElem'>
  &lt;input type='text' name='firstName' value='John'>
  &lt;input type='file' name='picture' accept='image/*'>
  &lt;input type='submit'>
&lt;/form>

formElem.onsubmit = async (e) => {
  e.preventDefault()
  const response = await fetch('/article/formdata/post/user-avatar', {
    method: 'POST',
    body: new FormData(formElem)
  })
  const result = await response.json()
  alert(result.message)
}
          </code>
        </pre></article></div></section><!-- MutationObserver --><section class="section" id="mutationObserver"><div class="section-container"><h2 class="section-title">MutationObserver</h2><article class="section-info"><pre>
  <b>MutationObserver</b> – это встроенный объект, наблюдающий за DOM-элементом и запускающий
колбэк в случае изменений.
  MutationObserver может реагировать на изменения в DOM: атрибуты, добавленные/удалённые
элементы, текстовое содержимое.

  Мы можем использовать его, чтобы отслеживать изменения, производимые другими частями нашего
собственного кода, а также интегрироваться со сторонними библиотеками.


<span>сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции</span>:
const observer = new MutationObserver(callback)

<span>потом прикрепляем его к DOM-узлу</span>:
observer.observe(node, config)

<b>config</b> – это объект с булевыми параметрами «на какие изменения реагировать»

  После изменений выполняется callback, в который изменения передаются первым аргументом
как массив объектов MutationRecord, а сам наблюдатель (экземпляр MutationObserver) идёт
вторым аргументом
        </pre></article><ul class="section-refs"><li><a href="https://learn.javascript.ru/mutation-observer" target="_blank">MutationObserver</a></li></ul></div></section></main><script src="index.js"></script></body></html>